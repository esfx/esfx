{
  "index.html": {
    "href": "index.html",
    "title": "@esfx reference | @esfx API Reference",
    "keywords": "The @esfx suite of packages is designed to provide low-level interoperability between 3rd-party packages for a number of common operations. Packages The main packages in the @esfx suite include: @esfx/async - Provides a number of asynchronous coordination primitives from the following packages: @esfx/async-autoresetevent @esfx/async-barrier @esfx/async-canceltoken @esfx/async-conditionvariable @esfx/async-countdown @esfx/async-deferred @esfx/async-delay @esfx/async-lazy @esfx/async-lockable @esfx/async-manualresetevent @esfx/async-mutex @esfx/async-queue @esfx/async-readerwriterlock @esfx/async-semaphore @esfx/async-stack @esfx/async-waitqueue @esfx/cancelable - A low-level Symbol-based API for defining a common cancellation protocol. @esfx/collection-core - A low-level Symbol-based API for defining common collection behaviors. @esfx/collections - A common collections API composed of the following packages: @esfx/collections-hashmap @esfx/collections-hashset @esfx/collections-linkedlist @esfx/collections-sortedmap @esfx/collections-sortedset @esfx/disposable - A low-level Symbol-based API for defining explicit resource management. @esfx/equatable - A low-level Symbol-based API for defining equality. @esfx/events - A low-level API for defining events. @esfx/indexed-object - A base class for custom integer-indexed objects. @esfx/lazy - Provides a class to simplify lazy-initialization logic. @esfx/metadata - An API for defining metadata about an object. @esfx/ref - A low-level API for defining forward references. @esfx/threading - Thread synchronization primitives for use with Workers: @esfx/threading-autoresetevent @esfx/threading-conditionvariable @esfx/threading-countdown @esfx/threading-lockable @esfx/threading-manualresetevent @esfx/threading-mutex @esfx/threading-semaphore @esfx/threading-sleep @esfx/threading-spinwait @esfx/type-model - A number of useful types for TypeScript. Shims Shim packages augment built-in objects with functionality from the main packages. @esfx/cancelable-dom-shim @esfx/collection-core-shim @esfx/collection-core-dom-shim @esfx/equatable-shim @esfx/metadata-shim @esfx/reflect-metadata-compat Adapters Adapter packages provide functionality to simplify interoperability scenarios with different platforms: @esfx/cancelable-dom"
  },
  "api/decorators-stage1-core/fieldmemberdescriptor.html": {
    "href": "api/decorators-stage1-core/fieldmemberdescriptor.html",
    "title": "Interface FieldMemberDescriptor | @esfx API Reference",
    "keywords": "Interface FieldMemberDescriptor Interfaces Properties descriptor Declaration descriptor?: undefined; Property Value Type Description undefined"
  },
  "api/decorators-stage1-core/classdescriptor.html": {
    "href": "api/decorators-stage1-core/classdescriptor.html",
    "title": "Interface ClassDescriptor | @esfx API Reference",
    "keywords": "Interface ClassDescriptor Interfaces Properties kind Declaration kind: \"class\"; Property Value Type Description \"class\" target Declaration target: T; Property Value Type Description T"
  },
  "api/collections-linkedlist/linkedlist.html": {
    "href": "api/collections-linkedlist/linkedlist.html",
    "title": "Class LinkedList | @esfx API Reference",
    "keywords": "Class LinkedList Classes Constructors constructor(equaler) Constructs a new instance of the LinkedList class Declaration constructor(equaler?: EqualityComparison<T> | Equaler<T>); Parameters Name Type Description equaler EqualityComparison<T> | Equaler<T> constructor(iterable, equaler) Constructs a new instance of the LinkedList class Declaration constructor(iterable?: Iterable<T>, equaler?: EqualityComparison<T> | Equaler<T>); Parameters Name Type Description iterable Iterable<T> equaler EqualityComparison<T> | Equaler<T> Classes Properties __@toStringTag Declaration [Symbol.toStringTag]: string; Property Value Type Description string [ReadonlyCollection.size] Declaration readonly [ReadonlyCollection.size]: number; Property Value Type Description number equaler Declaration readonly equaler: Equaler<T>; Property Value Type Description Equaler<T> first Declaration readonly first: LinkedListNode<T> | undefined; Property Value Type Description LinkedListNode<T> | undefined last Declaration readonly last: LinkedListNode<T> | undefined; Property Value Type Description LinkedListNode<T> | undefined size Declaration readonly size: number; Property Value Type Description number Classes Methods __@iterator() Declaration [Symbol.iterator](): IterableIterator<T>; Returns Type Description IterableIterator<T> [ReadonlyCollection.has](value) Declaration [ReadonlyCollection.has](value: T): boolean; Parameters Name Type Description value T Returns Type Description boolean clear() Declaration clear(): void; Returns Type Description void delete(value) Declaration delete(value: T): LinkedListNode<T> | undefined; Parameters Name Type Description value T Returns Type Description LinkedListNode<T> | undefined deleteAll(predicate, thisArg) Declaration deleteAll(predicate: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): number; Parameters Name Type Description predicate (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean thisArg any Returns Type Description number deleteNode(node) Declaration deleteNode(node: LinkedListNode<T> | null | undefined): boolean; Parameters Name Type Description node LinkedListNode<T> | null | undefined Returns Type Description boolean drain() Declaration drain(): IterableIterator<T>; Returns Type Description IterableIterator<T> every(callback, thisArg) Declaration every(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): boolean; Parameters Name Type Description callback (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean thisArg any Returns Type Description boolean filter(callback, thisArg) Declaration filter<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): LinkedList<S>; Parameters Name Type Description callback (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S thisArg any Returns Type Description LinkedList<S> filter(callback, thisArg) Declaration filter(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): LinkedList<T>; Parameters Name Type Description callback (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean thisArg any Returns Type Description LinkedList<T> find(callback, thisArg) Declaration find<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): S | undefined; Parameters Name Type Description callback (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S thisArg any Returns Type Description S | undefined find(callback, thisArg) Declaration find(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): T | undefined; Parameters Name Type Description callback (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean thisArg any Returns Type Description T | undefined findLast(callback, thisArg) Declaration findLast<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): S | undefined; Parameters Name Type Description callback (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S thisArg any Returns Type Description S | undefined findLast(callback, thisArg) Declaration findLast(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): T | undefined; Parameters Name Type Description callback (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean thisArg any Returns Type Description T | undefined findLastNode(callback, thisArg) Declaration findLastNode<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): LinkedListNode<S> | undefined; Parameters Name Type Description callback (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S thisArg any Returns Type Description LinkedListNode<S> | undefined findLastNode(callback, thisArg) Declaration findLastNode(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): LinkedListNode<T> | undefined; Parameters Name Type Description callback (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean thisArg any Returns Type Description LinkedListNode<T> | undefined findNode(callback, thisArg) Declaration findNode<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): LinkedListNode<S> | undefined; Parameters Name Type Description callback (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S thisArg any Returns Type Description LinkedListNode<S> | undefined findNode(callback, thisArg) Declaration findNode(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): LinkedListNode<T> | undefined; Parameters Name Type Description callback (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean thisArg any Returns Type Description LinkedListNode<T> | undefined forEach(callback, thisArg) Declaration forEach(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => void, thisArg?: any): void; Parameters Name Type Description callback (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => void thisArg any Returns Type Description void has(value) Declaration has(value: T): boolean; Parameters Name Type Description value T Returns Type Description boolean insertAfter(node, value) Declaration insertAfter(node: LinkedListNode<T> | null | undefined, value: T): LinkedListNode<T>; Parameters Name Type Description node LinkedListNode<T> | null | undefined value T Returns Type Description LinkedListNode<T> insertBefore(node, value) Declaration insertBefore(node: LinkedListNode<T> | null | undefined, value: T): LinkedListNode<T>; Parameters Name Type Description node LinkedListNode<T> | null | undefined value T Returns Type Description LinkedListNode<T> insertNodeAfter(node, newNode) Declaration insertNodeAfter(node: LinkedListNode<T> | null | undefined, newNode: LinkedListNode<T>): void; Parameters Name Type Description node LinkedListNode<T> | null | undefined newNode LinkedListNode<T> Returns Type Description void insertNodeBefore(node, newNode) Declaration insertNodeBefore(node: LinkedListNode<T> | null | undefined, newNode: LinkedListNode<T>): void; Parameters Name Type Description node LinkedListNode<T> | null | undefined newNode LinkedListNode<T> Returns Type Description void lastNodeOf(value, fromNode) Declaration lastNodeOf(value: T, fromNode?: LinkedListNode<T>): LinkedListNode<T> | undefined; Parameters Name Type Description value T fromNode LinkedListNode<T> Returns Type Description LinkedListNode<T> | undefined map(callback, thisArg) Declaration map<U>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => U, thisArg?: any): LinkedList<U>; Parameters Name Type Description callback (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => U thisArg any Returns Type Description LinkedList<U> nodeOf(value, fromNode) Declaration nodeOf(value: T, fromNode?: LinkedListNode<T>): LinkedListNode<T> | undefined; Parameters Name Type Description value T fromNode LinkedListNode<T> Returns Type Description LinkedListNode<T> | undefined nodes() Declaration nodes(): IterableIterator<LinkedListNode<T>>; Returns Type Description IterableIterator<LinkedListNode<T>> pop() Declaration pop(): T | undefined; Returns Type Description T | undefined popNode() Declaration popNode(): LinkedListNode<T> | undefined; Returns Type Description LinkedListNode<T> | undefined push(value) Declaration push(value: T): LinkedListNode<T>; Parameters Name Type Description value T Returns Type Description LinkedListNode<T> pushNode(newNode) Declaration pushNode(newNode: LinkedListNode<T>): void; Parameters Name Type Description newNode LinkedListNode<T> Returns Type Description void reduce(callback) Declaration reduce(callback: (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T): T; Parameters Name Type Description callback (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T Returns Type Description T reduce(callback, initialValue) Declaration reduce(callback: (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T, initialValue: T): T; Parameters Name Type Description callback (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T initialValue T Returns Type Description T reduce(callback, initialValue) Declaration reduce<U>(callback: (previousValue: U, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => U, initialValue: U): U; Parameters Name Type Description callback (previousValue: U, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => U initialValue U Returns Type Description U reduceRight(callback) Declaration reduceRight(callback: (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T): T; Parameters Name Type Description callback (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T Returns Type Description T reduceRight(callback, initialValue) Declaration reduceRight(callback: (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T, initialValue: T): T; Parameters Name Type Description callback (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T initialValue T Returns Type Description T reduceRight(callback, initialValue) Declaration reduceRight<U>(callback: (previousValue: U, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => U, initialValue: U): U; Parameters Name Type Description callback (previousValue: U, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => U initialValue U Returns Type Description U shift() Declaration shift(): T | undefined; Returns Type Description T | undefined shiftNode() Declaration shiftNode(): LinkedListNode<T> | undefined; Returns Type Description LinkedListNode<T> | undefined some(callback, thisArg) Declaration some(callback?: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): boolean; Parameters Name Type Description callback (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean thisArg any Returns Type Description boolean unshift(value) Declaration unshift(value: T): LinkedListNode<T>; Parameters Name Type Description value T Returns Type Description LinkedListNode<T> unshiftNode(newNode) Declaration unshiftNode(newNode: LinkedListNode<T>): void; Parameters Name Type Description newNode LinkedListNode<T> Returns Type Description void values() Declaration values(): IterableIterator<T>; Returns Type Description IterableIterator<T>"
  },
  "api/collections-hashset/hashset.html": {
    "href": "api/collections-hashset/hashset.html",
    "title": "Class HashSet | @esfx API Reference",
    "keywords": "Class HashSet Classes Constructors constructor(equaler) Constructs a new instance of the HashSet class Declaration constructor(equaler?: Equaler<T>); Parameters Name Type Description equaler Equaler<T> constructor(iterable, equaler) Constructs a new instance of the HashSet class Declaration constructor(iterable?: Iterable<T>, equaler?: Equaler<T>); Parameters Name Type Description iterable Iterable<T> equaler Equaler<T> constructor(capacity, equaler) Constructs a new instance of the HashSet class Declaration constructor(capacity: number, equaler?: Equaler<T>); Parameters Name Type Description capacity number equaler Equaler<T> Classes Properties __@toStringTag Declaration [Symbol.toStringTag]: string; Property Value Type Description string [Collection.size] Declaration readonly [Collection.size]: number; Property Value Type Description number equaler Declaration readonly equaler: Equaler<T>; Property Value Type Description Equaler<T> size Declaration readonly size: number; Property Value Type Description number Classes Methods __@iterator() Declaration [Symbol.iterator](): IterableIterator<T>; Returns Type Description IterableIterator<T> [Collection.has](value) Declaration [Collection.has](value: T): boolean; Parameters Name Type Description value T Returns Type Description boolean add(value) Declaration add(value: T): this; Parameters Name Type Description value T Returns Type Description this clear() Declaration clear(): void; Returns Type Description void delete(value) Declaration delete(value: T): boolean; Parameters Name Type Description value T Returns Type Description boolean ensureCapacity(capacity) Declaration ensureCapacity(capacity: number): number | undefined; Parameters Name Type Description capacity number Returns Type Description number | undefined entries() Declaration entries(): IterableIterator<[T, T]>; Returns Type Description IterableIterator<[T, T]> forEach(callback, thisArg) Declaration forEach(callback: (value: T, key: T, map: this) => void, thisArg?: any): void; Parameters Name Type Description callback (value: T, key: T, map: this) => void thisArg any Returns Type Description void has(value) Declaration has(value: T): boolean; Parameters Name Type Description value T Returns Type Description boolean keys() Declaration keys(): IterableIterator<T>; Returns Type Description IterableIterator<T> trimExcess(capacity) Declaration trimExcess(capacity?: number): void; Parameters Name Type Description capacity number Returns Type Description void values() Declaration values(): IterableIterator<T>; Returns Type Description IterableIterator<T>"
  },
  "api/collection-core/indexedcollection_interface.html": {
    "href": "api/collection-core/indexedcollection_interface.html",
    "title": "Interface IndexedCollection | @esfx API Reference",
    "keywords": "Interface IndexedCollection Interfaces Methods [IndexedCollection.insertAt](index, value) Inserts a value at the specified index in the collection, shifting any following elements to the right one position. Declaration [IndexedCollection.insertAt](index: number, value: T): void; Parameters Name Type Description index number value T Returns Type Description void"
  },
  "api/collection-core/fixedsizeindexedcollection_namespace.html": {
    "href": "api/collection-core/fixedsizeindexedcollection_namespace.html",
    "title": "Namespace FixedSizeIndexedCollection | @esfx API Reference",
    "keywords": "Namespace FixedSizeIndexedCollection Functions isFixedSizeIndexedCollection(value) Tests whether a value supports the minimal representation of a FixedSizeIndexedCollection <!-- --> . Declaration function isFixedSizeIndexedCollection<T>(value: Iterable<T>): value is FixedSizeIndexedCollection<T>; Parameters Name Type Description value Iterable<T> Returns Type Description value is FixedSizeIndexedCollection<T> isFixedSizeIndexedCollection(value) Tests whether a value supports the minimal representation of a FixedSizeIndexedCollection <!-- --> . Declaration function isFixedSizeIndexedCollection(value: unknown): value is FixedSizeIndexedCollection<unknown>; Parameters Name Type Description value unknown Returns Type Description value is FixedSizeIndexedCollection<unknown>"
  },
  "api/cancelable/cancelerror.html": {
    "href": "api/cancelable/cancelerror.html",
    "title": "Class CancelError | @esfx API Reference",
    "keywords": "Class CancelError Classes Constructors constructor(message) Constructs a new instance of the CancelError class Declaration constructor(message?: string); Parameters Name Type Description message string"
  },
  "api/cancelable/cancelable_namespace.html": {
    "href": "api/cancelable/cancelable_namespace.html",
    "title": "Namespace Cancelable | @esfx API Reference",
    "keywords": "Namespace Cancelable Functions isCancelable(value) Determines whether a value is a Cancelable object. Declaration function isCancelable(value: unknown): value is Cancelable; Parameters Name Type Description value unknown Returns Type Description value is Cancelable isSignaled(cancelable) Determines whether cancelable is in the signaled state. Declaration function isSignaled(cancelable: Cancelable | undefined): boolean; Parameters Name Type Description cancelable Cancelable | undefined Returns Type Description boolean subscribe(cancelable, onSignaled) Subscribes to be notified when a cancelable becomes signaled. Declaration function subscribe(cancelable: Cancelable | undefined, onSignaled: () => void): CancelSubscription; Parameters Name Type Description cancelable Cancelable | undefined onSignaled () => void Returns Type Description CancelSubscription throwIfSignaled(cancelable) Throws a CancelError exception if the provided cancelable is in the signaled state. Declaration function throwIfSignaled(cancelable: Cancelable | undefined): void; Parameters Name Type Description cancelable Cancelable | undefined Returns Type Description void"
  },
  "api/events/eventsource.html": {
    "href": "api/events/eventsource.html",
    "title": "Class EventSource | @esfx API Reference",
    "keywords": "Class EventSource Classes Properties event Declaration readonly event: Event<F>; Property Value Type Description Event<F> owner Declaration readonly owner: ThisParameterType<F>; Property Value Type Description ThisParameterType<F> Classes Methods emit(args) Declaration emit(...args: Parameters<F>): boolean; Parameters Name Type Description args Parameters<F> Returns Type Description boolean"
  },
  "api/equatable/structuralequatable_namespace.html": {
    "href": "api/equatable/structuralequatable_namespace.html",
    "title": "Namespace StructuralEquatable | @esfx API Reference",
    "keywords": "Namespace StructuralEquatable Functions isStructuralEquatable(value) Determines whether a value is StructuralEquatable. Declaration function isStructuralEquatable(value: unknown): value is StructuralEquatable; Parameters Name Type Description value unknown Returns Type Description value is StructuralEquatable"
  },
  "api/disposable/disposable_interface.html": {
    "href": "api/disposable/disposable_interface.html",
    "title": "Interface Disposable | @esfx API Reference",
    "keywords": "Interface Disposable Indicates an object that has resources that can be explicitly disposed. Interfaces Methods [Disposable.dispose]() Dispose this object's resources. Declaration [Disposable.dispose](): void; Returns Type Description void"
  },
  "api/disposable/asyncdisposable_namespace.html": {
    "href": "api/disposable/asyncdisposable_namespace.html",
    "title": "Namespace AsyncDisposable | @esfx API Reference",
    "keywords": "Namespace AsyncDisposable Functions create(dispose) Creates an AsyncDisposable wrapper around a callback used to dispose resources. Declaration function create(dispose: () => void | PromiseLike<void>): AsyncDisposable; Parameters Name Type Description dispose () => void | PromiseLike<void> Returns Type Description AsyncDisposable from(resources) Creates an AsyncDisposable wrapper around a set of other disposables. Declaration function from(resources: Iterable<AsyncDisposable | Disposable | null | undefined>): AsyncDisposable; Parameters Name Type Description resources Iterable<AsyncDisposable | Disposable | null | undefined> Returns Type Description AsyncDisposable isAsyncDisposable(value) Determines whether a value is [[AsyncDisposable]]. Declaration function isAsyncDisposable(value: unknown): value is AsyncDisposable; Parameters Name Type Description value unknown Returns Type Description value is AsyncDisposable use(resource, callback) Executes a callback with the provided AsyncDisposable resource, disposing the resource when the callback completes asynchronously. Declaration function use<T extends AsyncDisposable | Disposable | null | undefined, U>(resource: T, callback: (resource: T) => U | PromiseLike<U>): Promise<U>; Parameters Name Type Description resource T callback (resource: T) => U | PromiseLike<U> Returns Type Description Promise<U>"
  },
  "api/disposable/asyncdisposable_interface.html": {
    "href": "api/disposable/asyncdisposable_interface.html",
    "title": "Interface AsyncDisposable | @esfx API Reference",
    "keywords": "Interface AsyncDisposable Indicates an object that has resources that can be explicitly disposed asynchronously. Interfaces Methods [AsyncDisposable.asyncDispose]() Dispose this object's resources. Declaration [AsyncDisposable.asyncDispose](): Promise<void>; Returns Type Description Promise<void>"
  },
  "api/decorators-stage1-core/parameterdescriptor.html": {
    "href": "api/decorators-stage1-core/parameterdescriptor.html",
    "title": "Interface ParameterDescriptor | @esfx API Reference",
    "keywords": "Interface ParameterDescriptor Interfaces Properties index Declaration index: number; Property Value Type Description number key Declaration key: string | symbol; Property Value Type Description string | symbol kind Declaration kind: \"parameter\"; Property Value Type Description \"parameter\" target Declaration target: object; Property Value Type Description object"
  },
  "api/collection-core/readonlyindexedcollection_interface.html": {
    "href": "api/collection-core/readonlyindexedcollection_interface.html",
    "title": "Interface ReadonlyIndexedCollection | @esfx API Reference",
    "keywords": "Interface ReadonlyIndexedCollection Interfaces Methods [ReadonlyIndexedCollection.indexOf](value, fromIndex) Gets the index for a value in the collection, or -1 if the value was not found. Declaration [ReadonlyIndexedCollection.indexOf](value: T, fromIndex?: number): number; Parameters Name Type Description value T fromIndex number Returns Type Description number"
  },
  "api/collection-core/readonlycollection_namespace.html": {
    "href": "api/collection-core/readonlycollection_namespace.html",
    "title": "Namespace ReadonlyCollection | @esfx API Reference",
    "keywords": "Namespace ReadonlyCollection Functions isReadonlyCollection(value) Tests whether a value supports the minimal representation of a ReadonlyCollection <!-- --> . Declaration function isReadonlyCollection<T>(value: Iterable<T>): value is ReadonlyCollection<T>; Parameters Name Type Description value Iterable<T> Returns Type Description value is ReadonlyCollection<T> isReadonlyCollection(value) Tests whether a value supports the minimal representation of a ReadonlyCollection <!-- --> . Declaration function isReadonlyCollection(value: any): value is ReadonlyCollection<unknown>; Parameters Name Type Description value any Returns Type Description value is ReadonlyCollection<unknown>"
  },
  "api/threading-spinwait/spinwait.html": {
    "href": "api/threading-spinwait/spinwait.html",
    "title": "Class SpinWait | @esfx API Reference",
    "keywords": "Class SpinWait Classes Methods reset() Declaration reset(): void; Returns Type Description void spinOnce() Declaration spinOnce(): void; Returns Type Description void spinUntil(condition, ms) Declaration spinUntil(condition: () => boolean, ms?: number): boolean; Parameters Name Type Description condition () => boolean ms number Returns Type Description boolean"
  },
  "api/threading-semaphore/semaphore.html": {
    "href": "api/threading-semaphore/semaphore.html",
    "title": "Class Semaphore | @esfx API Reference",
    "keywords": "Class Semaphore Classes Constructors constructor(initialCount, maxCount) Constructs a new instance of the Semaphore class Declaration constructor(initialCount: number, maxCount?: number); Parameters Name Type Description initialCount number maxCount number constructor(buffer, byteOffset) Constructs a new instance of the Semaphore class Declaration constructor(buffer: SharedArrayBuffer, byteOffset?: number); Parameters Name Type Description buffer SharedArrayBuffer byteOffset number Classes Properties buffer Declaration readonly buffer: SharedArrayBuffer; Property Value Type Description SharedArrayBuffer byteLength Declaration readonly byteLength: number; Property Value Type Description number byteOffset Declaration readonly byteOffset: number; Property Value Type Description number count Declaration readonly count: number; Property Value Type Description number SIZE Declaration static readonly SIZE = 16; Classes Methods release(count) Declaration release(count?: number): number; Parameters Name Type Description count number Returns Type Description number wait(ms) Declaration wait(ms?: number): boolean; Parameters Name Type Description ms number Returns Type Description boolean"
  },
  "api/threading-mutex/mutex.html": {
    "href": "api/threading-mutex/mutex.html",
    "title": "Class Mutex | @esfx API Reference",
    "keywords": "Class Mutex Classes Constructors constructor(initiallyOwned) Constructs a new instance of the Mutex class Declaration constructor(initiallyOwned?: boolean); Parameters Name Type Description initiallyOwned boolean constructor(buffer, byteOffset) Constructs a new instance of the Mutex class Declaration constructor(buffer: SharedArrayBuffer, byteOffset?: number); Parameters Name Type Description buffer SharedArrayBuffer byteOffset number Classes Properties buffer Declaration readonly buffer: SharedArrayBuffer; Property Value Type Description SharedArrayBuffer byteLength Declaration readonly byteLength: number; Property Value Type Description number byteOffset Declaration readonly byteOffset: number; Property Value Type Description number isLocked Declaration readonly isLocked: boolean; Property Value Type Description boolean ownsLock Declaration readonly ownsLock: boolean; Property Value Type Description boolean SIZE Declaration static readonly SIZE = 12; Classes Methods [Lockable.lock](ms) Declaration [Lockable.lock](ms?: number): boolean; Parameters Name Type Description ms number Returns Type Description boolean close() Declaration close(): void; Returns Type Description void lock(ms) Declaration lock(ms?: number): boolean; Parameters Name Type Description ms number Returns Type Description boolean tryLock() Declaration tryLock(): boolean; Returns Type Description boolean unlock() Declaration unlock(): boolean; Returns Type Description boolean"
  },
  "api/equatable/comparer_interface.html": {
    "href": "api/equatable/comparer_interface.html",
    "title": "Interface Comparer | @esfx API Reference",
    "keywords": "Interface Comparer Represents an object that can be used to perform a relational comparison between two values. Interfaces Methods compare(x, y) Compares two values: - A negative value indicates x is lesser than y <!-- --> . - A positive value indicates x is greater than y <!-- --> . - A zero value indicates x and y are equivalent. Declaration compare(x: T, y: T): number; Parameters Name Type Description x T y T Returns Type Description number"
  },
  "api/equatable/comparable_namespace.html": {
    "href": "api/equatable/comparable_namespace.html",
    "title": "Namespace Comparable | @esfx API Reference",
    "keywords": "Namespace Comparable Functions isComparable(value) Determines whether a value is Comparable. Declaration function isComparable(value: unknown): value is Comparable; Parameters Name Type Description value unknown Returns Type Description value is Comparable"
  },
  "api/equatable/comparable_interface.html": {
    "href": "api/equatable/comparable_interface.html",
    "title": "Interface Comparable | @esfx API Reference",
    "keywords": "Interface Comparable Represents a value that can compare itself relationally with another value. Interfaces Methods [Comparable.compareTo](other) Compares this value with another value: - A negative value indicates this value is lesser. - A positive value indicates this value is greater. - A zero value indicates this value is the same. Declaration [Comparable.compareTo](other: unknown): number; Parameters Name Type Description other unknown Returns Type Description number"
  },
  "api/disposable/disposable_namespace.html": {
    "href": "api/disposable/disposable_namespace.html",
    "title": "Namespace Disposable | @esfx API Reference",
    "keywords": "Namespace Disposable Functions create(dispose) Creates a Disposable wrapper around a callback used to dispose of a resource. Declaration function create(dispose: () => void): Disposable; Parameters Name Type Description dispose () => void Returns Type Description Disposable from(disposables) Creates a Disposable wrapper around a set of other disposables. Declaration function from(disposables: Iterable<Disposable | null | undefined>): Disposable; Parameters Name Type Description disposables Iterable<Disposable | null | undefined> Returns Type Description Disposable isDisposable(value) Determines whether a value is [[Disposable]]. Declaration function isDisposable(value: unknown): value is Disposable; Parameters Name Type Description value unknown Returns Type Description value is Disposable use(resource, callback) Executes a callback with the provided Disposable resource, disposing the resource when the callback completes. Declaration function use<T extends Disposable | null | undefined, U>(resource: T, callback: (resource: T) => U): U; Parameters Name Type Description resource T callback (resource: T) => U Returns Type Description U"
  },
  "api/decorators-stage1-core/accessormemberdescriptor.html": {
    "href": "api/decorators-stage1-core/accessormemberdescriptor.html",
    "title": "Interface AccessorMemberDescriptor | @esfx API Reference",
    "keywords": "Interface AccessorMemberDescriptor Interfaces Properties descriptor Declaration descriptor: AccessorPropertyDescriptor<T>; Property Value Type Description AccessorPropertyDescriptor<T>"
  },
  "api/collections-sortedset/sortedset.html": {
    "href": "api/collections-sortedset/sortedset.html",
    "title": "Class SortedSet | @esfx API Reference",
    "keywords": "Class SortedSet Classes Constructors constructor(comparer) Constructs a new instance of the SortedSet class Declaration constructor(comparer?: Comparison<T> | Comparer<T>); Parameters Name Type Description comparer Comparison<T> | Comparer<T> constructor(iterable, comparer) Constructs a new instance of the SortedSet class Declaration constructor(iterable?: Iterable<T>, comparer?: Comparison<T> | Comparer<T>); Parameters Name Type Description iterable Iterable<T> comparer Comparison<T> | Comparer<T> Classes Properties __@toStringTag Declaration [Symbol.toStringTag]: string; Property Value Type Description string [Collection.size] Declaration readonly [Collection.size]: number; Property Value Type Description number size Declaration readonly size: number; Property Value Type Description number Classes Methods __@iterator() Declaration [Symbol.iterator](): IterableIterator<T>; Returns Type Description IterableIterator<T> [Collection.has](value) Declaration [Collection.has](value: T): boolean; Parameters Name Type Description value T Returns Type Description boolean add(value) Declaration add(value: T): this; Parameters Name Type Description value T Returns Type Description this clear() Declaration clear(): void; Returns Type Description void delete(value) Declaration delete(value: T): boolean; Parameters Name Type Description value T Returns Type Description boolean entries() Declaration entries(): IterableIterator<[T, T]>; Returns Type Description IterableIterator<[T, T]> forEach(cb, thisArg) Declaration forEach(cb: (value: T, key: T, map: this) => void, thisArg?: unknown): void; Parameters Name Type Description cb (value: T, key: T, map: this) => void thisArg unknown Returns Type Description void has(value) Declaration has(value: T): boolean; Parameters Name Type Description value T Returns Type Description boolean keys() Declaration keys(): IterableIterator<T>; Returns Type Description IterableIterator<T> values() Declaration values(): IterableIterator<T>; Returns Type Description IterableIterator<T>"
  },
  "api/collections-sortedmap/sortedmap.html": {
    "href": "api/collections-sortedmap/sortedmap.html",
    "title": "Class SortedMap | @esfx API Reference",
    "keywords": "Class SortedMap Classes Constructors constructor(comparer) Constructs a new instance of the SortedMap class Declaration constructor(comparer?: Comparison<K> | Comparer<K>); Parameters Name Type Description comparer Comparison<K> | Comparer<K> constructor(iterable, comparer) Constructs a new instance of the SortedMap class Declaration constructor(iterable?: Iterable<[K, V]>, comparer?: Comparison<K> | Comparer<K>); Parameters Name Type Description iterable Iterable<[K, V]> comparer Comparison<K> | Comparer<K> Classes Properties __@toStringTag Declaration [Symbol.toStringTag]: string; Property Value Type Description string [KeyedCollection.size] Declaration readonly [KeyedCollection.size]: number; Property Value Type Description number size Declaration readonly size: number; Property Value Type Description number Classes Methods __@iterator() Declaration [Symbol.iterator](): IterableIterator<[K, V]>; Returns Type Description IterableIterator<[K, V]> [KeyedCollection.has](key) Declaration [KeyedCollection.has](key: K): boolean; Parameters Name Type Description key K Returns Type Description boolean clear() Declaration clear(): void; Returns Type Description void delete(key) Declaration delete(key: K): boolean; Parameters Name Type Description key K Returns Type Description boolean entries() Declaration entries(): IterableIterator<[K, V]>; Returns Type Description IterableIterator<[K, V]> forEach(cb, thisArg) Declaration forEach(cb: (value: V, key: K, map: this) => void, thisArg?: unknown): void; Parameters Name Type Description cb (value: V, key: K, map: this) => void thisArg unknown Returns Type Description void get(key) Declaration get(key: K): V | undefined; Parameters Name Type Description key K Returns Type Description V | undefined has(key) Declaration has(key: K): boolean; Parameters Name Type Description key K Returns Type Description boolean keys() Declaration keys(): IterableIterator<K>; Returns Type Description IterableIterator<K> set(key, value) Declaration set(key: K, value: V): this; Parameters Name Type Description key K value V Returns Type Description this values() Declaration values(): IterableIterator<V>; Returns Type Description IterableIterator<V>"
  },
  "api/collections-linkedlist/linkedlistnode.html": {
    "href": "api/collections-linkedlist/linkedlistnode.html",
    "title": "Class LinkedListNode | @esfx API Reference",
    "keywords": "Class LinkedListNode Classes Constructors constructor(value) Constructs a new instance of the LinkedListNode class Declaration constructor(value: T); Parameters Name Type Description value T Classes Properties __@toStringTag Declaration [Symbol.toStringTag]: string; Property Value Type Description string [kList] Declaration [kList]: LinkedList<T> | undefined; Property Value Type Description LinkedList<T> | undefined list Declaration readonly list: LinkedList<T> | undefined; Property Value Type Description LinkedList<T> | undefined next Declaration readonly next: LinkedListNode<T> | undefined; Property Value Type Description LinkedListNode<T> | undefined previous Declaration readonly previous: LinkedListNode<T> | undefined; Property Value Type Description LinkedListNode<T> | undefined value Declaration value: T; Property Value Type Description T Classes Methods detachSelf() Declaration detachSelf(): boolean; Returns Type Description boolean"
  },
  "api/collection-core/keyedcollection_interface.html": {
    "href": "api/collection-core/keyedcollection_interface.html",
    "title": "Interface KeyedCollection | @esfx API Reference",
    "keywords": "Interface KeyedCollection Interfaces Methods [KeyedCollection.set](key, value) Sets a value in the collection for the provided key. Declaration [KeyedCollection.set](key: K, value: V): void; Parameters Name Type Description key K value V Returns Type Description void"
  },
  "api/collection-core/indexedcollection_namespace.html": {
    "href": "api/collection-core/indexedcollection_namespace.html",
    "title": "Namespace IndexedCollection | @esfx API Reference",
    "keywords": "Namespace IndexedCollection Functions isIndexedCollection(value) Tests whether a value supports the minimal representation of an IndexedCollection <!-- --> . Declaration function isIndexedCollection<T>(value: Iterable<T>): value is IndexedCollection<T>; Parameters Name Type Description value Iterable<T> Returns Type Description value is IndexedCollection<T> isIndexedCollection(value) Tests whether a value supports the minimal representation of an IndexedCollection <!-- --> . Declaration function isIndexedCollection(value: unknown): value is IndexedCollection<unknown>; Parameters Name Type Description value unknown Returns Type Description value is IndexedCollection<unknown>"
  },
  "api/cancelable/cancelsubscription_interface.html": {
    "href": "api/cancelable/cancelsubscription_interface.html",
    "title": "Interface CancelSubscription | @esfx API Reference",
    "keywords": "Interface CancelSubscription An object used to unsubscribe from a cancellation signal Interfaces Methods unsubscribe() Unsubscribes from a cancellation signal. Declaration unsubscribe(): void; Returns Type Description void"
  },
  "api/async-mutex.html": {
    "href": "api/async-mutex.html",
    "title": "Package @esfx/async-mutex | @esfx API Reference",
    "keywords": "Package @esfx/async-mutex Provides the AsyncMutex class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-mutex Usage TypeScript JavaScript (CommonJS) import { AsyncMutex } from \"@esfx/async-mutex\"; const m = new AsyncMutex(); let counter = 0; async function worker() { for (let i = 0; i < 3; i++) { // get exclusive access to 'm', which protects 'counter'. const lk = await m.lock(); try { const current = counter; await doSomethingElse(); // we still have exclusive access to 'm', which protects 'counter'. counter = current + 1; } finally { // release the lock lk.unlock(); } } } async function main() { // start two workers that share a resource await Promise.all([worker(), worker()]); counter; // 6 } const { AsyncMutex } = require(\"@esfx/async-mutex\"); const m = new AsyncMutex(); let counter = 0; async function worker() { for (let i = 0; i < 3; i++) { // get exclusive access to 'm', which protects 'counter'. const lk = await m.lock(); try { const current = counter; await doSomethingElse(); // we still have exclusive access to 'm', which protects 'counter'. counter = current + 1; } finally { // release the lock lk.unlock(); } } } async function main() { // start two workers that share a resource await Promise.all([worker(), worker()]); counter; // 6 }"
  },
  "api/async-barrier.html": {
    "href": "api/async-barrier.html",
    "title": "Package @esfx/async-barrier | @esfx API Reference",
    "keywords": "Package @esfx/async-barrier The @esfx/async-barrier package provides the AsyncBarrier class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-barrier Usage TypeScript JavaScript (CommonJS) import { AsyncBarrier } from \"@esfx/async-barrier\"; async function main() { let count = 0; // Create a barrier with 3 participants and a post-phase action to print results. // When phase 2 completes, throw an exception to be observed by all participants. const barrier = new AsyncBarrier(3, b => { console.log(`Post-phase action: count=${count}, phase=${b.currentPhaseNumber}`); if (b.currentPhaseNumber === 2) throw new Error(\"Oops\"); }); // Add two participants barrier.add(2); barrier.participantCount; // 5 // Remove one participant barrier.remove(); barrier.participantcount; // 4 const action = async () => { count++; // Wait for the current phase to end. During the post-phase action 'count' will be 4 and // 'phase' will be 0. await barrier.signalAndWait(); count++; // Wait for the current phase to end. During the post-phase action 'count' will be 8 and // 'phase' will be 1. await barrier.signalAndWait(); count++; // When phase 2 ends an exception is thrown to all participants: try { await barrier.signalAndWait(); } catch (e) { console.log(`Caught error: ${e.message}`); } // Wait for the current phase to end. During the post-phase action 'count' will be 16 and // 'phase' will be 3. await barrier.signalAndWait(); }; // Start 4 async actions to serve as the 4 participants. await Promise.all([action(), action(), action(), action()]); } main(); // prints: // Post-phase action: count=4, phase=0 // Post-phase action: count=8, phase=1 // Post-phase action: count=12, phase=2 // Caught error: Oops // Post-phase action: count=16, phase=3 const { AsyncBarrier } = require(\"@esfx/async-barrier\"); async function main() { let count = 0; // Create a barrier with 3 participants and a post-phase action to print results. // When phase 2 completes, throw an exception to be observed by all participants. const barrier = new AsyncBarrier(3, b => { console.log(`Post-phase action: count=${count}, phase=${b.currentPhaseNumber}`); if (b.currentPhaseNumber === 2) throw new Error(\"Oops\"); }); // Add two participants barrier.add(2); barrier.participantCount; // 5 // Remove one participant barrier.remove(); barrier.participantcount; // 4 const action = async () => { count++; // Wait for the current phase to end. During the post-phase action 'count' will be 4 and // 'phase' will be 0. await barrier.signalAndWait(); count++; // Wait for the current phase to end. During the post-phase action 'count' will be 8 and // 'phase' will be 1. await barrier.signalAndWait(); count++; // When phase 2 ends an exception is thrown to all participants: try { await barrier.signalAndWait(); } catch (e) { console.log(`Caught error: ${e.message}`); } // Wait for the current phase to end. During the post-phase action 'count' will be 16 and // 'phase' will be 3. await barrier.signalAndWait(); }; // Start 4 async actions to serve as the 4 participants. await Promise.all([action(), action(), action(), action()]); } main(); // prints: // Post-phase action: count=4, phase=0 // Post-phase action: count=8, phase=1 // Post-phase action: count=12, phase=2 // Caught error: Oops // Post-phase action: count=16, phase=3"
  },
  "api/threading-manualresetevent/manualresetevent.html": {
    "href": "api/threading-manualresetevent/manualresetevent.html",
    "title": "Class ManualResetEvent | @esfx API Reference",
    "keywords": "Class ManualResetEvent Classes Constructors constructor(initialState) Constructs a new instance of the ManualResetEvent class Declaration constructor(initialState?: boolean); Parameters Name Type Description initialState boolean constructor(buffer, byteOffset) Constructs a new instance of the ManualResetEvent class Declaration constructor(buffer: SharedArrayBuffer, byteOffset?: number); Parameters Name Type Description buffer SharedArrayBuffer byteOffset number Classes Properties buffer Declaration readonly buffer: SharedArrayBuffer; Property Value Type Description SharedArrayBuffer byteLength Declaration readonly byteLength: number; Property Value Type Description number byteOffset Declaration readonly byteOffset: number; Property Value Type Description number isSet Declaration readonly isSet: boolean; Property Value Type Description boolean SIZE Declaration static readonly SIZE = 4; Classes Methods [Disposable.dispose]() Declaration [Disposable.dispose](): void; Returns Type Description void close() Declaration close(): void; Returns Type Description void reset() Declaration reset(): boolean; Returns Type Description boolean set() Declaration set(): boolean; Returns Type Description boolean waitOne(ms) Declaration waitOne(ms?: number): boolean; Parameters Name Type Description ms number Returns Type Description boolean"
  },
  "api/threading-lockable/lockable_namespace.html": {
    "href": "api/threading-lockable/lockable_namespace.html",
    "title": "Namespace Lockable | @esfx API Reference",
    "keywords": "Namespace Lockable"
  },
  "api/threading-lockable/lockable_interface.html": {
    "href": "api/threading-lockable/lockable_interface.html",
    "title": "Interface Lockable | @esfx API Reference",
    "keywords": "Interface Lockable Interfaces Methods [Lockable.lock](ms) Declaration [Lockable.lock](ms?: number): boolean; Parameters Name Type Description ms number Returns Type Description boolean"
  },
  "api/threading-countdown/countdownevent.html": {
    "href": "api/threading-countdown/countdownevent.html",
    "title": "Class CountdownEvent | @esfx API Reference",
    "keywords": "Class CountdownEvent Classes Constructors constructor(initialCount) Constructs a new instance of the CountdownEvent class Declaration constructor(initialCount: number); Parameters Name Type Description initialCount number constructor(buffer, byteOffset) Constructs a new instance of the CountdownEvent class Declaration constructor(buffer: SharedArrayBuffer, byteOffset?: number); Parameters Name Type Description buffer SharedArrayBuffer byteOffset number Classes Properties buffer Declaration readonly buffer: SharedArrayBuffer; Property Value Type Description SharedArrayBuffer byteLength Declaration readonly byteLength: number; Property Value Type Description number byteOffset Declaration readonly byteOffset: number; Property Value Type Description number initialCount Declaration readonly initialCount: number; Property Value Type Description number isSet Declaration readonly isSet: boolean; Property Value Type Description boolean remainingCount Declaration readonly remainingCount: number; Property Value Type Description number SIZE Declaration static readonly SIZE = 12; Classes Methods [Disposable.dispose]() Declaration [Disposable.dispose](): void; Returns Type Description void add(count) Declaration add(count?: number): void; Parameters Name Type Description count number Returns Type Description void close() Declaration close(): void; Returns Type Description void reset(count) Declaration reset(count?: number): void; Parameters Name Type Description count number Returns Type Description void signal(count) Declaration signal(count?: number): boolean; Parameters Name Type Description count number Returns Type Description boolean tryAdd(count) Declaration tryAdd(count?: number): boolean; Parameters Name Type Description count number Returns Type Description boolean wait(ms) Declaration wait(ms?: number): boolean; Parameters Name Type Description ms number Returns Type Description boolean"
  },
  "api/events/event_interface.html": {
    "href": "api/events/event_interface.html",
    "title": "Interface Event | @esfx API Reference",
    "keywords": "Interface Event"
  },
  "api/events/event_class.html": {
    "href": "api/events/event_class.html",
    "title": "Class Event | @esfx API Reference",
    "keywords": "Class Event Classes Properties count Declaration readonly count: number; Property Value Type Description number owner Declaration readonly owner: ThisParameterType<F>; Property Value Type Description ThisParameterType<F> Classes Methods addListener(listener) Declaration addListener(listener: EventListener<F>): ThisParameterType<F>; Parameters Name Type Description listener EventListener<F> Returns Type Description ThisParameterType<F> create() Declaration static create<F extends (this: undefined, ...args: any[]) => void>(): EventSource<F>; Returns Type Description EventSource<F> create(owner) Declaration static create<F extends (...args: any[]) => void>(owner: ThisParameterType<F>): EventSource<F>; Parameters Name Type Description owner ThisParameterType<F> Returns Type Description EventSource<F> listeners() Declaration listeners(): IterableIterator<EventListener<F>>; Returns Type Description IterableIterator<EventListener<F>> off(listener) Declaration off(listener: EventListener<F>): ThisParameterType<F>; Parameters Name Type Description listener EventListener<F> Returns Type Description ThisParameterType<F> on(listener) Declaration on(listener: EventListener<F>): ThisParameterType<F>; Parameters Name Type Description listener EventListener<F> Returns Type Description ThisParameterType<F> once(listener) Declaration once(listener: EventListener<F>): ThisParameterType<F>; Parameters Name Type Description listener EventListener<F> Returns Type Description ThisParameterType<F> prependListener(listener) Declaration prependListener(listener: EventListener<F>): ThisParameterType<F>; Parameters Name Type Description listener EventListener<F> Returns Type Description ThisParameterType<F> prependOnceListener(listener) Declaration prependOnceListener(listener: EventListener<F>): ThisParameterType<F>; Parameters Name Type Description listener EventListener<F> Returns Type Description ThisParameterType<F> rawListeners() Declaration rawListeners(): IterableIterator<EventListener<F>>; Returns Type Description IterableIterator<EventListener<F>> removeAllListeners() Declaration removeAllListeners(): ThisParameterType<F>; Returns Type Description ThisParameterType<F> removeListener(listener) Declaration removeListener(listener: EventListener<F>): ThisParameterType<F>; Parameters Name Type Description listener EventListener<F> Returns Type Description ThisParameterType<F>"
  },
  "api/async-semaphore/asyncsemaphore.html": {
    "href": "api/async-semaphore/asyncsemaphore.html",
    "title": "Class AsyncSemaphore | @esfx API Reference",
    "keywords": "Class AsyncSemaphore Limits the number of asynchronous operations that can access a resource or pool of resources. Classes Constructors constructor(initialCount, maxCount) Initializes a new instance of the Semaphore class. Declaration constructor(initialCount: number, maxCount?: number); Parameters Name Type Description initialCount number maxCount number Classes Properties count Gets the number of remaining asynchronous operations that can enter the Semaphore. Declaration readonly count: number; Property Value Type Description number Classes Methods release(count) Releases the [[Semaphore]] one or more times. Declaration release(count?: number): void; Parameters Name Type Description count number Returns Type Description void wait(cancelable) Asynchronously waits for the event to become signaled. Declaration wait(cancelable?: Cancelable): Promise<void>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<void>"
  },
  "api/async-readerwriterlock/asyncreaderwriterlockwriter.html": {
    "href": "api/async-readerwriterlock/asyncreaderwriterlockwriter.html",
    "title": "Interface AsyncReaderWriterLockWriter | @esfx API Reference",
    "keywords": "Interface AsyncReaderWriterLockWriter Interfaces Properties owner Gets the AsyncReaderWriterLock that owns this object. Declaration readonly owner: AsyncReaderWriterLock; Property Value Type Description AsyncReaderWriterLock"
  },
  "api/async-manualresetevent/asyncmanualresetevent.html": {
    "href": "api/async-manualresetevent/asyncmanualresetevent.html",
    "title": "Class AsyncManualResetEvent | @esfx API Reference",
    "keywords": "Class AsyncManualResetEvent Asynchronously notifies one or more waiting Promises that an event has occurred. Classes Constructors constructor(initialState) Initializes a new instance of the ManualResetEvent class. Declaration constructor(initialState?: boolean); Parameters Name Type Description initialState boolean Classes Properties isSet Gets a value indicating whether the event is signaled. Declaration readonly isSet: boolean; Property Value Type Description boolean Classes Methods reset() Sets the state of the event to nonsignaled, causing asynchronous operations to pause. Declaration reset(): void; Returns Type Description void set() Sets the state of the event to signaled, resolving one or more waiting Promises. Declaration set(): void; Returns Type Description void wait(cancelable) Asynchronously waits for the event to become signaled. Declaration wait(cancelable?: Cancelable): Promise<void>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<void>"
  },
  "api/async-lockable/upgradeablelockhandle.html": {
    "href": "api/async-lockable/upgradeablelockhandle.html",
    "title": "Interface UpgradeableLockHandle | @esfx API Reference",
    "keywords": "Interface UpgradeableLockHandle An object used to release a held lock or upgrade to a stronger lock. Interfaces Methods upgrade(cancelable) Upgrades the lock to a stronger lock. Declaration upgrade(cancelable?: Cancelable): Promise<LockHandle<TUpgradedMutex>>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<LockHandle<TUpgradedMutex>>"
  },
  "api/async-conditionvariable/asyncconditionvariable.html": {
    "href": "api/async-conditionvariable/asyncconditionvariable.html",
    "title": "Class AsyncConditionVariable | @esfx API Reference",
    "keywords": "Class AsyncConditionVariable Classes Methods notifyAll() Notifies all current waiters to reacquire their locks. Declaration notifyAll(): void; Returns Type Description void notifyOne() Notifies one waiter to reacquire its lock. Declaration notifyOne(): void; Returns Type Description void wait(lock, cancelable) Releases lock <!-- --> , waiting until notified before reacquiring lock <!-- --> . Declaration wait(lock: AsyncLockable, cancelable?: Cancelable): Promise<void>; Parameters Name Type Description lock AsyncLockable cancelable Cancelable Returns Type Description Promise<void> wait(lock, condition, cancelable) Releases lock <!-- --> , waiting until notified before reacquiring lock <!-- --> . Declaration wait(lock: AsyncLockable, condition?: () => boolean, cancelable?: Cancelable): Promise<void>; Parameters Name Type Description lock AsyncLockable condition () => boolean cancelable Cancelable Returns Type Description Promise<void>"
  },
  "api/async-canceltoken/canceltoken.html": {
    "href": "api/async-canceltoken/canceltoken.html",
    "title": "Class CancelToken | @esfx API Reference",
    "keywords": "Class CancelToken Propagates notifications that operations should be canceled. Classes Properties canBeSignaled Gets a value indicating whether the token can be signaled. Declaration readonly canBeSignaled: boolean; Property Value Type Description boolean canceled Declaration static readonly canceled: CancelToken; Property Value Type Description CancelToken none Declaration static readonly none: CancelToken; Property Value Type Description CancelToken signaled Gets a value indicating whether the token is signaled. Declaration readonly signaled: boolean; Property Value Type Description boolean Classes Methods [Cancelable.cancelSignal]() Declaration [Cancelable.cancelSignal](): CancelToken; Returns Type Description CancelToken all(cancelables) Returns a CancelToken that becomes signaled when **all** of the provided cancelables are signaled. Declaration static all(cancelables: Iterable<Cancelable>): CancelToken; Parameters Name Type Description cancelables Iterable<Cancelable> Returns Type Description CancelToken from(cancelable) Gets a CancelToken from a cancelable. Declaration static from(cancelable: Cancelable | null | undefined): CancelToken; Parameters Name Type Description cancelable Cancelable | null | undefined Returns Type Description CancelToken race(cancelables) Returns a CancelToken that becomes signaled when **any** of the provided cancelables are signaled. Declaration static race(cancelables: Iterable<Cancelable>): CancelToken; Parameters Name Type Description cancelables Iterable<Cancelable> Returns Type Description CancelToken source() Creates a new CancelSource. Declaration static source(): CancelSource; Returns Type Description CancelSource subscribe(onSignaled) Subscribes to notifications for when the object becomes signaled. Declaration subscribe(onSignaled: () => void): CancelSubscription; Parameters Name Type Description onSignaled () => void Returns Type Description CancelSubscription throwIfSignaled() Throws a CancelError if the token was signaled. Declaration throwIfSignaled(): void; Returns Type Description void"
  },
  "api/threading-sleep.html": {
    "href": "api/threading-sleep.html",
    "title": "Package @esfx/threading-sleep | @esfx API Reference",
    "keywords": "Package @esfx/threading-sleep Provides the sleep(ms) function which causes the current execution thread to sleep until the timeout expires. Overview Installation Usage Installation npm i @esfx/threading-sleep Usage TypeScript JavaScript import { sleep } from \"@esfx/threading-sleep\"; // block the main thread for half a second sleep(500); const { sleep } = require(\"@esfx/threading-sleep\"); // block the main thread for half a second sleep(500); Functions sleep(ms) Causes the current thread of execution to sleep until the specified timeout expires. Declaration export declare function sleep(ms: number): void; Parameters Name Type Description ms number Returns Type Description void"
  },
  "api/threading-semaphore.html": {
    "href": "api/threading-semaphore.html",
    "title": "Package @esfx/threading-semaphore | @esfx API Reference",
    "keywords": "Package @esfx/threading-semaphore Provides the Semaphore class, a thread synchronization primitive for use with Workers. Overview Installation Usage Installation npm i @esfx/threading-semaphore Usage TypeScript JavaScript (CommonJS) import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; import { Semaphore } from \"@esfx/threading-semaphore\"; import { StructType, int32 } from \"@esfx/struct-type\"; import { sleep } from \"@esfx/threading-sleep\"; const SharedData = StructType([ { name: \"running\", type: int32 }, ] as const); function worker_thread() { const sem = new Semaphore(workerData[0]); while (true) { // wait until the thread can enter the semaphore sem.wait(); // do work inside the semaphore... // release this worker's spot sem.release(); // do work outside the semaphore... } } function main() { // create a semaphore that allows 5 workers to enter at once const sem = new Semaphore(5); // start 10 workers for (let i = 0; i < 10; i++) { new Worker(__filename, { workerData: [sem.buffer] }); } } if (isMainThread) { main(); } else { worker_thread(); } const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const { Semaphore } = require(\"@esfx/threading-semaphore\"); const { StructType, int32 } = require(\"@esfx/struct-type\"); const { sleep } = require(\"@esfx/threading-sleep\"); const SharedData = StructType([ { name: \"running\", type: int32 }, ]); function worker_thread() { const sem = new Semaphore(workerData[0]); while (true) { // wait until the thread can enter the semaphore sem.wait(); // do work inside the semaphore... // release this worker's spot sem.release(); // do work outside the semaphore... } } function main() { // create a semaphore that allows 5 workers to enter at once const sem = new Semaphore(5); // start 10 workers for (let i = 0; i < 10; i++) { new Worker(__filename, { workerData: [sem.buffer] }); } } if (isMainThread) { main(); } else { worker_thread(); }"
  },
  "api/struct-type.html": {
    "href": "api/struct-type.html",
    "title": "Package @esfx/struct-type | @esfx API Reference",
    "keywords": "Package @esfx/struct-type Define structured types using ArrayBuffer and SharedArrayBuffer . Overview Installation Usage Installation npm i @esfx/struct-type Usage Basic Usage TypeScript JavaScript (CommonJS) import { StructType, int32 } from \"@esfx/struct-type\"; // simple types const Point = StructType([ { name: \"x\", type: int32 }, { name: \"y\", type: int32 }, ] as const); // complex types const Line = StructType([ { name: \"from\", type: Point }, { name: \"to\", type: Point }, ] as const); // inherited types const Point3D = StructType(Point, [ { name: \"z\", type: int32 } ] as const); // create instances const p1 = new Point({ x: 1, y: 2 }); // by field name const p2 = new Point([3, 4]); // by field ordinal // copy contents const buffer = new ArrayBuffer(16); const l = new Line([p1, p2]); l.writeTo(buffer); // create from a buffer const l2 = new Line(buffer); // read from field names console.log(l1.from.x); // 1 console.log(l1.from.y); // 2 console.log(l1.to.x); // 3 console.log(l1.to.y); // 4 // read from field ordinals console.log(l1[0][0]); // 1 console.log(l1[0][1]); // 2 console.log(l1[1][0]); // 3 console.log(l1[1][1]); // 4 const { StructType, int32 } = require(\"@esfx/struct-type\"); // simple types const Point = StructType([ { name: \"x\", type: int32 }, { name: \"y\", type: int32 }, ]); // complex types const Line = StructType([ { name: \"from\", type: Point }, { name: \"to\", type: Point }, ]); // inherited types const Point3D = StructType(Point, [ { name: \"z\", type: int32 } ]); // create instances const p1 = new Point({ x: 1, y: 2 }); // by field name const p2 = new Point([3, 4]); // by field ordinal // copy contents const buffer = new ArrayBuffer(16); const l = new Line([p1, p2]); l.writeTo(buffer); // create from a buffer const l2 = new Line(buffer); // read from field names console.log(l1.from.x); // 1 console.log(l1.from.y); // 2 console.log(l1.to.x); // 3 console.log(l1.to.y); // 4 // read from field ordinals console.log(l1[0][0]); // 1 console.log(l1[0][1]); // 2 console.log(l1[1][0]); // 3 console.log(l1[1][1]); // 4 Using with Workers TypeScript JavaScript (CommonJS) import { StructType, int32 } from \"@esfx/struct-type\"; import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; const ThreadData = StructType([ { name: \"itemsRemaining\", type: int32 }, ] as const); function worker_thread() { // this is running in a background worker... const data = new ThreadData(workerData); // allocate struct using the SharedArrayBuffer while (data.itemsRemaining) { // do some work... data.itemsRemaining--; } parentPort.postMessage(\"done\"); } function main() { // this is running on the main thread... const data = new ThreadData(/*shared*/ true); // allocate struct using a SharedArrayBuffer data.itemsRemaining = 5; const worker = new Worker(__filename, { workerData: data.buffer }); worker.on(\"message\", message => { if (message === \"done\") { console.log(data.itemsRemaining); // 0 } }); } if (isMainThread) { main(); } else if (parentPort) { worker_thread(); } const { StructType, int32 } = require(\"@esfx/struct-type\"); const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const ThreadData = StructType([ { name: \"itemsRemaining\", type: int32 }, ]); function worker_thread() { // this is running in a background worker... const data = new ThreadData(workerData); // allocate struct using the SharedArrayBuffer while (data.itemsRemaining) { // do some work... data.itemsRemaining--; } parentPort.postMessage(\"done\"); } function main() { // this is running on the main thread... const data = new ThreadData(/*shared*/ true); // allocate struct using a SharedArrayBuffer data.itemsRemaining = 5; const worker = new Worker(__filename, { workerData: data.buffer }); worker.on(\"message\", message => { if (message === \"done\") { console.log(data.itemsRemaining); // 0 } }); } if (isMainThread) { main(); } else if (parentPort) { worker_thread(); }"
  },
  "api/reflect-metadata-compat.html": {
    "href": "api/reflect-metadata-compat.html",
    "title": "Package @esfx/reflect-metadata-compat | @esfx API Reference",
    "keywords": "Package @esfx/reflect-metadata-compat Provides a global shim that provides a drop-in replacement for reflect-metadata . Overview Installation Usage Installation npm i @esfx/reflect-metadata-compat Usage TypeScript import \"@esfx/reflect-metadata-compat\"; // TypeScript compiled with --emitDecoratorMetadata class MyClass { @someDecorator method(x: number): string { return \"\"; } } const c = new MyClass(); Reflect.getMetadata(\"design:returntype\", c, \"method\"); // String Reflect.getMetadata(\"design:paramtypes\", c, \"method\"); // [Number]"
  },
  "api/equatable-shim.html": {
    "href": "api/equatable-shim.html",
    "title": "Package @esfx/equatable-shim | @esfx API Reference",
    "keywords": "Package @esfx/equatable-shim Provides a global shim that adds @esfx/equatable functionality to various ECMAScript built-ins. Overview Installation Usage Installation npm i @esfx/equatable-shim Usage The global shim adds a default implementation of Equatable to Object.prototype and default implementations of @\"comparable.Comparable_Interface\" to String.prototype , Number.prototype , Boolean.prototype , and BigInt.prototype . To install the global shim, import @esfx/equatable-shim : TypeScript JavaScript (CommonJS) import \"@esfx/equatable-shim\"; // triggers global-scope side effects import { Equatable } from \"@esfx/equatable\"; 123[Equatable.hash]() // 123 require(\"@esfx/equatable-shim\"); // triggers global-scope side effects const { Equatable } = require(\"@esfx/equatable\"); 123[Equatable.hash]() // 123"
  },
  "api/disposable.html": {
    "href": "api/disposable.html",
    "title": "Package @esfx/disposable | @esfx API Reference",
    "keywords": "Package @esfx/disposable Provides a low-level API for defining explicit resource management that third-party libraries can use to interoperate. Overview Installation Usage Installation npm i @esfx/disposable Usage TypeScript JavaScript (CommonJS) import { Disposable } from \"@esfx/disposable\"; class MyFileResouce { private _handle?: number; constructor() { this._handle = fs.openSync(\"path/to/file\"); } close() { if (this._handle !== undefined) { fs.closeSync(this._handle); this._handle = undefined; } } // provide low-level 'dispose' primitive for interop [Disposable.dispose]() { this.close(); } } const { Disposable } = require(\"@esfx/disposable\"); class MyFileResouce { constructor() { this._handle = fs.openSync(\"path/to/file\"); } close() { if (this._handle !== undefined) { fs.closeSync(this._handle); this._handle = undefined; } } // provide low-level 'dispose' primitive for interop [Disposable.dispose]() { this.close(); } }"
  },
  "api/collections-sortedmap.html": {
    "href": "api/collections-sortedmap.html",
    "title": "Package @esfx/collections-sortedmap | @esfx API Reference",
    "keywords": "Package @esfx/collections-sortedmap Provides the SortedMap class, a collection class that utilizes @esfx/collection-core and @esfx/equatable . Overview Installation Usage Installation npm i @esfx/collections-sortedmap Usage TypeScript JavaScript (CommonJS) import { SortedMap } from \"@esfx/collections-sortedmap\"; import { Equatable, Equaler, Comparable, Comparer } from \"@esfx/equatable\"; class Person { firstName: string; lastName: string; constructor(firstName: string, lastName: string) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other: unknown) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other: unknown) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Alice\", \"Johnson\"); const obj2 = new Person(\"Bob\", \"Clark\"); // ECMAScript native map iterates in insertion order const map = new Map<Person, string>(); // native ECMAScript Map set.set(obj1, \"obj1\"); set.set(obj2, \"obj2\"); [...set.keys()]; // Alice Johnson,Bob Clark // SortedMap uses Comparable.compareTo if available const sortedMap = new SortedMap<Person, string>(); sortedMap.set(obj1, \"obj1\"); sortedMap.set(obj2, \"obj2\"); [...sortedMap.keys()]; // Bob Clark,Alice Johnson const { SortedMap } = require(\"@esfx/collections-sortedmap\"); const { Equatable, Equaler, Comparable, Comparer } = require(\"@esfx/equatable\"); class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Alice\", \"Johnson\"); const obj2 = new Person(\"Bob\", \"Clark\"); // ECMAScript native map iterates in insertion order const map = new Map(); // native ECMAScript Map set.set(obj1, \"obj1\"); set.set(obj2, \"obj2\"); [...set.keys()]; // Alice Johnson,Bob Clark // SortedMap uses Comparable.compareTo if available const sortedMap = new SortedMap(); sortedMap.set(obj1, \"obj1\"); sortedMap.set(obj2, \"obj2\"); [...sortedMap.keys()]; // Bob Clark,Alice Johnson"
  },
  "api/collection-core.html": {
    "href": "api/collection-core.html",
    "title": "Package @esfx/collection-core | @esfx API Reference",
    "keywords": "Package @esfx/collection-core Provides a low-level Symbol-based API for defining common collection behaviors. Overview Installation Usage Installation npm i @esfx/collection-core Usage TypeScript JavaScript (CommonJS) import { Collection } from \"@esfx/collection-core\"; class MyCollection<T> { private _items = new Set<T>(); // Your implementation get count() { return this._items.size; } contains(value): T { return this._items.has(value); } add(value: T) { this._items.add(value); } remove(value: T) { return this._items.delete(value); } clear() { this._items.clear(); } // Implement the `Collection` interface for cross-library consistency get [Collection.size]() { return this.count; } [Collection.has](value) { return this.contains(value); } [Collection.add](value) { this.add(value); } [Collection.delete](value) { return this.remove(value); } [Collection.clear]() { this.clear(); } [Symbol.iterator]() { return this._items.values(); } } const { Collection } = require(\"@esfx/collection-core\"); class MyCollection { constructor() { this._items = new Set(); } // Your implementation get count() { return this._items.size; } contains(value) { return this._items.has(value); } add(value) { this._items.add(value); } remove(value) { return this._items.delete(value); } clear() { this._items.clear(); } // Implement the `Collection` interface for cross-library consistency get [Collection.size]() { return this.count; } [Collection.has](value) { return this.contains(value); } [Collection.add](value) { this.add(value); } [Collection.delete](value) { return this.remove(value); } [Collection.clear]() { this.clear(); } [Symbol.iterator]() { return this._items.values(); } }"
  },
  "api/cancelable-dom-shim.html": {
    "href": "api/cancelable-dom-shim.html",
    "title": "Package @esfx/cancelable-dom-shim | @esfx API Reference",
    "keywords": "Package @esfx/cancelable-dom-shim The @esfx/cancelable-dom-shim package provides a global shim to make the DOM AbortController and AbortSignal classes compatible with @esfx/cancelable . Overview Installation Usage Installation npm i @esfx/cancelable-dom-shim Usage The global shim adds a default implementation the collection interfaces to the following global DOM objects: AbortController implements: @\"cancelable.CancelableSource\" @\"cancelable.Cancelable\" AbortSignal implements: @\"cancelable.Cancelable\" To install the global shim, import @esfx/cancelable/global : TypeScript JavaScript (CommonJS) import \"@esfx/cancelable-dom-shim\"; // triggers global-scope side effects import { Cancelable } from \"@esfx/cancelable\"; const abortController = new AbortController(); const signal = abortController[Cancelable.cancelSignal](); require(\"@esfx/cancelable-dom-shim\"); // triggers global-scope side effects const { Cancelable } = require(\"@esfx/cancelable\"); const abortController = new AbortController(); const signal = abortController[Cancelable.cancelSignal]();"
  },
  "api/async-semaphore.html": {
    "href": "api/async-semaphore.html",
    "title": "Package @esfx/async-semaphore | @esfx API Reference",
    "keywords": "Package @esfx/async-semaphore The @esfx/async-semaphore package provides the AsyncSemaphore class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-semaphore Usage TypeScript JavaScript (CommonJS) import { AsyncSemaphore } from \"@esfx/async-semaphore\"; // create a semaphore that allows one participant const semaphore = new AsyncSemaphore(1); async function updateResource(updates: UpdateObject) { // Wait for a lock on the semaphore await semaphore.wait(); try { // Between the 'wait' above and the 'release' below, // this function has exclusive access to a resource... // Await something async, allowing other logic to // execute. If some other event/timer/etc. calls // 'updateResource' before this async operation // finishes, they will be blocked at the 'wait' above. await doSomethingAsync(); // We still have exclusive access even after resuming, // so we can continue to use our exclusive access. } finally { // Release the semaphore. The next waiter will // be unblocked and will have the lock instead. semaphore.release(); } } const { AsyncSemaphore } = require(\"@esfx/async-semaphore\"); // create a semaphore that allows one participant const semaphore = new AsyncSemaphore(1); async function updateResource(updates) { // Wait for a lock on the semaphore await semaphore.wait(); try { // Between the 'wait' above and the 'release' below, // this function has exclusive access to a resource... // Await something async, allowing other logic to // execute. If some other event/timer/etc. calls // 'updateResource' before this async operation // finishes, they will be blocked at the 'wait' above. await doSomethingAsync(); // We still have exclusive access even after resuming, // so we can continue to use our exclusive access. } finally { // Release the semaphore. The next waiter will // be unblocked and will have the lock instead. semaphore.release(); } }"
  },
  "api/struct-type/structprimitivetype.html": {
    "href": "api/struct-type/structprimitivetype.html",
    "title": "Interface StructPrimitiveType | @esfx API Reference",
    "keywords": "Interface StructPrimitiveType Interfaces Properties name Declaration readonly name: K; Property Value Type Description K SIZE Declaration readonly SIZE: number; Property Value Type Description number"
  },
  "api/struct-type/structfielddefinition.html": {
    "href": "api/struct-type/structfielddefinition.html",
    "title": "Interface StructFieldDefinition | @esfx API Reference",
    "keywords": "Interface StructFieldDefinition Interfaces Properties name Declaration readonly name: string | symbol; Property Value Type Description string | symbol type Declaration readonly type: StructFieldType; Property Value Type Description StructFieldType"
  },
  "api/equatable/equatable_interface.html": {
    "href": "api/equatable/equatable_interface.html",
    "title": "Interface Equatable | @esfx API Reference",
    "keywords": "Interface Equatable Represents a value that can compare its equality with another value. Interfaces Methods [Equatable.equals](other) Determines whether this value is equal to another value. Declaration [Equatable.equals](other: unknown): boolean; Parameters Name Type Description other unknown Returns Type Description boolean"
  },
  "api/equatable/equaler_namespace.html": {
    "href": "api/equatable/equaler_namespace.html",
    "title": "Namespace Equaler | @esfx API Reference",
    "keywords": "Namespace Equaler Functions create(equalityComparison, hashGenerator) Creates an Equaler from a comparison function and an optional hash generator. Declaration function create<T>(equalityComparison: EqualityComparison<T>, hashGenerator?: HashGenerator<T>): Equaler<T>; Parameters Name Type Description equalityComparison EqualityComparison<T> hashGenerator HashGenerator<T> Returns Type Description Equaler<T>"
  },
  "api/async-queue/asyncqueue.html": {
    "href": "api/async-queue/asyncqueue.html",
    "title": "Class AsyncQueue | @esfx API Reference",
    "keywords": "Class AsyncQueue An asynchronous queue. Classes Constructors constructor(iterable) Initializes a new instance of the AsyncQueue class. Declaration constructor(iterable?: Iterable<T | PromiseLike<T>>); Parameters Name Type Description iterable Iterable<T | PromiseLike<T>> Classes Properties done Gets a value indicating whether the queue has ended and there are no more items available. Declaration readonly done: boolean; Property Value Type Description boolean readable Gets a value indicating whether items can be read from the queue. Declaration readonly readable: boolean; Property Value Type Description boolean size Gets the number of entries in the queue. When positive, indicates the number of entries available to get. When negative, indicates the number of requests waiting to be fulfilled. Declaration readonly size: number; Property Value Type Description number writable Gets a value indicating whether new items can be added to the queue. Declaration readonly writable: boolean; Property Value Type Description boolean Classes Methods doneReading() Blocks attempts to read from the queue until it is empty. Available items in the queue can still be read until the queue is empty. Declaration doneReading(): void; Returns Type Description void doneWriting() Blocks attempts to write to the queue. Pending requests in the queue can still be resolved until the queue is empty. Declaration doneWriting(): void; Returns Type Description void end() Blocks future attempts to read or write from the queue. Available items in the queue can still be read until the queue is empty. Pending reads from the queue are rejected with a CancelError <!-- --> . Declaration end(): void; Returns Type Description void get(cancelable) Removes and returns a Promise for the first value in the queue. If the queue is empty, returns a Promise for the next value to be added to the queue. Declaration get(cancelable?: Cancelable): Promise<T>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<T> put(this) Adds a value to the end of the queue. If the queue is empty but has a pending dequeue request, the value will be dequeued and the request fulfilled. Declaration put(this: AsyncQueue<void>): void; Parameters Name Type Description this AsyncQueue<void> Returns Type Description void put(value) Adds a value to the end of the queue. If the queue is empty but has a pending dequeue request, the value will be dequeued and the request fulfilled. Declaration put(value: T | PromiseLike<T>): void; Parameters Name Type Description value T | PromiseLike<T> Returns Type Description void"
  },
  "api/async-mutex/asyncmutex.html": {
    "href": "api/async-mutex/asyncmutex.html",
    "title": "Class AsyncMutex | @esfx API Reference",
    "keywords": "Class AsyncMutex An async coordination primitive used to coordinate access to a protected resource. Classes Properties isLocked Indicates whether the lock has been taken. Declaration readonly isLocked: boolean; Property Value Type Description boolean Classes Methods [AsyncLockable.lock](cancelable) Declaration [AsyncLockable.lock](cancelable?: Cancelable): Promise<LockHandle<AsyncMutex>>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<LockHandle<AsyncMutex>> lock(cancelable) Asynchronously waits for the lock to become available and then takes the lock. Declaration lock(cancelable?: Cancelable): Promise<LockHandle<AsyncMutex>>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<LockHandle<AsyncMutex>> tryLock() Synchronously tries to take a lock. Declaration tryLock(): boolean; Returns Type Description boolean unlock() Releases the lock. Declaration unlock(): boolean; Returns Type Description boolean"
  },
  "api/threading-conditionvariable.html": {
    "href": "api/threading-conditionvariable.html",
    "title": "Package @esfx/threading-conditionvariable | @esfx API Reference",
    "keywords": "Package @esfx/threading-conditionvariable Provides the ConditionVariable class, a thread synchronization primitive for use with Workers. Overview Installation Usage Installation npm i @esfx/threading-conditionvariable Usage TypeScript JavaScript (CommonJS) import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; import { Mutex } from \"@esfx/threading-mutex\"; import { ConditionVariable } from \"@esfx/threading-conditionvariable\"; import { StructType, int32 } from \"@esfx/struct-type\"; const SharedData = StructType([ { name: \"ready\", type: int32 }, { name: \"processed\", type: int32 }, ] as const); function worker_thread() { const m = new Mutex(workerData[0]); const cv = new ConditionVariable(workerData[1]); const data = new SharedData(workerData[2]); m.lock(); try { // release the lock and wait until main() sends data cv.wait(m, () => data.ready === 1); // after waiting we once again own the lock console.log(\"worker thread is processing data\"); // send data back to main() data.processed = 1; console.log(\"worker thread is done\"); } finally { m.unlock(); } cv.notifyOne(); } function main() { const m = new Mutex(); const cv = new ConditionVariable(); const data = new SharedData(/*shared*/ true); // start the Worker, passing the buffers of the shared objects const worker = new Worker(__filename, { workerData: [m.buffer, cv.buffer, data.buffer], stdout: true, }); // pipe stdout for console.log in worker worker.stdout.pipe(process.stdout); // send data to the worker m.lock(); try { data.ready = 1; console.log(\"main is ready\"); } finally { m.unlock(); } // notify the waiting worker cv.notifyOne(); m.lock(); try { // release the lock and wait for the worker to finish processing cv.wait(m, () => data.processed === 1); } finally { m.unlock(); } } if (isMainThread) { main(); } else { worker_thread(); } const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const { Mutex } = require(\"@esfx/threading-mutex\"); const { ConditionVariable } = require(\"@esfx/threading-conditionvariable\"); const { StructType, int32 } = require(\"@esfx/struct-type\"); const SharedData = StructType([ { name: \"ready\", type: int32 }, { name: \"processed\", type: int32 }, ]); function worker_thread() { const m = new Mutex(workerData[0]); const cv = new ConditionVariable(workerData[1]); const data = new SharedData(workerData[2]); m.lock(); try { // release the lock and wait until main() sends data cv.wait(m, () => data.ready === 1); // after waiting we once again own the lock console.log(\"worker thread is processing data\"); // send data back to main() data.processed = 1; console.log(\"worker thread is done\"); } finally { m.unlock(); } cv.notifyOne(); } function main() { const m = new Mutex(); const cv = new ConditionVariable(); const data = new SharedData(/*shared*/ true); // start the Worker, passing the buffers of the shared objects const worker = new Worker(__filename, { workerData: [m.buffer, cv.buffer, data.buffer], stdout: true, }); // pipe stdout for console.log in worker worker.stdout.pipe(process.stdout); // send data to the worker m.lock(); try { data.ready = 1; console.log(\"main is ready\"); } finally { m.unlock(); } // notify the waiting worker cv.notifyOne(); m.lock(); try { // release the lock and wait for the worker to finish processing cv.wait(m, () => data.processed === 1); } finally { m.unlock(); } } if (isMainThread) { main(); } else { worker_thread(); }"
  },
  "api/cancelable.html": {
    "href": "api/cancelable.html",
    "title": "Package @esfx/cancelable | @esfx API Reference",
    "keywords": "Package @esfx/cancelable The @esfx/cancelable package provides a low-level Symbol-based API for defining a common cancellation protocol. Note This package does not contain an implementation of cancellation signals, but rather provides only a protocol for interoperable libraries that depend on cancellation. For an implementation of this protocol, please consider the following packages: @esfx/async-canceltoken @esfx/cancelable-dom @esfx/cancelable-dom-shim prex (version 0.4.6 or later) Overview Installation Usage Installation npm i @esfx/cancelable Usage TypeScript JavaScript (CommonJS) import { Cancelable } from \"@esfx/cancelable\"; function doSomeWork(cancelable: Cancelable) { return new Promise((resolve, reject) => { const cancelSignal = cancelable[Cancelable.cancelSignal](); if (cancelSignal.signaled) throw new Error(\"Operation canceled.\"); const child = fork(\"worker.js\"); const subscription = cancelSignal.subscribe(() => { // cancellation requested, abort worker worker.kill(); reject(new Error(\"Operation canceled.\")); }); worker.on(\"exit\", () => { subscription.unsubscribe(); resolve(); }); }); } const { Cancelable } = require(\"@esfx/cancelable\"); function doSomeWork(cancelable) { return new Promise((resolve, reject) => { const cancelSignal = cancelable[Cancelable.cancelSignal](); if (cancelSignal.signaled) throw new Error(\"Operation canceled.\"); const child = fork(\"worker.js\"); const subscription = cancelSignal.subscribe(() => { // cancellation requested, abort worker worker.kill(); reject(new Error(\"Operation canceled.\")); }); worker.on(\"exit\", () => { subscription.unsubscribe(); resolve(); }); }); }"
  },
  "api/async-lazy.html": {
    "href": "api/async-lazy.html",
    "title": "Package @esfx/async-lazy | @esfx API Reference",
    "keywords": "Package @esfx/async-lazy Lazy-initialized asynchronous value. Overview Installation Usage Installation npm i @esfx/async-lazy Usage TypeScript JavaScript (CommonJS) import { AsyncLazy } from \"@esfx/async-lazy\"; async function main() { // lazy initialize an object const lazy1 = new AsyncLazy(() => new SomeObject()); lazy1.isStarted; // false const p1 = lazy1.value; // Promise {} lazy1.isStarted; // true await p1; // SomeObject {} // lazy initialize with arguments const lazy2 = Lazy.from( async (a, b) => (await a) + (await b), Promise.resolve(1), Promise.resolve(2)); lazy2.isStarted; // false const p2 = lazy2.value; // Promise {} lazy2.isStarted; // true await p2; // 3 // initialized \"lazy\" const lazy3 = Lazy.for(Promise.resolve(\"test\")); lazy3.isStarted; // true await lazy3.value; // \"test\" } main().catch(e => console.error(e)); const { AsyncLazy } = require(\"@esfx/async-lazy\"); async function main() { // lazy initialize an object const lazy1 = new AsyncLazy(() => new SomeObject()); lazy1.isStarted; // false const p1 = lazy1.value; // Promise {} lazy1.isStarted; // true await p1; // SomeObject {} // lazy initialize with arguments const lazy2 = Lazy.from( async (a, b) => (await a) + (await b), Promise.resolve(1), Promise.resolve(2)); lazy2.isStarted; // false const p2 = lazy2.value; // Promise {} lazy2.isStarted; // true await p2; // 3 // initialized \"lazy\" const lazy3 = Lazy.for(Promise.resolve(\"test\")); lazy3.isStarted; // true await lazy3.value; // \"test\" } main().catch(e => console.error(e));"
  },
  "api/threading-conditionvariable/conditionvariable.html": {
    "href": "api/threading-conditionvariable/conditionvariable.html",
    "title": "Class ConditionVariable | @esfx API Reference",
    "keywords": "Class ConditionVariable Classes Constructors constructor(buffer, byteOffset) Constructs a new instance of the ConditionVariable class Declaration constructor(buffer?: SharedArrayBuffer, byteOffset?: number); Parameters Name Type Description buffer SharedArrayBuffer byteOffset number Classes Properties buffer Declaration readonly buffer: SharedArrayBuffer; Property Value Type Description SharedArrayBuffer byteLength Declaration readonly byteLength: number; Property Value Type Description number byteOffset Declaration readonly byteOffset: number; Property Value Type Description number SIZE Declaration static readonly SIZE = 4; Classes Methods [Disposable.dispose]() Declaration [Disposable.dispose](): void; Returns Type Description void close() Declaration close(): void; Returns Type Description void notifyAll() Declaration notifyAll(): number; Returns Type Description number notifyOne() Declaration notifyOne(): boolean; Returns Type Description boolean wait(mutex, condition) Declaration wait(mutex: Lockable, condition?: () => boolean): boolean; Parameters Name Type Description mutex Lockable condition () => boolean Returns Type Description boolean waitFor(mutex, ms, condition) Declaration waitFor(mutex: Lockable, ms: number, condition?: () => boolean): boolean; Parameters Name Type Description mutex Lockable ms number condition () => boolean Returns Type Description boolean"
  },
  "api/threading-autoresetevent/autoresetevent.html": {
    "href": "api/threading-autoresetevent/autoresetevent.html",
    "title": "Class AutoResetEvent | @esfx API Reference",
    "keywords": "Class AutoResetEvent Classes Constructors constructor(initialState) Constructs a new instance of the AutoResetEvent class Declaration constructor(initialState?: boolean); Parameters Name Type Description initialState boolean constructor(buffer, byteOffset) Constructs a new instance of the AutoResetEvent class Declaration constructor(buffer: SharedArrayBuffer, byteOffset?: number); Parameters Name Type Description buffer SharedArrayBuffer byteOffset number Classes Properties buffer Declaration readonly buffer: SharedArrayBuffer; Property Value Type Description SharedArrayBuffer byteLength Declaration readonly byteLength: number; Property Value Type Description number byteOffset Declaration readonly byteOffset: number; Property Value Type Description number SIZE Declaration static readonly SIZE = 4; Classes Methods [Disposable.dispose]() Declaration [Disposable.dispose](): void; Returns Type Description void close() Declaration close(): void; Returns Type Description void reset() Declaration reset(): boolean; Returns Type Description boolean set() Declaration set(): boolean; Returns Type Description boolean waitOne(ms) Declaration waitOne(ms?: number): boolean; Parameters Name Type Description ms number Returns Type Description boolean"
  },
  "api/async-readerwriterlock/asyncreaderwriterlockupgradedwriter.html": {
    "href": "api/async-readerwriterlock/asyncreaderwriterlockupgradedwriter.html",
    "title": "Interface AsyncReaderWriterLockUpgradedWriter | @esfx API Reference",
    "keywords": "Interface AsyncReaderWriterLockUpgradedWriter Interfaces Properties owner Gets the AsyncReaderWriterLock that owns this object. Declaration readonly owner: AsyncReaderWriterLock; Property Value Type Description AsyncReaderWriterLock"
  },
  "api/async-readerwriterlock/asyncreaderwriterlockupgradeablereader.html": {
    "href": "api/async-readerwriterlock/asyncreaderwriterlockupgradeablereader.html",
    "title": "Interface AsyncReaderWriterLockUpgradeableReader | @esfx API Reference",
    "keywords": "Interface AsyncReaderWriterLockUpgradeableReader Interfaces Properties owner Gets the AsyncReaderWriterLock that owns this object. Declaration readonly owner: AsyncReaderWriterLock; Property Value Type Description AsyncReaderWriterLock Interfaces Methods createWriter() Creates a AsyncReaderWriterLockUpgradedWriter that can be used to take and release \"write\" locks on a resource. Declaration createWriter(): AsyncReaderWriterLockUpgradedWriter; Returns Type Description AsyncReaderWriterLockUpgradedWriter upgrade(cancelable) Asynchronously waits for and takes a write lock on a resource. Declaration upgrade(cancelable?: Cancelable): Promise<AsyncReaderWriterLockUpgradedWriter>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<AsyncReaderWriterLockUpgradedWriter>"
  },
  "api/async-lockable/lockhandle.html": {
    "href": "api/async-lockable/lockhandle.html",
    "title": "Interface LockHandle | @esfx API Reference",
    "keywords": "Interface LockHandle An object used to release a held lock. Interfaces Properties mutex Gets the associated AsyncLockable object. Declaration readonly mutex: TMutex; Property Value Type Description TMutex ownsLock Indicates whether this handle owns its associated mutex <!-- --> . Declaration readonly ownsLock: boolean; Property Value Type Description boolean Interfaces Methods lock(cancelable) Reacquires the lock. If this handle already owns the lock, an Error is thrown. Declaration lock(cancelable?: Cancelable): Promise<this>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<this> unlock() Releases the lock. If this handle does not own the lock, an Error is thrown. Declaration unlock(): void; Returns Type Description void"
  },
  "api/async-lockable/asynclockable_namespace.html": {
    "href": "api/async-lockable/asynclockable_namespace.html",
    "title": "Namespace AsyncLockable | @esfx API Reference",
    "keywords": "Namespace AsyncLockable Functions isAsyncLockable(value) Determines whether a value is AsyncLockable <!-- --> . Declaration function isAsyncLockable(value: unknown): value is AsyncLockable; Parameters Name Type Description value unknown Returns Type Description value is AsyncLockable"
  },
  "api/async-canceltoken/cancelsource.html": {
    "href": "api/async-canceltoken/cancelsource.html",
    "title": "Interface CancelSource | @esfx API Reference",
    "keywords": "Interface CancelSource Signals a CancelToken when cancellation has been requested. Interfaces Properties token Gets the CancelToken linked to this source. Declaration readonly token: CancelToken; Property Value Type Description CancelToken Interfaces Methods cancel() Cancels the source, evaluating any subscribed callbacks. If any callback raises an exception, the exception is propagated to a host specific unhanedle exception mechanism. Declaration cancel(): void; Returns Type Description void close() Closes the source, preventing the possibility of future cancellation. Declaration close(): void; Returns Type Description void"
  },
  "api/async-barrier/asyncbarrier.html": {
    "href": "api/async-barrier/asyncbarrier.html",
    "title": "Class AsyncBarrier | @esfx API Reference",
    "keywords": "Class AsyncBarrier Enables multiple tasks to cooperatively work on an algorithm through multiple phases. Classes Constructors constructor(participantCount, postPhaseAction) Initializes a new instance of the Barrier class. Declaration constructor(participantCount: number, postPhaseAction?: (barrier: AsyncBarrier) => void | PromiseLike<void>); Parameters Name Type Description participantCount number postPhaseAction (barrier: AsyncBarrier) => void | PromiseLike<void> Classes Properties currentPhaseNumber Gets the number of the Barrier's current phase. Declaration readonly currentPhaseNumber: number; Property Value Type Description number participantCount Gets the total number of participants in the barrier. Declaration readonly participantCount: number; Property Value Type Description number remainingParticipants Gets the number of participants in the barrier that haven't yet signaled in the current phase. Declaration readonly remainingParticipants: number; Property Value Type Description number Classes Methods add(participantCount) Notifies the Barrier there will be additional participants. Declaration add(participantCount?: number): void; Parameters Name Type Description participantCount number Returns Type Description void remove(participantCount) Notifies the Barrier there will be fewer participants. Declaration remove(participantCount?: number): void; Parameters Name Type Description participantCount number Returns Type Description void signalAndWait(cancelable) Signals that a participant has reached the barrier and waits for all other participants to reach the barrier. Declaration signalAndWait(cancelable?: Cancelable): Promise<void>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<void>"
  },
  "api/threading-mutex.html": {
    "href": "api/threading-mutex.html",
    "title": "Package @esfx/threading-mutex | @esfx API Reference",
    "keywords": "Package @esfx/threading-mutex Provides the Mutex class which can be used to protect shared resources across Workers using a SharedArrayBuffer . Overview Installation Usage Installation npm i @esfx/threading-mutex Usage TypeScript JavaScript (CommonJS) import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; import { Mutex } from \"@esfx/threading-mutex\"; import { StructType, int32 } from \"@esfx/struct-type\"; import { sleep } from \"@esfx/threading-sleep\"; const SharedData = StructType([ { name: \"x\", type: int32 }, { name: \"y\", type: int32 }, ] as const); function worker_thread() { const m = new Mutex(workerData[0]); const data = new SharedData(workerData[1]); while (true) { sleep(250); m.lock(); try { // inside of the lock we can mutate 'data' without // main() seeing a partial update. data.x++; data.y--; } finally { m.unlock(); } } } function main() { const m = new Mutex(); const data = new SharedData(/*shared*/ true); const worker = new Worker(__filename, { workerData: [m.buffer, data.buffer] }); while (true) { sleep(500); m.lock(); try { // inside of the lock, we know that we can safely read // both 'x' and 'y' and the worker will not modify // either value until we unlock. console.log(`x: ${data.x}, y: ${data.y}`); } finally { m.unlock(); } } } if (isMainThread) { main(); } else { worker_thread(); } const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const { Mutex } = require(\"@esfx/threading-mutex\"); const { StructType, int32 } = require(\"@esfx/struct-type\"); const { sleep } = require(\"@esfx/threading-sleep\"); const SharedData = StructType([ { name: \"x\", type: int32 }, { name: \"y\", type: int32 }, ]); function worker_thread() { const m = new Mutex(workerData[0]); const data = new SharedData(workerData[1]); while (true) { sleep(250); m.lock(); try { // inside of the lock we can mutate 'data' without // main() seeing a partial update. data.x++; data.y--; } finally { m.unlock(); } } } function main() { const m = new Mutex(); const data = new SharedData(/*shared*/ true); const worker = new Worker(__filename, { workerData: [m.buffer, data.buffer] }); while (true) { sleep(500); m.lock(); try { // inside of the lock, we know that we can safely read // both 'x' and 'y' and the worker will not modify // either value until we unlock. console.log(`x: ${data.x}, y: ${data.y}`); } finally { m.unlock(); } } } if (isMainThread) { main(); } else { worker_thread(); }"
  },
  "api/threading-manualresetevent.html": {
    "href": "api/threading-manualresetevent.html",
    "title": "Package @esfx/threading-manualresetevent | @esfx API Reference",
    "keywords": "Package @esfx/threading-manualresetevent Provides the ManualResetEvent class, a threading primitive for use with Workers. Overview Installation Usage Installation npm i @esfx/threading-manualresetevent Usage TypeScript JavaScript (CommonJS) import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; import { createInterface } from \"readline\"; import { ManualResetEvent } from \"@esfx/threading-manualresetevent\"; import { sleep } from \"@esfx/threading-sleep\"; function worker_thread() { const mre = new ManualResetEvent(workerData); let count = 0; while (true) { mre.wait(); // wait until signaled console.log(`counter: ${count++}`); sleep(500); } } function main() { const mre = new ManualResetEvent(); const worker = new Worker(__filename, { workerData: mre.buffer, stdout: true }); worker.stdout.pipe(process.stdout); console.log(\"Press ENTER to start counter:\"); const rl = createInterface({ input: process.stdin, output: process.stdout }); rl.on(\"line\", () => { if (mre.isSet) { mre.reset(); console.log(\"Press ENTER to start counter:\"); } else { console.log(\"Press ENTER to stop counter:\"); mre.set(); } }); } if (isMainThread) { main(); } else { worker_thread(); } const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const { createInterface } = require(\"readline\"); const { ManualResetEvent } = require(\"@esfx/threading-manualresetevent\"); const { sleep } = require(\"@esfx/threading-sleep\"); function worker_thread() { const mre = new ManualResetEvent(workerData); let count = 0; while (true) { mre.wait(); // wait until signaled console.log(`counter: ${count++}`); sleep(500); } } function main() { const mre = new ManualResetEvent(); const worker = new Worker(__filename, { workerData: mre.buffer, stdout: true }); worker.stdout.pipe(process.stdout); console.log(\"Press ENTER to start counter:\"); const rl = createInterface({ input: process.stdin, output: process.stdout }); rl.on(\"line\", () => { if (mre.isSet) { mre.reset(); console.log(\"Press ENTER to start counter:\"); } else { console.log(\"Press ENTER to stop counter:\"); mre.set(); } }); } if (isMainThread) { main(); } else { worker_thread(); }"
  },
  "api/collection-core/readonlycollection_interface.html": {
    "href": "api/collection-core/readonlycollection_interface.html",
    "title": "Interface ReadonlyCollection | @esfx API Reference",
    "keywords": "Interface ReadonlyCollection Interfaces Properties [ReadonlyCollection.size] Gets the number of elements in the collection. Declaration readonly [ReadonlyCollection.size]: number; Property Value Type Description number Interfaces Methods [ReadonlyCollection.has](value) Tests whether an element is present in the collection. Declaration [ReadonlyCollection.has](value: T): boolean; Parameters Name Type Description value T Returns Type Description boolean"
  },
  "api/collection-core/keyedcollection_namespace.html": {
    "href": "api/collection-core/keyedcollection_namespace.html",
    "title": "Namespace KeyedCollection | @esfx API Reference",
    "keywords": "Namespace KeyedCollection Functions isKeyedCollection(value) Tests whether a value supports the minimal representation of a KeyedCollection <!-- --> . Declaration function isKeyedCollection<K, V>(value: Iterable<[K, V]>): value is KeyedCollection<K, V>; Parameters Name Type Description value Iterable<[K, V]> Returns Type Description value is KeyedCollection<K, V> isKeyedCollection(value) Tests whether a value supports the minimal representation of a KeyedCollection <!-- --> . Declaration function isKeyedCollection(value: unknown): value is KeyedCollection<unknown, unknown>; Parameters Name Type Description value unknown Returns Type Description value is KeyedCollection<unknown, unknown>"
  },
  "api/collection-core/collection_interface.html": {
    "href": "api/collection-core/collection_interface.html",
    "title": "Interface Collection | @esfx API Reference",
    "keywords": "Interface Collection Interfaces Methods [Collection.add](value) Adds an element to the collection. Declaration [Collection.add](value: T): void; Parameters Name Type Description value T Returns Type Description void"
  },
  "api/cancelable/cancelsubscription_namespace.html": {
    "href": "api/cancelable/cancelsubscription_namespace.html",
    "title": "Namespace CancelSubscription | @esfx API Reference",
    "keywords": "Namespace CancelSubscription Functions create(unsubscribe) Creates a CancelSubscription object for an unsubscribe callback. Declaration function create(unsubscribe: () => void): CancelSubscription; Parameters Name Type Description unsubscribe () => void Returns Type Description CancelSubscription"
  },
  "api/cancelable/cancelablesource_interface.html": {
    "href": "api/cancelable/cancelablesource_interface.html",
    "title": "Interface CancelableSource | @esfx API Reference",
    "keywords": "Interface CancelableSource Represents an object that is a source for cancelation. Interfaces Methods [CancelableSource.cancel]() Cancels the source, notifying the associated [[CancelSignal]]. Declaration [CancelableSource.cancel](): void; Returns Type Description void"
  },
  "api/cancelable/cancelablecancelsignal.html": {
    "href": "api/cancelable/cancelablecancelsignal.html",
    "title": "Interface CancelableCancelSignal | @esfx API Reference",
    "keywords": "Interface CancelableCancelSignal Interfaces Methods [Cancelable.cancelSignal]() Declaration [Cancelable.cancelSignal](): CancelableCancelSignal; Returns Type Description CancelableCancelSignal"
  },
  "api/async-readerwriterlock/asyncreaderwriterlockreader.html": {
    "href": "api/async-readerwriterlock/asyncreaderwriterlockreader.html",
    "title": "Interface AsyncReaderWriterLockReader | @esfx API Reference",
    "keywords": "Interface AsyncReaderWriterLockReader Interfaces Properties owner Gets the AsyncReaderWriterLock that owns this object. Declaration readonly owner: AsyncReaderWriterLock; Property Value Type Description AsyncReaderWriterLock"
  },
  "api/async-readerwriterlock/asyncreaderwriterlock.html": {
    "href": "api/async-readerwriterlock/asyncreaderwriterlock.html",
    "title": "Class AsyncReaderWriterLock | @esfx API Reference",
    "keywords": "Class AsyncReaderWriterLock Coordinates readers and writers for a resource. Classes Methods createReader() Creates a AsyncReaderWriterLockReader that can be used to take and release \"read\" locks on a resource. Declaration createReader(): AsyncReaderWriterLockReader; Returns Type Description AsyncReaderWriterLockReader createUpgradeableReader() Creates a AsyncReaderWriterLockUpgradeableReader that can be used to take and release \"read\" locks on a resource and can be later upgraded to take and release \"write\" locks. Declaration createUpgradeableReader(): AsyncReaderWriterLockUpgradeableReader; Returns Type Description AsyncReaderWriterLockUpgradeableReader createWriter() Creates a AsyncReaderWriterLockWriter that can be used to take and release \"write\" locks on a resource. Declaration createWriter(): AsyncReaderWriterLockWriter; Returns Type Description AsyncReaderWriterLockWriter read(cancelable) Asynchronously waits for and takes a read lock on a resource. Declaration read(cancelable?: Cancelable): Promise<AsyncReaderWriterLockReader>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<AsyncReaderWriterLockReader> upgradeableRead(cancelable) Asynchronously waits for and takes a read lock on a resource that can later be upgraded to a write lock. Declaration upgradeableRead(cancelable?: Cancelable): Promise<AsyncReaderWriterLockUpgradeableReader>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<AsyncReaderWriterLockUpgradeableReader> write(cancelable) Asynchronously waits for and takes a write lock on a resource. Declaration write(cancelable?: Cancelable): Promise<AsyncReaderWriterLockWriter>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<AsyncReaderWriterLockWriter>"
  },
  "api/collections.html": {
    "href": "api/collections.html",
    "title": "Package @esfx/collections | @esfx API Reference",
    "keywords": "Package @esfx/collections Provides a number of common collection classes from the following packages: @esfx/collections-sortedmap @esfx/collections-sortedset @esfx/collections-hashmap @esfx/collections-hashset @esfx/collections-linkedlist Installation npm i @esfx/collections"
  },
  "api/collections-hashset.html": {
    "href": "api/collections-hashset.html",
    "title": "Package @esfx/collections-hashset | @esfx API Reference",
    "keywords": "Package @esfx/collections-hashset Provides the HashSet class, a collection class that utilizes @esfx/collection-core and @esfx/equatable . Overview Installation Usage Installation npm i @esfx/collections-hashset Usage TypeScript JavaScript (CommonJS) import { HashSet } from \"@esfx/collections-hashset\"; import { Equatable, Equaler, Comparable, Comparer } from \"@esfx/equatable\"; class Person { firstName: string; lastName: string; constructor(firstName: string, lastName: string) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other: unknown) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other: unknown) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Bob\", \"Clark\"); const obj2 = new Person(\"Bob\", \"Clark\"); const set = new Set<Person>(); // native ECMAScript Set set.add(obj1); set.add(obj2); set.length; // 2 const hashSet = new HashSet<Person>(); hashSet.add(obj1); hashSet.add(obj2); hashSet.length; // 1 const { HashSet } = require(\"@esfx/collections-hashset\"); const { Equatable, Equaler, Comparable, Comparer } = require(\"@esfx/equatable\"); class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Bob\", \"Clark\"); const obj2 = new Person(\"Bob\", \"Clark\"); const set = new Set(); // native ECMAScript Set set.add(obj1); set.add(obj2); set.length; // 2 const hashSet = new HashSet(); hashSet.add(obj1); hashSet.add(obj2); hashSet.length; // 1"
  },
  "api/collection-core-dom-shim.html": {
    "href": "api/collection-core-dom-shim.html",
    "title": "Package @esfx/collection-core-dom-shim | @esfx API Reference",
    "keywords": "Package @esfx/collection-core-dom-shim Provides a global shim to add default @esfx/collection-core behaviors to global DOM objects. Overview Installation Usage Installation npm i @esfx/collection-core-dom-shim Usage The global shim adds a default implementation the collection interfaces to the following global DOM objects: AudioParamMap implements: @\"collection-core.ReadonlyKeyedCollection\" AudioTrackList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" CSSRuleList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" CSSStyleDeclaration implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" ClientRectList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" DOMRectList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" DOMStringList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" DOMTokenList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" DataTransferItemList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" FileList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" FormData implements: @\"collection-core.KeyedCollection\" @\"collection-core.ReadonlyKeyedCollection\" HTMLAllCollection implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" HTMLCollectionBase implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" HTMLCollectionOf implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" HTMLFormElement implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" HTMLSelectElement implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" Headers implements: @\"collection-core.KeyedCollection\" @\"collection-core.ReadonlyKeyedCollection\" MediaKeyStatusMap implements: @\"collection-core.ReadonlyKeyedCollection\" MediaList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" MimeTypeArray implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" NamedNodeMap implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" NodeList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" Plugin implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" PluginArray implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" RTCStatsReport implements: @\"collection-core.ReadonlyKeyedCollection\" SVGLengthList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" SVGNumberList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" SVGStringList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" SourceBufferList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" SpeechGrammarList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" SpeechRecognitionResult implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" SpeechRecognitionResultList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" StyleSheetList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" TextTrackCueList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" TextTrackList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" TouchList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" URLSearchParams implements: @\"collection-core.KeyedCollection\" @\"collection-core.ReadonlyKeyedCollection\" @\"collection-core.ReadonlyKeyedCollection\" VideoTrackList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" To install the global shim, import @esfx/collection-core-dom-shim : TypeScript JavaScript (CommonJS) import \"@esfx/collection-core-dom-shim\"; // triggers global-scope side effects import { ReadonlyIndexedCollection } from \"@esfx/collection-core\"; document.anchors[ReadonlyIndexedCollection.size]; // gets the number of anchors in the document require(\"@esfx/collection-core-dom-shim\"); // triggers global-scope side effects const { ReadonlyIndexedCollection } = require(\"@esfx/collection-core\"); document.anchors[ReadonlyIndexedCollection.size]; // gets the number of anchors in the document"
  },
  "api/async.html": {
    "href": "api/async.html",
    "title": "Package @esfx/async | @esfx API Reference",
    "keywords": "Package @esfx/async Provides a number of asynchronous coordination primitives from the following packages: @esfx/async-autoresetevent @esfx/async-barrier @esfx/async-canceltoken @esfx/async-conditionvariable @esfx/async-countdown @esfx/async-deferred @esfx/async-delay @esfx/async-lazy @esfx/async-lockable @esfx/async-manualresetevent @esfx/async-mutex @esfx/async-queue @esfx/async-readerwriterlock @esfx/async-semaphore @esfx/async-stack @esfx/async-waitqueue Installation npm i @esfx/async"
  },
  "api/ref/ref_namespace.html": {
    "href": "api/ref/ref_namespace.html",
    "title": "Namespace ref | @esfx API Reference",
    "keywords": "Namespace ref Functions _for(value) Creates a ref for an initial value. Declaration function _for<T>(value: T): Reference<T>; Parameters Name Type Description value T Returns Type Description Reference<T> _is(value) Determines whether value is a [[ref]]. Declaration function _is(value: unknown): value is Reference<any>; Parameters Name Type Description value unknown Returns Type Description value is Reference<any> at(object, key, readonly) Creates a ref to a property of an object. Declaration function at<T, K extends keyof T>(object: T, key: K, readonly?: boolean): Reference<T[K]>; Parameters Name Type Description object T key K readonly boolean Returns Type Description Reference<T[K]> out() Creates a ref that must be set before it can be read. Declaration function out<T>(): Reference<T>; Returns Type Description Reference<T> out(get, set) Declaration function out<T>(get: () => T, set: (value: T) => void): Reference<T>; Parameters Name Type Description get () => T set (value: T) => void Returns Type Description Reference<T>"
  },
  "api/ref/reference.html": {
    "href": "api/ref/reference.html",
    "title": "Interface Reference | @esfx API Reference",
    "keywords": "Interface Reference A reference to a lexical value. Interfaces Properties __@toStringTag Declaration [Symbol.toStringTag]: string; Property Value Type Description string value Declaration value: T; Property Value Type Description T"
  },
  "api/lazy/lazy.html": {
    "href": "api/lazy/lazy.html",
    "title": "Class Lazy | @esfx API Reference",
    "keywords": "Class Lazy Classes Constructors constructor(factory) Constructs a new instance of the Lazy class Declaration constructor(factory: () => T); Parameters Name Type Description factory () => T Classes Properties hasValue Declaration readonly hasValue: boolean; Property Value Type Description boolean value Declaration readonly value: T; Property Value Type Description T Classes Methods for(value) Declaration static for<T>(value: T): Lazy<T>; Parameters Name Type Description value T Returns Type Description Lazy<T> from(factory, args) Declaration static from<T, A extends any[]>(factory: (...args: A) => T, ...args: A): Lazy<T>; Parameters Name Type Description factory (...args: A) => T args A Returns Type Description Lazy<T>"
  },
  "api/indexed-object/integerindexedobject.html": {
    "href": "api/indexed-object/integerindexedobject.html",
    "title": "Class IntegerIndexedObject | @esfx API Reference",
    "keywords": "Class IntegerIndexedObject Represents an object that can be indexed by an integer value similar to a native Array or TypedArray. Classes Constructors constructor() Constructs a new instance of the IntegerIndexedObject class Declaration constructor(); Classes Methods deleteIndex(index) Deletes the value at the specified index/ Declaration protected deleteIndex(index: number): boolean; Parameters Name Type Description index number Returns Type Description boolean true if the value was successfully deleted; otherwise, false <!-- --> . getIndex(index) Gets the value at the specified index. Declaration protected abstract getIndex(index: number): T; Parameters Name Type Description index number Returns Type Description T getLength() Gets the \"length\" of the indexed object, which should be one more than the largest index stored in the object. Declaration protected abstract getLength(): number; Returns Type Description number hasIndex(index) Determines whether the object contains a value at the specified index. Declaration protected hasIndex(index: number): boolean; Parameters Name Type Description index number Returns Type Description boolean setIndex(index, value) Sets the value at the specified index. Declaration protected setIndex(index: number, value: T): boolean; Parameters Name Type Description index number value T Returns Type Description boolean true if the value could be set; otherwise, false <!-- --> ."
  },
  "api/collection-core/fixedsizeindexedcollection_interface.html": {
    "href": "api/collection-core/fixedsizeindexedcollection_interface.html",
    "title": "Interface FixedSizeIndexedCollection | @esfx API Reference",
    "keywords": "Interface FixedSizeIndexedCollection Interfaces Methods [FixedSizeIndexedCollection.setAt](index, value) Sets a value at the specified index in the collection. Declaration [FixedSizeIndexedCollection.setAt](index: number, value: T): boolean; Parameters Name Type Description index number value T Returns Type Description boolean true if the value was set at the provided index, otherwise false <!-- --> ."
  },
  "api/collection-core/collection_namespace.html": {
    "href": "api/collection-core/collection_namespace.html",
    "title": "Namespace Collection | @esfx API Reference",
    "keywords": "Namespace Collection Functions isCollection(value) Tests whether a value supports the minimal representation of a Collection <!-- --> . Declaration function isCollection<T>(value: Iterable<T>): value is Collection<T>; Parameters Name Type Description value Iterable<T> Returns Type Description value is Collection<T> isCollection(value) Tests whether a value supports the minimal representation of a Collection <!-- --> . Declaration function isCollection(value: any): value is Collection<unknown>; Parameters Name Type Description value any Returns Type Description value is Collection<unknown>"
  },
  "api/cancelable/cancelable_interface.html": {
    "href": "api/cancelable/cancelable_interface.html",
    "title": "Interface Cancelable | @esfx API Reference",
    "keywords": "Interface Cancelable An object that can be canceled from an external source. Interfaces Methods [Cancelable.cancelSignal]() Gets the [[CancelSignal]] for this [[Cancelable]]. Declaration [Cancelable.cancelSignal](): CancelSignal; Returns Type Description CancelSignal"
  },
  "api/cancelable/cancelablesource_namespace.html": {
    "href": "api/cancelable/cancelablesource_namespace.html",
    "title": "Namespace CancelableSource | @esfx API Reference",
    "keywords": "Namespace CancelableSource Functions isCancelableSource(value) Determines whether a value is a CancelableSource object. Declaration function isCancelableSource(value: unknown): value is CancelableSource; Parameters Name Type Description value unknown Returns Type Description value is CancelableSource"
  },
  "api/struct-type/structclass.html": {
    "href": "api/struct-type/structclass.html",
    "title": "Interface StructClass | @esfx API Reference",
    "keywords": "Interface StructClass Interfaces Properties [kFields] Declaration [kFields]: TDef; Property Value Type Description TDef SIZE Declaration readonly SIZE: number; Property Value Type Description number"
  },
  "api/struct-type/struct.html": {
    "href": "api/struct-type/struct.html",
    "title": "Class Struct | @esfx API Reference",
    "keywords": "Class Struct Classes Constructors constructor() Constructs a new instance of the Struct class Declaration constructor(); constructor(shared) Constructs a new instance of the Struct class Declaration constructor(shared: boolean); Parameters Name Type Description shared boolean constructor(buffer, byteOffset) Constructs a new instance of the Struct class Declaration constructor(buffer: ArrayBufferLike, byteOffset?: number); Parameters Name Type Description buffer ArrayBufferLike byteOffset number constructor(object, shared) Constructs a new instance of the Struct class Declaration constructor(object: Partial<StructInitProperties<TDef>>, shared?: boolean); Parameters Name Type Description object Partial<StructInitProperties<TDef>> shared boolean constructor(elements, shared) Constructs a new instance of the Struct class Declaration constructor(elements: Partial<StructInitElements<TDef>>, shared?: boolean); Parameters Name Type Description elements Partial<StructInitElements<TDef>> shared boolean Classes Properties buffer Declaration readonly buffer: ArrayBuffer | SharedArrayBuffer; Property Value Type Description ArrayBuffer | SharedArrayBuffer byteLength Declaration readonly byteLength: number; Property Value Type Description number byteOffset Declaration readonly byteOffset: number; Property Value Type Description number SIZE Declaration static readonly SIZE: number; Property Value Type Description number Classes Methods get(key) Declaration get<K extends keyof StructProperties<TDef>>(key: K): StructProperties<TDef>[K]; Parameters Name Type Description key K Returns Type Description StructProperties<TDef>[K] getIndex(index) Declaration getIndex<I extends keyof StructElements<TDef>>(index: I): StructElements<TDef>[I]; Parameters Name Type Description index I Returns Type Description StructElements<TDef>[I] set(key, value) Declaration set<K extends keyof StructProperties<TDef>>(key: K, value: StructProperties<TDef>[K]): void; Parameters Name Type Description key K value StructProperties<TDef>[K] Returns Type Description void setIndex(index, value) Declaration setIndex<I extends keyof StructElements<TDef>>(index: I, value: StructElements<TDef>[I]): boolean; Parameters Name Type Description index I value StructElements<TDef>[I] Returns Type Description boolean writeTo(buffer, byteOffset) Declaration writeTo(buffer: ArrayBufferLike, byteOffset?: number): void; Parameters Name Type Description buffer ArrayBufferLike byteOffset number Returns Type Description void"
  },
  "api/equatable/equaler_interface.html": {
    "href": "api/equatable/equaler_interface.html",
    "title": "Interface Equaler | @esfx API Reference",
    "keywords": "Interface Equaler Represents an object that can be used to compare the equality of two objects. Interfaces Methods equals(x, y) Tests whether two values are equal to each other. Declaration equals(x: T, y: T): boolean; Parameters Name Type Description x T y T Returns Type Description boolean hash(x) Generates a hash code for a value. Declaration hash(x: T): number; Parameters Name Type Description x T Returns Type Description number"
  },
  "api/equatable/comparer_namespace.html": {
    "href": "api/equatable/comparer_namespace.html",
    "title": "Namespace Comparer | @esfx API Reference",
    "keywords": "Namespace Comparer Functions create(comparison) Creates a Comparer from a comparison function. Declaration function create<T>(comparison: Comparison<T>): Comparer<T>; Parameters Name Type Description comparison Comparison<T> Returns Type Description Comparer<T>"
  },
  "api/async-deferred/deferred.html": {
    "href": "api/async-deferred/deferred.html",
    "title": "Class Deferred | @esfx API Reference",
    "keywords": "Class Deferred Encapsulates a Promise and exposes its resolve and reject callbacks. Classes Constructors constructor() Initializes a new instance of the Deferred class. Declaration constructor(); Classes Properties callback Gets a NodeJS-style callback that can be used to resolve or reject the promise. Declaration readonly callback: T extends void ? (err: Error | null | undefined) => void : (err: Error | null | undefined, value: T) => void; Property Value Type Description T extends void ? (err: Error | null | undefined) => void : (err: Error | null | undefined, value: T) => void promise Gets the promise. Declaration readonly promise: Promise<T>; Property Value Type Description Promise<T> reject Gets the callback used to reject the promise. Declaration readonly reject: (reason: any) => void; Property Value Type Description (reason: any) => void resolve Gets the callback used to resolve the promise. Declaration readonly resolve: (value?: T | PromiseLike<T> | undefined) => void; Property Value Type Description (value?: T | PromiseLike<T> | undefined) => void Classes Methods createCallback(selector) Creates a NodeJS-style callback that can be used to resolve or reject the promise with multiple values. Declaration createCallback<A extends any[]>(selector: (...args: A) => T): (err: Error | null | undefined, ...args: A) => void; Parameters Name Type Description selector (...args: A) => T Returns Type Description (err: Error | null | undefined, ...args: A) => void"
  },
  "api/async-countdown/asynccountdownevent.html": {
    "href": "api/async-countdown/asynccountdownevent.html",
    "title": "Class AsyncCountdownEvent | @esfx API Reference",
    "keywords": "Class AsyncCountdownEvent An event that is set when all participants have signaled. Classes Constructors constructor(initialCount) Initializes a new instance of the CountdownEvent class. Declaration constructor(initialCount: number); Parameters Name Type Description initialCount number Classes Properties initialCount Gets the number of signals initially required to set the event. Declaration readonly initialCount: number; Property Value Type Description number remainingCount Gets the number of remaining signals required to set the event. Declaration readonly remainingCount: number; Property Value Type Description number Classes Methods add(count) Increments the event's current count by one or more. Declaration add(count?: number): void; Parameters Name Type Description count number Returns Type Description void reset(count) Resets the remaining and initial count to the specified value, or the initial count. Declaration reset(count?: number): void; Parameters Name Type Description count number Returns Type Description void signal(count) Registers one or more signals with the CountdownEvent, decrementing the remaining count. Declaration signal(count?: number): boolean; Parameters Name Type Description count number Returns Type Description boolean wait(cancelable) Asynchronously waits for the event to become signaled. Declaration wait(cancelable?: Cancelable): Promise<void>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<void>"
  },
  "api/events.html": {
    "href": "api/events.html",
    "title": "Package @esfx/events | @esfx API Reference",
    "keywords": "Package @esfx/events Provides a low-level API for defining events. Overview Installation Usage Installation npm i @esfx/events Usage TypeScript JavaScript (CommonJS) import { Event } from \"@esfx/events\"; class MyService { private _loadedEvent = Event.create<(this: MyService) => void(this); readonly loadedEvent = this._loadedEvent.event; load() { ... this._loadedEvent.emit(); } } const svc = new MyService(); svc.loadedEvent.on(() => console.log(\"loaded\")); svc.load(); const { Event } = require(\"@esfx/events\"); class MyService { constructor() { this._loadedEvent = Event.create(this); this.loadedEvent = this._loadedEvent.event; } load() { ... this._loadedEvent.emit(); } } // Use const svc = new MyService(); svc.loadedEvent.on(() => console.log(\"loaded\")); svc.load();"
  },
  "api/collections-sortedset.html": {
    "href": "api/collections-sortedset.html",
    "title": "Package @esfx/collections-sortedset | @esfx API Reference",
    "keywords": "Package @esfx/collections-sortedset Provides the SortedSet class, a collection class that utilizes @esfx/collection-core and @esfx/equatable . Overview Installation Usage Installation npm i @esfx/collections-sortedset Usage TypeScript JavaScript (CommonJS) import { SortedSet } from \"@esfx/collections-sortedset\"; import { Equatable, Equaler, Comparable, Comparer } from \"@esfx/equatable\"; class Person { firstName: string; lastName: string; constructor(firstName: string, lastName: string) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other: unknown) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other: unknown) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Alice\", \"Johnson\"); const obj2 = new Person(\"Bob\", \"Clark\"); // ECMAScript native set iterates in insertion order const set = new Set<Person>(); // native ECMAScript Set set.add(obj1); set.add(obj2); [...set]; // Alice Johnson,Bob Clark // SortedSet uses Comparable.compareTo if available const sortedSet = new SortedSet<Person>(); sortedSet.add(obj1); sortedSet.add(obj2); [...sortedSet]; // Bob Clark,Alice Johnson const { SortedSet } = require(\"@esfx/collections-sortedset\"); const { Equatable, Equaler, Comparable, Comparer } = require(\"@esfx/equatable\"); class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Alice\", \"Johnson\"); const obj2 = new Person(\"Bob\", \"Clark\"); // ECMAScript native set iterates in insertion order const set = new Set(); // native ECMAScript Set set.add(obj1); set.add(obj2); [...set]; // Alice Johnson,Bob Clark // SortedSet uses Comparable.compareTo if available const sortedSet = new SortedSet(); sortedSet.add(obj1); sortedSet.add(obj2); [...sortedSet]; // Bob Clark,Alice Johnson"
  },
  "api/async-canceltoken.html": {
    "href": "api/async-canceltoken.html",
    "title": "Package @esfx/async-canceltoken | @esfx API Reference",
    "keywords": "Package @esfx/async-canceltoken The @esfx/async-canceltoken package provides the CancelToken class, an implementation of @esfx/cancelable . Overview Installation Usage Installation npm i @esfx/async-canceltoken Usage Basic Usage Linking Tokens Basic Usage TypeScript JavaScript (CommonJS) import { CancelToken } from \"@esfx/async-canceltoken\"; // consume a cancel token async function doWork(token = CancelToken.none) { // do some work await doSomeOtherWork(token); // throw an error if cancellation has been signaled since awaiting. token.throwIfSignaled(); } function doSomeOtherWork(token = CancelToken.none) { return new Promise((resolve, reject) => { token.throwIfSignaled(); // throw if cancellation has already been signaled. // setup some external async operation... const worker = ...; // listen for cancellation and abort the worker. const subscription = token.subscribe(() => { worker.abort(); reject(new CancelError()); }); // start working, resolve when done worker.start(resolve); }); } // call an async function that supports cancellation const source = CancelToken.source(); doWork(source.token).then(() => { // operation completed... source.close(); }, err => { if (err instanceof CancelError) { // operation was canceled.. } }); // cancel operation after 10 seconds setTimeout(() => source.cancel(), 1000 * 10); const { CancelToken } = require(\"@esfx/async-canceltoken\"); // consume a cancel token async function doWork(token = CancelToken.none) { // do some work await doSomeOtherWork(token); // throw an error if cancellation has been signaled since awaiting. token.throwIfSignaled(); } function doSomeOtherWork(token = CancelToken.none) { return new Promise((resolve, reject) => { token.throwIfSignaled(); // throw if cancellation has already been signaled. // setup some external async operation... const worker = ...; // listen for cancellation and abort the worker. const subscription = token.subscribe(() => { worker.abort(); reject(new CancelError()); }); // start working, resolve when done worker.start(resolve); }); } // call an async function that supports cancellation const source = CancelToken.source(); doWork(source.token).then(() => { // operation completed... source.close(); }, err => { if (err instanceof CancelError) { // operation was canceled.. } }); // cancel operation after 10 seconds setTimeout(() => source.cancel(), 1000 * 10); Linking Tokens TypeScript JavaScript (CommonJS) import { CancelToken } from \"@esfx/async-canceltoken\"; // You can compose a cancellation graph with a root CancelToken, allowing you to cancel a large // number of asynchronous operations all at once let rootSource = CancelToken.source(); function cancelAllDownloads() { // explicitly cancel all downloads rootSource.cancel(); // reset the root source rootSource = CancelToken.source(); } async function downloadFile(url, path, token = CancelToken.none) { // add own source for timeout after 60 seconds const timeoutSource = CancelToken.source(); setTimeout(() => timeoutSource.cancel(), 60 * 1000); // download can be canceled by either 'rootSource', 'timeoutSource' or 'token': const linkedToken = CancelToken.race([rootSource.token, timeoutSource.token, token]); // ... use linkedToken to observe cancellation. } const { CancelToken } = require(\"@esfx/async-canceltoken\"); // You can compose a cancellation graph with a root CancelToken, allowing you to cancel a large // number of asynchronous operations all at once let rootSource = CancelToken.source(); function cancelAllDownloads() { // explicitly cancel all downloads rootSource.cancel(); // reset the root source rootSource = CancelToken.source(); } async function downloadFile(url, path, token = CancelToken.none) { // add own source for timeout after 60 seconds const timeoutSource = CancelToken.source(); setTimeout(() => timeoutSource.cancel(), 60 * 1000); // download can be canceled by either 'rootSource', 'timeoutSource' or 'token': const linkedToken = CancelToken.race([rootSource.token, timeoutSource.token, token]); // ... use linkedToken to observe cancellation. }"
  },
  "api/cancelable/cancelsignal.html": {
    "href": "api/cancelable/cancelsignal.html",
    "title": "Interface CancelSignal | @esfx API Reference",
    "keywords": "Interface CancelSignal An object that represents a cancellation signal. Interfaces Properties signaled Gets a value indicating whether cancellation was signaled. Declaration readonly signaled: boolean; Property Value Type Description boolean Interfaces Methods subscribe(onSignaled) Subscribes to notifications for when the object becomes signaled. Declaration subscribe(onSignaled: () => void): CancelSubscription; Parameters Name Type Description onSignaled () => void Returns Type Description CancelSubscription"
  },
  "api/threading.html": {
    "href": "api/threading.html",
    "title": "Package @esfx/threading | @esfx API Reference",
    "keywords": "Package @esfx/threading Provides a number Thread synchronization primitives for use with Workers from the following packages: @esfx/threading-autoresetevent @esfx/threading-conditionvariable @esfx/threading-countdown @esfx/threading-lockable @esfx/threading-manualresetevent @esfx/threading-mutex @esfx/threading-semaphore @esfx/threading-sleep @esfx/threading-spinwait Installation npm i @esfx/threading"
  },
  "api/threading-spinwait.html": {
    "href": "api/threading-spinwait.html",
    "title": "Package @esfx/threading-spinwait | @esfx API Reference",
    "keywords": "Package @esfx/threading-spinwait Provides the SpinWait class, a thread synchronization primitive for use with Workers. Overview Installation Usage Installation npm i @esfx/threading-spinwait Usage TypeScript JavaScript (CommonJS) import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; import { SpinWait } from \"@esfx/threading-spinwait\"; import { StructType, int32 } from \"@esfx/struct-type\"; const SharedData = StructType([ { name: \"ready\", type: int32 }, ] as const); function worker_thread() { const data = new SharedData(workerData); // do some long running process... // signal that the work has completed. data.ready = 1; } function main() { const data = new SharedData(/*shared*/ true); const worker = new Worker(__filename, { workerData: data.buffer }); // start spinning until the condition is met. // this results in the thread sleeping periodically // while it waits for the condition. const spinWait = new SpinWait(); spinWait.spinUntil(() => data.ready === 1); } if (isMainThread) { main(); } else { worker_thread(); } const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const { SpinWait } = require(\"@esfx/threading-spinwait\"); const { StructType, int32 } = require(\"@esfx/struct-type\"); const SharedData = StructType([ { name: \"ready\", type: int32 }, ]); function worker_thread() { const data = new SharedData(workerData); // do some long running process... // signal that the work has completed. data.ready = 1; } function main() { const data = new SharedData(/*shared*/ true); const worker = new Worker(__filename, { workerData: data.buffer }); // start spinning until the condition is met. // this results in the thread sleeping periodically // while it waits for the condition. const spinWait = new SpinWait(); spinWait.spinUntil(() => data.ready === 1); } if (isMainThread) { main(); } else { worker_thread(); }"
  },
  "api/threading-autoresetevent.html": {
    "href": "api/threading-autoresetevent.html",
    "title": "Package @esfx/threading-autoresetevent | @esfx API Reference",
    "keywords": "Package @esfx/threading-autoresetevent Provides the AutoResetEvent class, a threading primitive for use with Workers. Overview Installation Usage Installation npm i @esfx/threading-autoresetevent Usage TypeScript JavaScript (CommonJS) import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; import { createInterface } from \"readline\"; import { AutoResetEvent } from \"@esfx/threading-autoresetevent\"; function worker_thread() { const workerReadyEvent = new AutoResetEvent(workerData[0]); const continueEvent = new AutoResetEvent(workerData[1]); // signal the main thread we are ready workerReadyEvent.set(); let count = 0; while (true) { // wait for the main thread to set 'continueEvent' continueEvent.wait(); parentPort.postMessage(`counter=${count++}`); } } function main() { // create two AutoResetEvents in the main thread const workerReadyEvent = new AutoResetEvent(); const continueEvent = new AutoResetEvent(); // create a Worker, passing the buffers of the two events const worker = new Worker(__filename, { workerData: [workerReadyEvent.buffer, continueEvent.buffer] }); // wait for the worker to tell us it is ready workerReadyEvent.wait(); console.log(\"worker is ready. Press ENTER to continue the worker...\"); worker.on(\"message\", message => { console.log(`worker says: ${message}`); }); const rl = createInterface({ input: process.stdin, output: process.stdout }); rl.on(\"line\", () => { // event is automatically reset as soon as a single waiter is signaled continueEvent.set(); }); } if (isMainThread) { main(); } else { worker_thread(); } const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const { createInterface } = require(\"readline\"); const { AutoResetEvent } = require(\"@esfx/threading-autoresetevent\"); function worker_thread() { const workerReadyEvent = new AutoResetEvent(workerData[0]); const continueEvent = new AutoResetEvent(workerData[1]); // signal the main thread we are ready workerReadyEvent.set(); let count = 0; while (true) { // wait for the main thread to set 'continueEvent' continueEvent.wait(); parentPort.postMessage(`counter=${count++}`); } } function main() { // create two AutoResetEvents in the main thread const workerReadyEvent = new AutoResetEvent(); const continueEvent = new AutoResetEvent(); // create a Worker, passing the buffers of the two events const worker = new Worker(__filename, { workerData: [workerReadyEvent.buffer, continueEvent.buffer] }); // wait for the worker to tell us it is ready workerReadyEvent.wait(); console.log(\"worker is ready. Press ENTER to continue the worker...\"); worker.on(\"message\", message => { console.log(`worker says: ${message}`); }); const rl = createInterface({ input: process.stdin, output: process.stdout }); rl.on(\"line\", () => { // event is automatically reset as soon as a single waiter is signaled continueEvent.set(); }); } if (isMainThread) { main(); } else { worker_thread(); }"
  },
  "api/collections-hashmap.html": {
    "href": "api/collections-hashmap.html",
    "title": "Package @esfx/collections-hashmap | @esfx API Reference",
    "keywords": "Package @esfx/collections-hashmap Provides the HashMap class, a collection class that utilizes @esfx/collection-core and @esfx/equatable . Overview Installation Usage Installation npm i @esfx/collections-hashmap Usage TypeScript JavaScript (CommonJS) import { HashMap } from \"@esfx/collections-hashmap\"; import { Equatable, Equaler, Comparable, Comparer } from \"@esfx/equatable\"; class Person { firstName: string; lastName: string; constructor(firstName: string, lastName: string) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other: unknown) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other: unknown) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Bob\", \"Clark\"); const obj2 = new Person(\"Bob\", \"Clark\"); const set = new Map<Person, string>(); // native ECMAScript Map set.set(obj1, \"obj1\"); set.set(obj2, \"obj2\"); set.size; // 2 const hashMap = new HashMap<Person, string>(); hashMap.set(obj1, \"obj1\"); hashMap.set(obj2, \"obj2\"); hashMap.size; // 1 const { HashMap } = require(\"@esfx/collections-hashmap\"); const { Equatable, Equaler, Comparable, Comparer } = require(\"@esfx/equatable\"); class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Bob\", \"Clark\"); const obj2 = new Person(\"Bob\", \"Clark\"); const set = new Map(); // native ECMAScript Map set.set(obj1, \"obj1\"); set.set(obj2, \"obj2\"); set.size; // 2 const hashMap = new HashMap(); hashMap.set(obj1, \"obj1\"); hashMap.set(obj2, \"obj2\"); hashMap.size; // 1"
  },
  "api/async-queue.html": {
    "href": "api/async-queue.html",
    "title": "Package @esfx/async-queue | @esfx API Reference",
    "keywords": "Package @esfx/async-queue The @esfx/async-queue package provides the AsyncQueue class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-queue Usage TypeScript JavaScript (CommonJS) import { AsyncQueue } from \"@esfx/async-queue\"; async function main() { const queue = new AsyncQueue<number>(); // put two items on the queue queue.put(1); queue.put(Promise.resolve(2)); // take two items from the queue await queue.get(); // 1 await queue.get(); // 2 // take two more pending items from the queue const p3 = queue.get(); const p4 = queue.get(); // put two more items on the queue queue.put(3); queue.put(4); await p3; // 3 await p4; // 4 } const { AsyncQueue } = require(\"@esfx/async-queue\"); async function main() { const queue = new AsyncQueue(); // put two items on the queue queue.put(1); queue.put(Promise.resolve(2)); // take two items from the queue await queue.get(); // 1 await queue.get(); // 2 // take two more pending items from the queue const p3 = queue.get(); const p4 = queue.get(); // put two more items on the queue queue.put(3); queue.put(4); await p3; // 3 await p4; // 4 }"
  },
  "api/struct-type/structtype_interface.html": {
    "href": "api/struct-type/structtype_interface.html",
    "title": "Interface StructType | @esfx API Reference",
    "keywords": "Interface StructType Interfaces Properties [kFields] Declaration [kFields]: TDef; Property Value Type Description TDef SIZE Declaration readonly SIZE: number; Property Value Type Description number"
  },
  "api/struct-type/structtypeconstructor.html": {
    "href": "api/struct-type/structtypeconstructor.html",
    "title": "Interface StructTypeConstructor | @esfx API Reference",
    "keywords": "Interface StructTypeConstructor Interfaces Properties prototype Declaration prototype: typeof Struct; Property Value Type Description typeof Struct"
  },
  "api/equatable/structuralequatable_interface.html": {
    "href": "api/equatable/structuralequatable_interface.html",
    "title": "Interface StructuralEquatable | @esfx API Reference",
    "keywords": "Interface StructuralEquatable Represents a value that can compare its structural equality with another value. Interfaces Methods [StructuralEquatable.structuralEquals](other, equaler) Determines whether this value is structurally equal to another value using the supplied Equaler <!-- --> . Declaration [StructuralEquatable.structuralEquals](other: unknown, equaler: Equaler<unknown>): boolean; Parameters Name Type Description other unknown equaler Equaler<unknown> Returns Type Description boolean"
  },
  "api/equatable/structuralcomparable_namespace.html": {
    "href": "api/equatable/structuralcomparable_namespace.html",
    "title": "Namespace StructuralComparable | @esfx API Reference",
    "keywords": "Namespace StructuralComparable Functions isStructuralComparable(value) Determines whether a value is StructuralComparable. Declaration function isStructuralComparable(value: unknown): value is StructuralComparable; Parameters Name Type Description value unknown Returns Type Description value is StructuralComparable"
  },
  "api/equatable/structuralcomparable_interface.html": {
    "href": "api/equatable/structuralcomparable_interface.html",
    "title": "Interface StructuralComparable | @esfx API Reference",
    "keywords": "Interface StructuralComparable Represents a value that can compare its structure relationally with another value. Interfaces Methods [StructuralComparable.structuralCompareTo](other, comparer) Compares the structure of this value with another value using the supplied comparer: - A negative value indicates this value is lesser. - A positive value indicates this value is greater. - A zero value indicates this value is the same. Declaration [StructuralComparable.structuralCompareTo](other: unknown, comparer: Comparer<unknown>): number; Parameters Name Type Description other unknown comparer Comparer<unknown> Returns Type Description number"
  },
  "api/equatable/equatable_namespace.html": {
    "href": "api/equatable/equatable_namespace.html",
    "title": "Namespace Equatable | @esfx API Reference",
    "keywords": "Namespace Equatable Functions isEquatable(value) Determines whether a value is Equatable. Declaration function isEquatable(value: unknown): value is Equatable; Parameters Name Type Description value unknown Returns Type Description value is Equatable"
  },
  "api/decorators-stage1-core/methodmemberdescriptor.html": {
    "href": "api/decorators-stage1-core/methodmemberdescriptor.html",
    "title": "Interface MethodMemberDescriptor | @esfx API Reference",
    "keywords": "Interface MethodMemberDescriptor Interfaces Properties descriptor Declaration descriptor: MethodPropertyDescriptor<T>; Property Value Type Description MethodPropertyDescriptor<T>"
  },
  "api/decorators-stage1-core/memberdescriptor.html": {
    "href": "api/decorators-stage1-core/memberdescriptor.html",
    "title": "Interface MemberDescriptor | @esfx API Reference",
    "keywords": "Interface MemberDescriptor Interfaces Properties descriptor Declaration descriptor?: TypedPropertyDescriptor<T>; Property Value Type Description TypedPropertyDescriptor<T> key Declaration key: string | symbol; Property Value Type Description string | symbol kind Declaration kind: \"member\"; Property Value Type Description \"member\" target Declaration target: object; Property Value Type Description object"
  },
  "api/async-lockable/asynclockable_interface.html": {
    "href": "api/async-lockable/asynclockable_interface.html",
    "title": "Interface AsyncLockable | @esfx API Reference",
    "keywords": "Interface AsyncLockable Represents a value that can be used to synchronize access to a resource. Interfaces Methods [AsyncLockable.lock](cancelable) Takes a lock. Declaration [AsyncLockable.lock](cancelable?: Cancelable): Promise<LockHandle>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<LockHandle>"
  },
  "api/async-lazy/asynclazy.html": {
    "href": "api/async-lazy/asynclazy.html",
    "title": "Class AsyncLazy | @esfx API Reference",
    "keywords": "Class AsyncLazy A lazy-initialized asynchronous value. Classes Constructors constructor(factory) Constructs a new instance of the AsyncLazy class Declaration constructor(factory: () => T | PromiseLike<T>); Parameters Name Type Description factory () => T | PromiseLike<T> Classes Properties isStarted Declaration readonly isStarted: boolean; Property Value Type Description boolean value Declaration readonly value: Promise<T>; Property Value Type Description Promise<T> Classes Methods for(value) Declaration static for<T>(value: T | PromiseLike<T>): AsyncLazy<T>; Parameters Name Type Description value T | PromiseLike<T> Returns Type Description AsyncLazy<T> from(factory, args) Declaration static from<T, A extends any[]>(factory: (...args: A) => T | PromiseLike<T>, ...args: A): AsyncLazy<T>; Parameters Name Type Description factory (...args: A) => T | PromiseLike<T> args A Returns Type Description AsyncLazy<T>"
  },
  "api/async-autoresetevent/asyncautoresetevent.html": {
    "href": "api/async-autoresetevent/asyncautoresetevent.html",
    "title": "Class AsyncAutoResetEvent | @esfx API Reference",
    "keywords": "Class AsyncAutoResetEvent Represents a synchronization event that, when signaled, resets automatically after releasing a single waiting asynchronous operation. Classes Constructors constructor(initialState) Initializes a new instance of the AutoResetEvent class. Declaration constructor(initialState?: boolean); Parameters Name Type Description initialState boolean Classes Methods reset() Sets the state of the event to nonsignaled, causing asynchronous operations to pause. Declaration reset(): void; Returns Type Description void set() Sets the state of the event to signaled, resolving at most one waiting Promise. The event is then automatically reset. Declaration set(): boolean; Returns Type Description boolean true if the operation successfully resolved a waiting Promise; otherwise, false <!-- --> . wait(cancelable) Asynchronously waits for the event to become signaled. Declaration wait(cancelable?: Cancelable): Promise<void>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<void>"
  },
  "api/threading-lockable.html": {
    "href": "api/threading-lockable.html",
    "title": "Package @esfx/threading-lockable | @esfx API Reference",
    "keywords": "Package @esfx/threading-lockable A low-level Symbol-based API for defining locking semantics for thread synchronization primitives for Workers. Installation npm i @esfx/threading-lockable"
  },
  "api/threading-countdown.html": {
    "href": "api/threading-countdown.html",
    "title": "Package @esfx/threading-countdown | @esfx API Reference",
    "keywords": "Package @esfx/threading-countdown Provides the CountdownEvent class, a thread synchronization primitive for use with Workers. Overview Installation Usage Installation npm i @esfx/threading-countdown Usage TypeScript JavaScript (CommonJS) import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; import { CountdownEvent } from \"@esfx/threading-countdown\"; function worker_thread() { const countdown = new CountdownEvent(workerData); // do work in background... // signal worker is finished countdown.signal(); } function main() { const countdown = new CountdownEvent(5); // start 5 workers for (let i = 0; i < 5; i++) { new Worker(__filename, { workerData: countdown.buffer }); } // wait for the workers to finish countdown.wait(); } if (isMainThread) { main(); } else { worker_thread(); } const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const { CountdownEvent } = require(\"@esfx/threading-countdown\"); function worker_thread() { const countdown = new CountdownEvent(workerData); // do work in background... // signal worker is finished countdown.signal(); } function main() { const countdown = new CountdownEvent(5); // start 5 workers for (let i = 0; i < 5; i++) { new Worker(__filename, { workerData: countdown.buffer }); } // wait for the workers to finish countdown.wait(); } if (isMainThread) { main(); } else { worker_thread(); }"
  },
  "api/metadata-shim.html": {
    "href": "api/metadata-shim.html",
    "title": "Package @esfx/metadata-shim | @esfx API Reference",
    "keywords": "Package @esfx/metadata-shim Provides a global shim that adds minimal @esfx/metadata functionality to the Reflect global object. This provides partial compatibility with TypeScript's --emitDecoratorMetadata flag. Overview Installation Usage Installation npm i @esfx/metadata-shim Usage TypeScript import \"@esfx/metadata-shim\"; import { getMemberMetadata } from \"@esfx/metadata\"; // TypeScript compiled with --emitDecoratorMetadata class MyClass { @someDecorator method(x: number): string { return \"\"; } } const c = new MyClass(); getMemberMetadata(c, \"method\", \"design:returntype\"); // String getMemberMetadata(c, \"method\", \"design:paramtypes\"); // [Number]"
  },
  "api/lazy.html": {
    "href": "api/lazy.html",
    "title": "Package @esfx/lazy | @esfx API Reference",
    "keywords": "Package @esfx/lazy Provides a class to simplify lazy-initialization logic. Overview Installation Usage Installation npm i @esfx/lazy Usage TypeScript JavaScript (CommonJS) import { Lazy } from \"@esfx/lazy\"; // lazy initialize an object const lazy1 = new Lazy(() => new SomeObject()); lazy1.hasValue; // false lazy1.value; // SomeObject {} lazy1.hasValue; // true // lazy initialize with arguments const lazy2 = Lazy.from((a, b) => a + b, 1, 2); lazy2.hasValue; // false lazy2.value; // 3 lazy2.hasValue; // true // initialized \"lazy\" const lazy3 = Lazy.for(\"test\"); lazy3.hasValue; // true lazy3.value; // \"test\" const { Lazy } = require(\"@esfx/lazy\"); // lazy initialize an object const lazy1 = new Lazy(() => new SomeObject()); lazy1.hasValue; // false lazy1.value; // SomeObject {} lazy1.hasValue; // true // lazy initialize with arguments const lazy2 = Lazy.from((a, b) => a + b, 1, 2); lazy2.hasValue; // false lazy2.value; // 3 lazy2.hasValue; // true // initialized \"lazy\" const lazy3 = Lazy.for(\"test\"); lazy3.hasValue; // true lazy3.value; // \"test\""
  },
  "api/decorators-stage1-core.html": {
    "href": "api/decorators-stage1-core.html",
    "title": "Package @esfx/decorators-stage1-core | @esfx API Reference",
    "keywords": "Package @esfx/decorators-stage1-core Provides a low-level API for working with ECMAScript Stage 1 Decorators. Overview Installation Usage Installation npm i @esfx/decorators-stage1-core Usage TypeScript Functions createClassDescriptor(target) Declaration export declare function createClassDescriptor<T extends Function = Function>(target: T): ClassDescriptor<T>; Parameters Name Type Description target T Returns Type Description ClassDescriptor<T> createDecorator(decorator) Declaration export declare function createDecorator<S extends DecoratorSignature<[]>>(decorator: S): MappedDecoratorSignature<S>; Parameters Name Type Description decorator S Returns Type Description MappedDecoratorSignature<S> createDecoratorFactory(decorator) Declaration export declare function createDecoratorFactory<S extends DecoratorSignature>(decorator: S): MappedDecoratorFactorySignature<S>; Parameters Name Type Description decorator S Returns Type Description MappedDecoratorFactorySignature<S> createDecoratorOrDecoratorFactory(decorator) Declaration export declare function createDecoratorOrDecoratorFactory<S extends DecoratorSignature>(decorator: S): MappedDecoratorOrDecoratorFactorySignature<S>; Parameters Name Type Description decorator S Returns Type Description MappedDecoratorOrDecoratorFactorySignature<S> createMemberDescriptor(target, propertyKey, descriptor) Declaration export declare function createMemberDescriptor<T = any>(target: object, propertyKey: PropertyKey, descriptor?: TypedPropertyDescriptor<T>): MemberDescriptor<T>; Parameters Name Type Description target object propertyKey PropertyKey descriptor TypedPropertyDescriptor<T> Returns Type Description MemberDescriptor<T> createParameterDescriptor(target, propertyKey, parameterIndex) Declaration export declare function createParameterDescriptor(target: object, propertyKey: PropertyKey, parameterIndex: number): ParameterDescriptor; Parameters Name Type Description target object propertyKey PropertyKey parameterIndex number Returns Type Description ParameterDescriptor decorate(decorators, target) Declaration export declare function decorate(decorators: ((target: Function) => Function | void)[], target: Function): Function; Parameters Name Type Description decorators ((target: Function) => Function | void)[] target Function Returns Type Description Function decorate(decorators, target, propertyKey, descriptor) Declaration export declare function decorate(decorators: ((target: object, propertyKey: PropertyKey, descriptor?: PropertyDescriptor) => PropertyDescriptor | void)[], target: object, propertyKey: PropertyKey, descriptor?: PropertyDescriptor): PropertyDescriptor | void; Parameters Name Type Description decorators ((target: object, propertyKey: PropertyKey, descriptor?: PropertyDescriptor) => PropertyDescriptor | void)[] target object propertyKey PropertyKey descriptor PropertyDescriptor Returns Type Description PropertyDescriptor | void decorateClass(decorators, target) Declaration export declare function decorateClass(decorators: ((target: Function) => Function | void)[], target: Function): Function; Parameters Name Type Description decorators ((target: Function) => Function | void)[] target Function Returns Type Description Function decorateMember(decorators, target, propertyKey, descriptor) Declaration export declare function decorateMember(decorators: ((target: object, propertyKey: PropertyKey, descriptor?: PropertyDescriptor) => PropertyDescriptor | void)[], target: object, propertyKey: PropertyKey, descriptor?: PropertyDescriptor): PropertyDescriptor | void; Parameters Name Type Description decorators ((target: object, propertyKey: PropertyKey, descriptor?: PropertyDescriptor) => PropertyDescriptor | void)[] target object propertyKey PropertyKey descriptor PropertyDescriptor Returns Type Description PropertyDescriptor | void getDecoratorInfoFromArguments(args) Declaration export declare function getDecoratorInfoFromArguments(args: ClassDecoratorArguments): ClassDescriptor; Parameters Name Type Description args ClassDecoratorArguments Returns Type Description ClassDescriptor getDecoratorInfoFromArguments(args) Declaration export declare function getDecoratorInfoFromArguments(args: MemberDecoratorArguments): MemberDescriptor; Parameters Name Type Description args MemberDecoratorArguments Returns Type Description MemberDescriptor getDecoratorInfoFromArguments(args) Declaration export declare function getDecoratorInfoFromArguments(args: ParameterDecoratorArguments): ParameterDescriptor; Parameters Name Type Description args ParameterDecoratorArguments Returns Type Description ParameterDescriptor getDecoratorInfoFromArguments(args) Declaration export declare function getDecoratorInfoFromArguments(args: DecoratorArguments): DecoratorDescriptor; Parameters Name Type Description args DecoratorArguments Returns Type Description DecoratorDescriptor getDecoratorInfoFromArguments(args) Declaration export declare function getDecoratorInfoFromArguments(args: DecoratorArguments | IArguments): DecoratorDescriptor | undefined; Parameters Name Type Description args DecoratorArguments | IArguments Returns Type Description DecoratorDescriptor | undefined isAccessor(value) Declaration export declare function isAccessor(value: DecoratorDescriptor): value is AccessorMemberDescriptor; Parameters Name Type Description value DecoratorDescriptor Returns Type Description value is AccessorMemberDescriptor isClass(value) Declaration export declare function isClass(value: DecoratorDescriptor): value is ClassDescriptor; Parameters Name Type Description value DecoratorDescriptor Returns Type Description value is ClassDescriptor isClassDecoratorArguments(args) Declaration export declare function isClassDecoratorArguments(args: DecoratorArguments | IArguments | unknown[]): args is ClassDecoratorArguments; Parameters Name Type Description args DecoratorArguments | IArguments | unknown[] Returns Type Description args is ClassDecoratorArguments isDecoratorArguments(args) Declaration export declare function isDecoratorArguments(args: DecoratorArguments | IArguments | unknown[]): args is DecoratorArguments; Parameters Name Type Description args DecoratorArguments | IArguments | unknown[] Returns Type Description args is DecoratorArguments isField(value) Declaration export declare function isField(value: DecoratorDescriptor): value is FieldMemberDescriptor; Parameters Name Type Description value DecoratorDescriptor Returns Type Description value is FieldMemberDescriptor isMember(value) Declaration export declare function isMember(value: DecoratorDescriptor): value is MemberDescriptor; Parameters Name Type Description value DecoratorDescriptor Returns Type Description value is MemberDescriptor isMemberDecoratorArguments(args) Declaration export declare function isMemberDecoratorArguments(args: DecoratorArguments | IArguments | unknown[]): args is MemberDecoratorArguments; Parameters Name Type Description args DecoratorArguments | IArguments | unknown[] Returns Type Description args is MemberDecoratorArguments isMethod(value) Declaration export declare function isMethod(value: DecoratorDescriptor): value is MethodMemberDescriptor; Parameters Name Type Description value DecoratorDescriptor Returns Type Description value is MethodMemberDescriptor isNonStatic(value) Declaration export declare function isNonStatic(value: MemberDescriptor | ParameterDescriptor): boolean; Parameters Name Type Description value MemberDescriptor | ParameterDescriptor Returns Type Description boolean isParameter(value) Declaration export declare function isParameter(value: DecoratorDescriptor): value is ParameterDescriptor; Parameters Name Type Description value DecoratorDescriptor Returns Type Description value is ParameterDescriptor isParameterDecoratorArguments(args) Declaration export declare function isParameterDecoratorArguments(args: DecoratorArguments | IArguments | unknown[]): args is ParameterDecoratorArguments; Parameters Name Type Description args DecoratorArguments | IArguments | unknown[] Returns Type Description args is ParameterDecoratorArguments isStatic(value) Declaration export declare function isStatic(value: MemberDescriptor | ParameterDescriptor): boolean; Parameters Name Type Description value MemberDescriptor | ParameterDescriptor Returns Type Description boolean"
  },
  "api/async-readerwriterlock.html": {
    "href": "api/async-readerwriterlock.html",
    "title": "Package @esfx/async-readerwriterlock | @esfx API Reference",
    "keywords": "Package @esfx/async-readerwriterlock The @esfx/async-readerwriterlock package provides the AsyncReaderWriterLock class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-readerwriterlock Usage TypeScript JavaScript (CommonJS) import { AsyncReaderWriterLock } from \"@esfx/async-readerwriterlock\"; interface User { id: string, name: string, email: string } // 'rwlock' protects access to 'userCache' and data stored on disk const rwlock = new AsyncReaderWriterLock(); const userCache = new Map<string, User>(); async function getUser(id: string) { // get read access const lk = await rwlock.read(); try { let user = userCache.get(id); if (!user) { user = await readUserFromDisk(id); userCache.set(id, user); } return user; } finally { // release read access lk.unlock(); } } async function addUser(user: User) { // get write access const lk = await rwlock.write(); try { userCache.set(user.id, user); await writeUserToDisk(user.id, user); } finally { // release write access lk.unlock(); } } async function updateUser(id: string, oldData: User, newData: User) { // get upgradeable read access const lk = await rwlock.upgradeableRead(); try { // verify that we are ok to make changes... let user = userCache.get(id); if (!user || user.name === oldData.name && user.email === oldData.email) { // looks safe, so upgrade to a write lock const updlk = await lk.upgrade(); try { if (!user) { user = { id } as User; userCache.set(id, user); } user.name = newData.name; user.email = newData.email; await writeUserToDisk(user.id, user); } finally { updlk.unlock(); // release the write lock } } } finally { lk.unlock(); // release the read lock } } const { AsyncReaderWriterLock } = require(\"@esfx/async-readerwriterlock\"); // 'rwlock' protects access to 'userCache' and data stored on disk const rwlock = new AsyncReaderWriterLock(); const userCache = new Map(); async function getUser(id) { // get read access const lk = await rwlock.read(); try { let user = userCache.get(id); if (!user) { user = await readUserFromDisk(id); userCache.set(id, user); } return user; } finally { // release read access lk.unlock(); } } async function addUser(user) { // get write access const lk = await rwlock.write(); try { userCache.set(user.id, user); await writeUserToDisk(user.id, user); } finally { // release write access lk.unlock(); } } async function updateUser(id, oldData, newData) { // get upgradeable read access const lk = await rwlock.upgradeableRead(); try { // verify that we are ok to make changes... let user = userCache.get(id); if (!user || user.name === oldData.name && user.email === oldData.email) { // looks safe, so upgrade to a write lock const updlk = await lk.upgrade(); try { if (!user) { user = { id }; userCache.set(id, user); } user.name = newData.name; user.email = newData.email; await writeUserToDisk(user.id, user); } finally { updlk.unlock(); // release the write lock } } } finally { lk.unlock(); // release the read lock } }"
  },
  "api/async-lockable.html": {
    "href": "api/async-lockable.html",
    "title": "Package @esfx/async-lockable | @esfx API Reference",
    "keywords": "Package @esfx/async-lockable A low-level Symbol-based common API for async coordination primitives. Overview Installation Installation npm i @esfx/async-lockable"
  },
  "api/async-deferred.html": {
    "href": "api/async-deferred.html",
    "title": "Package @esfx/async-deferred | @esfx API Reference",
    "keywords": "Package @esfx/async-deferred The @esfx/async-deferred package provides the Deferred class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-deferred Usage TypeScript JavaScript (CommonJS) import { Deferred } from \"@esfx/async-deferred\"; const deferred = new Deferred<number>(); // to resolve the deferred: deferred.resolve(1); // to reject the deferred: deferred.reject(new Error()); // get the promise for the deferred: deferred.promise; const { Deferred } = require(\"@esfx/async-deferred\"); const deferred = new Deferred(); // to resolve the deferred: deferred.resolve(1); // to reject the deferred: deferred.reject(new Error()); // get the promise for the deferred: deferred.promise;"
  },
  "api/async-countdown.html": {
    "href": "api/async-countdown.html",
    "title": "Package @esfx/async-countdown | @esfx API Reference",
    "keywords": "Package @esfx/async-countdown The @esfx/async-countdown package provides the AsyncCountdownEvent class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-countdown Usage TypeScript JavaScript (CommonJS) import { AsyncCountdownEvent } from \"@esfx/cancelable\"; async function main() { // create an AsyncCountdownEvent with 4 participants const countdown = new AsyncCountdownEvent(4); const worker = async () => { // dome some work async... // signal completion countdown.signal(); } // start 4 workers worker(); worker(); worker(); worker(); // wait for all 4 workers to signal completion... await countdown.wait(); } main().catch(e => console.error(e)); const { AsyncCountdownEvent } = require(\"@esfx/cancelable\"); async function main() { // create an AsyncCountdownEvent with 4 participants const countdown = new AsyncCountdownEvent(4); const worker = async () => { // dome some work async... // signal completion countdown.signal(); } // start 4 workers worker(); worker(); worker(); worker(); // wait for all 4 workers to signal completion... await countdown.wait(); } main().catch(e => console.error(e));"
  },
  "api/collections-hashmap/hashmap.html": {
    "href": "api/collections-hashmap/hashmap.html",
    "title": "Class HashMap | @esfx API Reference",
    "keywords": "Class HashMap Classes Constructors constructor(equaler) Constructs a new instance of the HashMap class Declaration constructor(equaler?: Equaler<K>); Parameters Name Type Description equaler Equaler<K> constructor(iterable, equaler) Constructs a new instance of the HashMap class Declaration constructor(iterable?: Iterable<[K, V]>, equaler?: Equaler<K>); Parameters Name Type Description iterable Iterable<[K, V]> equaler Equaler<K> constructor(capacity, equaler) Constructs a new instance of the HashMap class Declaration constructor(capacity: number, equaler?: Equaler<K>); Parameters Name Type Description capacity number equaler Equaler<K> Classes Properties __@toStringTag Declaration [Symbol.toStringTag]: string; Property Value Type Description string [KeyedCollection.size] Declaration readonly [KeyedCollection.size]: number; Property Value Type Description number equaler Declaration readonly equaler: Equaler<K>; Property Value Type Description Equaler<K> size Declaration readonly size: number; Property Value Type Description number Classes Methods __@iterator() Declaration [Symbol.iterator](): IterableIterator<[K, V]>; Returns Type Description IterableIterator<[K, V]> [KeyedCollection.has](key) Declaration [KeyedCollection.has](key: K): boolean; Parameters Name Type Description key K Returns Type Description boolean clear() Declaration clear(): void; Returns Type Description void delete(key) Declaration delete(key: K): boolean; Parameters Name Type Description key K Returns Type Description boolean ensureCapacity(capacity) Declaration ensureCapacity(capacity: number): number | undefined; Parameters Name Type Description capacity number Returns Type Description number | undefined entries() Declaration entries(): IterableIterator<[K, V]>; Returns Type Description IterableIterator<[K, V]> forEach(callback, thisArg) Declaration forEach(callback: (value: V, key: K, map: this) => void, thisArg?: any): void; Parameters Name Type Description callback (value: V, key: K, map: this) => void thisArg any Returns Type Description void get(key) Declaration get(key: K): V | undefined; Parameters Name Type Description key K Returns Type Description V | undefined has(key) Declaration has(key: K): boolean; Parameters Name Type Description key K Returns Type Description boolean keys() Declaration keys(): IterableIterator<K>; Returns Type Description IterableIterator<K> set(key, value) Declaration set(key: K, value: V): this; Parameters Name Type Description key K value V Returns Type Description this trimExcess(capacity) Declaration trimExcess(capacity?: number): void; Parameters Name Type Description capacity number Returns Type Description void values() Declaration values(): IterableIterator<V>; Returns Type Description IterableIterator<V>"
  },
  "api/collection-core/readonlykeyedcollection_namespace.html": {
    "href": "api/collection-core/readonlykeyedcollection_namespace.html",
    "title": "Namespace ReadonlyKeyedCollection | @esfx API Reference",
    "keywords": "Namespace ReadonlyKeyedCollection Functions isReadonlyKeyedCollection(value) Tests whether a value supports the minimal representation of a ReadonlyKeyedCollection <!-- --> . Declaration function isReadonlyKeyedCollection<K, V>(value: Iterable<[K, V]>): value is ReadonlyKeyedCollection<K, V>; Parameters Name Type Description value Iterable<[K, V]> Returns Type Description value is ReadonlyKeyedCollection<K, V> isReadonlyKeyedCollection(value) Tests whether a value supports the minimal representation of a ReadonlyKeyedCollection <!-- --> . Declaration function isReadonlyKeyedCollection(value: unknown): value is ReadonlyKeyedCollection<unknown, unknown>; Parameters Name Type Description value unknown Returns Type Description value is ReadonlyKeyedCollection<unknown, unknown>"
  },
  "api/collection-core/readonlykeyedcollection_interface.html": {
    "href": "api/collection-core/readonlykeyedcollection_interface.html",
    "title": "Interface ReadonlyKeyedCollection | @esfx API Reference",
    "keywords": "Interface ReadonlyKeyedCollection Interfaces Properties [ReadonlyKeyedCollection.size] Gets the number of elements in the collection. Declaration readonly [ReadonlyKeyedCollection.size]: number; Property Value Type Description number Interfaces Methods [ReadonlyKeyedCollection.has](key) Tests whether a key is present in the collection. Declaration [ReadonlyKeyedCollection.has](key: K): boolean; Parameters Name Type Description key K Returns Type Description boolean"
  },
  "api/collection-core/readonlyindexedcollection_namespace.html": {
    "href": "api/collection-core/readonlyindexedcollection_namespace.html",
    "title": "Namespace ReadonlyIndexedCollection | @esfx API Reference",
    "keywords": "Namespace ReadonlyIndexedCollection Functions isReadonlyIndexedCollection(value) Tests whether a value supports the minimal representation of a ReadonlyIndexedCollection <!-- --> . Declaration function isReadonlyIndexedCollection<T>(value: Iterable<T>): value is ReadonlyIndexedCollection<T>; Parameters Name Type Description value Iterable<T> Returns Type Description value is ReadonlyIndexedCollection<T> isReadonlyIndexedCollection(value) Tests whether a value supports the minimal representation of a ReadonlyIndexedCollection <!-- --> . Declaration function isReadonlyIndexedCollection(value: unknown): value is ReadonlyIndexedCollection<unknown>; Parameters Name Type Description value unknown Returns Type Description value is ReadonlyIndexedCollection<unknown>"
  },
  "api/async-manualresetevent.html": {
    "href": "api/async-manualresetevent.html",
    "title": "Package @esfx/async-manualresetevent | @esfx API Reference",
    "keywords": "Package @esfx/async-manualresetevent The @esfx/async-manualresetevent package provides the AsyncManualResetEvent class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-manualresetevent Usage TypeScript JavaScript (CommonJS) import { AsyncManualResetEvent } from \"@esfx/async-manualresetevent\"; const event = new AsyncManualResetEvent(); async function doSomeActivity() { // do some work asynchronously... // signal completion of the activity event.set(); } async function doSomeOtherActivity() { // do some work asynchronously... // wait for 'doSomeActivity' to finish await event.wait(); // keep working now that both activities have synchronized... } // start some work doSomeActivity(); // start some other work doSomeOtherActivity(); const { AsyncManualResetEvent } = require(\"@esfx/async-manualresetevent\"); const event = new AsyncManualResetEvent(); async function doSomeActivity() { // do some work asynchronously... // signal completion of the activity event.set(); } async function doSomeOtherActivity() { // do some work asynchronously... // wait for 'doSomeActivity' to finish await event.wait(); // keep working now that both activities have synchronized... } // start some work doSomeActivity(); // start some other work doSomeOtherActivity();"
  },
  "api/async-delay.html": {
    "href": "api/async-delay.html",
    "title": "Package @esfx/async-delay | @esfx API Reference",
    "keywords": "Package @esfx/async-delay The @esfx/async-delay package provides the @\"async-delay.delay\" function. Overview Installation Usage Installation npm i @esfx/async-delay Usage TypeScript JavaScript (CommonJS) import { delay } from \"@esfx/async-delay\"; async function doSomeAction() { // wait 10 seconds await delay(10 * 1000); } const { delay } = require(\"@esfx/async-delay\"); async function doSomeAction() { // wait 10 seconds await delay(10 * 1000); } Functions delay(msec) Waits the specified number of milliseconds before resolving. Declaration export declare function delay(msec: number): Promise<void>; Parameters Name Type Description msec number Returns Type Description Promise<void> delay(msec, value) Waits the specified number of milliseconds before resolving with the provided value. Declaration export declare function delay<T>(msec: number, value: T | PromiseLike<T>): Promise<T>; Parameters Name Type Description msec number value T | PromiseLike<T> Returns Type Description Promise<T> delay(cancelable, msec) Waits the specified number of milliseconds before resolving. Declaration export declare function delay(cancelable: Cancelable, msec: number): Promise<void>; Parameters Name Type Description cancelable Cancelable msec number Returns Type Description Promise<void> delay(cancelable, msec, value) Waits the specified number of milliseconds before resolving with the provided value. Declaration export declare function delay<T>(cancelable: Cancelable, msec: number, value: T | PromiseLike<T>): Promise<T>; Parameters Name Type Description cancelable Cancelable msec number value T | PromiseLike<T> Returns Type Description Promise<T>"
  },
  "api/async-conditionvariable.html": {
    "href": "api/async-conditionvariable.html",
    "title": "Package @esfx/async-conditionvariable | @esfx API Reference",
    "keywords": "Package @esfx/async-conditionvariable Provides AsyncConditionVariable , an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-conditionvariable Usage TypeScript JavaScript (CommonJS) import { AsyncConditionVariable } from \"@esfx/async-conditionvariable\"; import { AsyncMutex } from \"@esfx/async-mutex\"; // create a mutex used to lock a resource const m = new AsyncMutex(); // create a condition variable to maintain a list of waiters for a resource const cv = new AsyncConditionVariable(); let tasks = getTasksToPerform(); // get some array of tasks to perform. let ready = false; let currentTask!: () => Promise<number>; let taskResult!: number; async function worker() { // pause worker until we can acquire a lock on 'm'. const lk = await m.lock(); try { // pause execution and release the lock on 'm' until we are ready. await cv.wait(lk, () => ready); while (ready) { // pause execution and release the lock on 'm' until we are notified await cv.wait(lk); // We should now have the lock again for 'm', so do more work... taskResult = await currentTask(); } } finally { lk.unlock(); } } async function main() { const pWorker = worker(); // start the worker let task; // get the next task to perform while (task = tasks.shift()) { // pause main until we can acquire a lock on 'm'. let lk = await m.lock(); try { currentTask = task; } finally { lk.unlock(); } cv.notifyOne(); // pause main until we can acquire a lock on 'm'. lk = await m.lock(); try { // we should now have the lock again for 'm', so process the result... console.log(taskResult); } finally { lk.unlock(); } } } main().catch(e => console.error(e)); const { AsyncConditionVariable } = require(\"@esfx/async-conditionvariable\"); const { AsyncMutex } = require(\"@esfx/async-mutex\"); // create a mutex used to lock a resource const m = new AsyncMutex(); // create a condition variable to maintain a list of waiters for a resource const cv = new AsyncConditionVariable(); let tasks = getTasksToPerform(); // get some array of tasks to perform. let ready = false; let currentTask; let taskResult; async function worker() { // pause worker until we can acquire a lock on 'm'. const lk = await m.lock(); try { // pause execution and release the lock on 'm' until we are ready. await cv.wait(lk, () => ready); while (ready) { // pause execution and release the lock on 'm' until we are notified await cv.wait(lk); // We should now have the lock again for 'm', so do more work... taskResult = await currentTask(); } } finally { lk.unlock(); } } async function main() { const pWorker = worker(); // start the worker let task; // get the next task to perform while (task = tasks.shift()) { // pause main until we can acquire a lock on 'm'. let lk = await m.lock(); try { currentTask = task; } finally { lk.unlock(); } cv.notifyOne(); // pause main until we can acquire a lock on 'm'. lk = await m.lock(); try { // we should now have the lock again for 'm', so process the result... console.log(taskResult); } finally { lk.unlock(); } } } main().catch(e => console.error(e));"
  },
  "api/type-model.html": {
    "href": "api/type-model.html",
    "title": "Package @esfx/type-model | @esfx API Reference",
    "keywords": "Package @esfx/type-model Provides a number of utility types for TypeScript. Installation npm i @esfx/type-model"
  },
  "api/async-waitqueue/waitqueue.html": {
    "href": "api/async-waitqueue/waitqueue.html",
    "title": "Class WaitQueue | @esfx API Reference",
    "keywords": "Class WaitQueue An async coordination primitive that provides a queue of Promises. Classes Properties size Gets the number of pending entries in the queue. Declaration readonly size: number; Property Value Type Description number Classes Methods cancelAll() Rejects all pending wait() operations with a CancelError <!-- --> . Declaration cancelAll(): number; Returns Type Description number The number of pending wait() operations that were rejected. cancelOne() Rejects the next pending wait() operation with a CancelError <!-- --> . Declaration cancelOne(): boolean; Returns Type Description boolean true if a pending wait() operation was rejected; otherwise, false <!-- --> . rejectAll(reason) Rejects all pending wait() operations with the provided reason. Declaration rejectAll(reason: unknown): number; Parameters Name Type Description reason unknown Returns Type Description number The number of pending wait() operations that were rejected. rejectOne(reason) Rejects the next pending wait() operation with the provided reason. Declaration rejectOne(reason: unknown): boolean; Parameters Name Type Description reason unknown Returns Type Description boolean true if a pending wait() operation was rejected; otherwise, false <!-- --> . resolveAll(this) Resolves all pending wait() operations with the provided value. Declaration resolveAll(this: WaitQueue<void>): number; Parameters Name Type Description this WaitQueue<void> Returns Type Description number The number of pending wait() operations that were resolved. resolveAll(value) Resolves all pending wait() operations with the provided value. Declaration resolveAll(value: T | PromiseLike<T>): number; Parameters Name Type Description value T | PromiseLike<T> Returns Type Description number The number of pending wait() operations that were resolved. resolveOne(this) Resolves a pending wait() operation with the provided value. Declaration resolveOne(this: WaitQueue<void>): boolean; Parameters Name Type Description this WaitQueue<void> Returns Type Description boolean true if a pending wait() operation was resolved; otherwise, false <!-- --> . resolveOne(value) Resolves a pending wait() operation with the provided value. Declaration resolveOne(value: T | PromiseLike<T>): boolean; Parameters Name Type Description value T | PromiseLike<T> Returns Type Description boolean true if a pending wait() operation was resolved; otherwise, false <!-- --> . wait(cancelable) Returns a Promise for the next value to be added to the queue. Declaration wait(cancelable?: Cancelable): Promise<T>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<T>"
  },
  "api/async-stack/asyncstack.html": {
    "href": "api/async-stack/asyncstack.html",
    "title": "Class AsyncStack | @esfx API Reference",
    "keywords": "Class AsyncStack An asynchronous Stack. Classes Constructors constructor(iterable) Initializes a new instance of the AsyncStack class. Declaration constructor(iterable?: Iterable<T | PromiseLike<T>>); Parameters Name Type Description iterable Iterable<T | PromiseLike<T>> Classes Properties done Gets a value indicating whether the stack has ended and there are no more items available. Declaration readonly done: boolean; Property Value Type Description boolean readable Gets a value indicating whether items can be read from the stack. Declaration readonly readable: boolean; Property Value Type Description boolean size Gets the number of entries in the stack. When positive, indicates the number of entries available to get. When negative, indicates the number of requests waiting to be fulfilled. Declaration readonly size: number; Property Value Type Description number writable Gets a value indicating whether new items can be added to the stack. Declaration readonly writable: boolean; Property Value Type Description boolean Classes Methods doneReading() Blocks attempts to read from the stack until it is empty. Available items in the stack can still be read until the stack is empty. Declaration doneReading(): void; Returns Type Description void doneWriting() Blocks attempts to write to the stack. Pending requests in the stack can still be resolved until the stack is empty. Declaration doneWriting(): void; Returns Type Description void end() Blocks future attempts to read or write from the stack. Available items in the stack can still be read until the stack is empty. Pending reads from the stack are rejected with a CancelError <!-- --> . Declaration end(): void; Returns Type Description void pop(cancelable) Removes and returns a Promise for the top value of the stack. If the stack is empty, returns a Promise for the next value to be pushed on to the stack. Declaration pop(cancelable?: Cancelable): Promise<T>; Parameters Name Type Description cancelable Cancelable Returns Type Description Promise<T> push(this) Adds a value to the top of the stack. If the stack is empty but has a pending pop request, the value will be popped and the request fulfilled. Declaration push(this: AsyncStack<void>): void; Parameters Name Type Description this AsyncStack<void> Returns Type Description void push(value) Adds a value to the top of the stack. If the stack is empty but has a pending pop request, the value will be popped and the request fulfilled. Declaration push(value: T | PromiseLike<T>): void; Parameters Name Type Description value T | PromiseLike<T> Returns Type Description void"
  },
  "api/equatable.html": {
    "href": "api/equatable.html",
    "title": "Package @esfx/equatable | @esfx API Reference",
    "keywords": "Package @esfx/equatable Provides a low level API for defining equality. Overview Installation Usage Installation npm i @esfx/equatable Usage TypeScript JavaScript (CommonJS) import { Equatable, Equaler, Comparable, Comparer } from \"@esfx/equatable\"; class Person { firstName: string; lastName: string; constructor(firstName: string, lastName: string) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other: unknown) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other: unknown) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const people = [ new Person(\"Alice\", \"Johnson\") new Person(\"Bob\", \"Clark\"), ]; people.sort(Comparer.defaultComparer.compare); console.log(people); // Bob Clark,Alice Johnson const obj1 = new Person(\"Bob\", \"Clark\"); const obj2 = new Person(\"Bob\", \"Clark\"); obj1 === obj2; // false Equaler.defaultEqualer.equals(obj1, obj2); // true const { Equatable, Equaler, Comparable, Comparer } = require(\"@esfx/equatable\"); class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const people = [ new Person(\"Alice\", \"Johnson\") new Person(\"Bob\", \"Clark\"), ]; people.sort(Comparer.defaultComparer.compare); console.log(people); // Bob Clark,Alice Johnson const obj1 = new Person(\"Bob\", \"Clark\"); const obj2 = new Person(\"Bob\", \"Clark\"); obj1 === obj2; // false Equaler.defaultEqualer.equals(obj1, obj2); // true"
  },
  "api/async-waitqueue.html": {
    "href": "api/async-waitqueue.html",
    "title": "Package @esfx/async-waitqueue | @esfx API Reference",
    "keywords": "Package @esfx/async-waitqueue The @esfx/async-waitqueue package provides the WaitQueue class, an async coordination primitive used to queue and resolve promises. Overview Installation Usage Installation npm i @esfx/async-waitqueue Usage TypeScript JavaScript (CommonJS) import { WaitQueue } from \"@esfx/async-waitqueue\"; async function main() { const queue = new WaitQueue<number>(); // Create two pending \"waiters\" in the queue const p1 = queue.wait(); const p2 = queue.wait(); // Resolve the two pending \"waiters\" in the queue queue.resolveOne(1); queue.resolveOne(Promise.resolve(2)); await p1; // 1 await p2; // 2 } const { WaitQueue } = require(\"@esfx/async-waitqueue\"); async function main() { const queue = new WaitQueue(); // Create two pending \"waiters\" in the queue const p1 = queue.wait(); const p2 = queue.wait(); // Resolve the two pending \"waiters\" in the queue queue.resolveOne(1); queue.resolveOne(Promise.resolve(2)); await p1; // 1 await p2; // 2 }"
  },
  "api/async-autoresetevent.html": {
    "href": "api/async-autoresetevent.html",
    "title": "Package @esfx/async-autoresetevent | @esfx API Reference",
    "keywords": "Package @esfx/async-autoresetevent The @esfx/async-autoresetevent package provides the AsyncAutoResetEvent class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-autoresetevent Usage TypeScript JavaScript (CommonJS) import { AsyncAutoResetEvent } from \"@esfx/async-autoresetevent\"; const event = new AsyncAutoResetEvent(); async function doSomeActivity() { while (true) { // do some work asynchronously... // indicate 'waitForActivity' can resume. Event is immediately reset to // the signaled state. event.set(); } } async function waitForActivity() { while (true) { // wait for 'doSomeActivity' to set the event... await event.wait(); // do something asynchronous... } } doSomeActivity(); waitForActivity(); const { AsyncAutoResetEvent } = require(\"@esfx/async-autoresetevent\"); const event = new AsyncAutoResetEvent(); async function doSomeActivity() { while (true) { // do some work asynchronously... // indicate 'waitForActivity' can resume. Event is immediately reset to // the signaled state. event.set(); } } async function waitForActivity() { while (true) { // wait for 'doSomeActivity' to set the event... await event.wait(); // do something asynchronous... } } doSomeActivity(); waitForActivity();"
  },
  "api/ref.html": {
    "href": "api/ref.html",
    "title": "Package @esfx/ref | @esfx API Reference",
    "keywords": "Package @esfx/ref Provides a low-level API for defining forward references. Note This implementation is an approximation of the Reference behavior from https://github.com/rbuckton/proposal-refs . Overview Installation Usage Installation npm i @esfx/ref Usage Note Examples adapted from https://github.com/rbuckton/proposal-refs#examples where applicable. Take a reference to a variable TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; let x = 1; const r = ref(() => x, _ => x = _); print(r.value); // 1 r.value = 2; print(x); // 2 const { ref } = require(\"@esfx/ref\"); let x = 1; const r = ref(() => x, _ => x = _); print(r.value); // 1 r.value = 2; print(x); // 2 Take a reference to a property TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; let o = { x: 1 }; const r = ref.at(o, \"x\"); print(r.value); // 1 r.value = 2; print(o); // { x: 2 } const { ref } = require(\"@esfx/ref\"); let o = { x: 1 }; const r = ref.at(o, \"x\"); print(r.value); // 1 r.value = 2; print(o); // { x: 2 } Take a reference to an element TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; let ar = [1]; const r = ref.at(ar, 0); print(r.value); // 1 r.value = 2; print(ar); // [2] const { ref } = require(\"@esfx/ref\"); let ar = [1]; const r = ref.at(ar, 0); print(r.value); // 1 r.value = 2; print(ar); // [2] Reference passing TypeScript JavaScript (CommonJS) import { ref, Reference } from \"@esfx/ref\"; function update(ref_r: Reference<number>) { ref_r.value = 2; } let x = 1; update(ref(() => x, _ => x = _)); print(x); // 2 const { ref } = require(\"@esfx/ref\"); function update(ref_r) { ref_r.value = 2; } let x = 1; update(ref(() => x, _ => x = _)); print(x); // 2 Referencing a local declaration creates a closure TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; function f() { let x = 1; return [ref(() => x, _ => x = _), () => print(x)] as const; } const [r, p] = f(); p(); // 1 r.value = 2; p(); // 2 const { ref } = require(\"@esfx/ref\"); function f() { let x = 1; return [ref(() => x, _ => x = _), () => print(x)]; } const [r, p] = f(); p(); // 1 r.value = 2; p(); // 2 More complex reference passing TypeScript JavaScript (CommonJS) import { ref, Reference } from \"@esfx/ref\"; function max(ref_first: Reference<number>, ref_second: Reference<number>, ref_third: Reference<number>) { const ref_max = ref_first.value > ref_second.value ? ref_first : ref_second; return ref_max.value > ref_third.value ? ref_max : ref_third; } let x = 1, y = 2, z = 3; const ref_x = ref(() => x, _ => x = _); const ref_y = ref(() => y, _ => y = _); const ref_z = ref(() => z, _ => z = _); const ref_w = max(ref_x, ref_y, ref_z); ref_w.value = 4; print(x); // 1 print(y); // 2 print(z); // 4 const { ref } = require(\"@esfx/ref\"); function max(ref_first, ref_second, ref_third) { const ref_max = ref_first.value > ref_second.value ? ref_first : ref_second; return ref_max.value > ref_third.value ? ref_max : ref_third; } let x = 1, y = 2, z = 3; const ref_x = ref(() => x, _ => x = _); const ref_y = ref(() => y, _ => y = _); const ref_z = ref(() => z, _ => z = _); const ref_w = max(ref_x, ref_y, ref_z); ref_w.value = 4; print(x); // 1 print(y); // 2 print(z); // 4 Forward reference to a var TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; const ref_a = ref(() => a, _ => a = _); ref_a.value = 1; // ok, no error as `a` is a var. var a: number; const { ref } = require(\"@esfx/ref\"); const ref_a = ref(() => a, _ => a = _); ref_a.value = 1; // ok, no error as `a` is a var. var a; Forward reference to a block-scoped variable TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; let a: number; const ref_a = ref(() => a, _ => a = _); ref_a.value = 1; // ok, no error as `a` has been declared. const ref_b = ref(() => b, _ => b = _); ref_b.value = 1; // error as `b` has not yet been declared. let b: number; const { ref } = require(\"@esfx/ref\"); let a; const ref_a = ref(() => a, _ => a = _); ref_a.value = 1; // ok, no error as `a` has been declared. const ref_b = ref(() => b, _ => b = _); ref_b.value = 1; // error as `b` has not yet been declared. let b; Forward reference to a member of a block-scoped variable TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; const ref_x = ref.at(b, \"x\"); // error, `b` has not yet been declared let b = { x: 1 }; const { ref } = require(\"@esfx/ref\"); const ref_x = ref.at(b, \"x\"); // error, `b` has not yet been declared let b = { x: 1 }; Forward references for decorators TypeScript import { ref, Reference } from \"@esfx/ref\"; import { metadata } from \"@esfx/metadata\"; const Type = (ref_type: Reference<Function>) => metadata(\"design:type\", ref_type); class Node { @Type(ref(() => Container)) get parent() { /*...*/ } @Type(ref(() => Node)) get nextSibling() { /*...*/ } } class Container extends Node { @Type(ref(() => Node)) get firstChild() { /*...*/ } } Side effects TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; let count = 0; let e = [0, 1, 2]; const ref_e = ref.at(e, count++); // `count++` is evaluated when Reference is taken. print(ref_e.value); // 0 print(ref_e.value); // 0 print(count); // 1 const { ref } = require(\"@esfx/ref\"); let count = 0; let e = [0, 1, 2]; const ref_e = ref.at(e, count++); // `count++` is evaluated when Reference is taken. print(ref_e.value); // 0 print(ref_e.value); // 0 print(count); // 1 Functions ref(get, set) Create a reference to a value in the current lexical scope. Declaration export declare function ref<T>(get: () => T, set?: (value: T) => void): Reference<T>; Parameters Name Type Description get () => T set (value: T) => void Returns Type Description Reference<T>"
  },
  "api/metadata.html": {
    "href": "api/metadata.html",
    "title": "Package @esfx/metadata | @esfx API Reference",
    "keywords": "Package @esfx/metadata Provides an API for defining metadata about an object. Overview Installation Usage Installation npm i @esfx/metadata Usage TypeScript JavaScript (CommonJS) import { Metadata, getClassMetadata, getMemberMetadata, getParameterMetadata } from \"@esfx/metadata\"; const Service = name => Metadata(\"Service\", name); const ReturnType = type => Metadata(\"ReturnType\", type); const Type = type => Metadata(\"Type\", type); @Service(\"MyService\") class MyClass { @ReturnType(\"string\") method(@Type(\"number\") x: number) { return \"hi\"; } } const c = new MyClass(); getClassMetadata(MyClass, \"Service\"); // \"MyService\" getMemberMetadata(c, \"method\", \"ReturnType\"); // \"string\" getParameterMetadata(c, \"method\", 0, \"Type\"); // \"number\" const { defineClassMetadata, defineMemberMetadata, defineParameterMetadata, getClassMetadata, getMemberMetadata, getParameterMetadata } = require(\"@esfx/metadata\"); class MyClass { method(x) { return \"hi\"; } } defineClassMetadata(MyClass, \"Service\", \"MyService\"); defineMemberMetadata(MyClass.prototype, \"method\", \"ReturnType\", \"string\"); defineParameterMetadata(MyClass.prototype, \"method\", 0, \"Type\", \"number\"); const c = new MyClass(); getClassMetadata(MyClass, \"Service\"); // \"MyService\" getMemberMetadata(c, \"method\", \"ReturnType\"); // \"string\" getParameterMetadata(c, \"method\", 0, \"Type\"); // \"number\" Functions defineObjectMetadata(target, metadataKey, metadataValue) Define metadata on an object. Declaration export declare function defineObjectMetadata(target: object, metadataKey: MetadataKey, metadataValue: unknown): void; Parameters Name Type Description target object metadataKey MetadataKey metadataValue unknown Returns Type Description void defineParameterMetadata(target, propertyKey, parameterIndex, metadataKey, metadataValue) Define metadata on a parameter of a method of an object. Declaration export declare function defineParameterMetadata(target: object, propertyKey: PropertyKey, parameterIndex: number, metadataKey: MetadataKey, metadataValue: unknown): void; Parameters Name Type Description target object propertyKey PropertyKey parameterIndex number metadataKey MetadataKey metadataValue unknown Returns Type Description void definePropertyMetadata(target, propertyKey, metadataKey, metadataValue) Define metadata for a property of an object. The property does not have to exist. Declaration export declare function definePropertyMetadata(target: object, propertyKey: PropertyKey, metadataKey: MetadataKey, metadataValue: unknown): void; Parameters Name Type Description target object propertyKey PropertyKey metadataKey MetadataKey metadataValue unknown Returns Type Description void deleteObjectMetadata(target, metadataKey) Deletes an own metadata key from an object. Declaration export declare function deleteObjectMetadata(target: object, metadataKey: MetadataKey): boolean; Parameters Name Type Description target object metadataKey MetadataKey Returns Type Description boolean deleteParameterMetadata(target, propertyKey, parameterIndex, metadataKey) Deletes an own metadata key from a parameter of a method of an object. Declaration export declare function deleteParameterMetadata(target: object, propertyKey: PropertyKey, parameterIndex: number, metadataKey: MetadataKey): boolean; Parameters Name Type Description target object propertyKey PropertyKey parameterIndex number metadataKey MetadataKey Returns Type Description boolean deletePropertyMetadata(target, propertyKey, metadataKey) Deletes an own metadata key from a property of an object. Declaration export declare function deletePropertyMetadata(target: object, propertyKey: PropertyKey, metadataKey: MetadataKey): boolean; Parameters Name Type Description target object propertyKey PropertyKey metadataKey MetadataKey Returns Type Description boolean getMetadataParameterLength(target, propertyKey) Gets the maximum known length of a method of an object or its prototypes from its parameters that have metadata metadata. Declaration export declare function getMetadataParameterLength(target: object, propertyKey: PropertyKey): number; Parameters Name Type Description target object propertyKey PropertyKey Returns Type Description number getMetadataProperties(target) Gets the property names for an object or its prototypes for which there is metadata defined. Declaration export declare function getMetadataProperties(target: object): (string | symbol)[]; Parameters Name Type Description target object Returns Type Description (string | symbol)[] getObjectMetadata(target, metadataKey) Gets the metadata value for a metadata key on an object or its prototypes. Declaration export declare function getObjectMetadata(target: object, metadataKey: MetadataKey): unknown; Parameters Name Type Description target object metadataKey MetadataKey Returns Type Description unknown getObjectMetadataKeys(target) Gets the metadata keys defined on an object or its prototypes. Declaration export declare function getObjectMetadataKeys(target: object): MetadataKey[]; Parameters Name Type Description target object Returns Type Description MetadataKey[] getOwnMetadataParameterLength(target, propertyKey) Gets the maximum known length of a method of an object from its parameters that have metadata metadata. Declaration export declare function getOwnMetadataParameterLength(target: object, propertyKey: PropertyKey): number; Parameters Name Type Description target object propertyKey PropertyKey Returns Type Description number getOwnMetadataProperties(target) Gets the own property names for an object for which there is metadata defined. Declaration export declare function getOwnMetadataProperties(target: object): (string | symbol)[]; Parameters Name Type Description target object Returns Type Description (string | symbol)[] getOwnObjectMetadata(target, metadataKey) Gets the metadata value for an own metadata key on an object. Declaration export declare function getOwnObjectMetadata(target: object, metadataKey: MetadataKey): unknown; Parameters Name Type Description target object metadataKey MetadataKey Returns Type Description unknown getOwnObjectMetadataKeys(target) Gets the own metadata keys defined on an object. Declaration export declare function getOwnObjectMetadataKeys(target: object): MetadataKey[]; Parameters Name Type Description target object Returns Type Description MetadataKey[] getOwnParameterMetadata(target, propertyKey, parameterIndex, metadataKey) Gets the metadata value for an own metadata key on a parameter of a method of an object. Declaration export declare function getOwnParameterMetadata(target: object, propertyKey: PropertyKey, parameterIndex: number, metadataKey: MetadataKey): unknown; Parameters Name Type Description target object propertyKey PropertyKey parameterIndex number metadataKey MetadataKey Returns Type Description unknown getOwnParameterMetadataKeys(target, propertyKey, parameterIndex) Gets the own metadata keys defined on a parameter of a method of an object. Declaration export declare function getOwnParameterMetadataKeys(target: object, propertyKey: PropertyKey, parameterIndex: number): MetadataKey[]; Parameters Name Type Description target object propertyKey PropertyKey parameterIndex number Returns Type Description MetadataKey[] getOwnPropertyMetadata(target, propertyKey, metadataKey) Gets the metadata value for an own metadata key on a property of an object. Declaration export declare function getOwnPropertyMetadata(target: object, propertyKey: PropertyKey, metadataKey: MetadataKey): unknown; Parameters Name Type Description target object propertyKey PropertyKey metadataKey MetadataKey Returns Type Description unknown getOwnPropertyMetadataKeys(target, propertyKey) Gets the own metadata keys defined on a property of an object. Declaration export declare function getOwnPropertyMetadataKeys(target: object, propertyKey: PropertyKey): MetadataKey[]; Parameters Name Type Description target object propertyKey PropertyKey Returns Type Description MetadataKey[] getParameterMetadata(target, propertyKey, parameterIndex, metadataKey) Gets the metadata value for a metadata key on a parameter of a method of an object or its prototypes. Declaration export declare function getParameterMetadata(target: object, propertyKey: PropertyKey, parameterIndex: number, metadataKey: MetadataKey): unknown; Parameters Name Type Description target object propertyKey PropertyKey parameterIndex number metadataKey MetadataKey Returns Type Description unknown getParameterMetadataKeys(target, propertyKey, parameterIndex) Gets the metadata keys defined on a parameter of a method of an object or its prototypes. Declaration export declare function getParameterMetadataKeys(target: object, propertyKey: PropertyKey, parameterIndex: number): MetadataKey[]; Parameters Name Type Description target object propertyKey PropertyKey parameterIndex number Returns Type Description MetadataKey[] getPropertyMetadata(target, propertyKey, metadataKey) Gets the metadata value for a metadata key on a property of an object or its prototypes. Declaration export declare function getPropertyMetadata(target: object, propertyKey: PropertyKey, metadataKey: MetadataKey): unknown; Parameters Name Type Description target object propertyKey PropertyKey metadataKey MetadataKey Returns Type Description unknown getPropertyMetadataKeys(target, propertyKey) Gets the metadata keys defined on a property of an object or its prototypes. Declaration export declare function getPropertyMetadataKeys(target: object, propertyKey: PropertyKey): MetadataKey[]; Parameters Name Type Description target object propertyKey PropertyKey Returns Type Description MetadataKey[] hasObjectMetadata(target, metadataKey) Tests whether an object or its prototypes have metadata for the provided key. Declaration export declare function hasObjectMetadata(target: object, metadataKey: MetadataKey): boolean; Parameters Name Type Description target object metadataKey MetadataKey Returns Type Description boolean hasOwnObjectMetadata(target, metadataKey) Tests whether an object has own metadata for the provided key. Declaration export declare function hasOwnObjectMetadata(target: object, metadataKey: MetadataKey): boolean; Parameters Name Type Description target object metadataKey MetadataKey Returns Type Description boolean hasOwnParameterMetadata(target, propertyKey, parameterIndex, metadataKey) Tests whether a parameter of a method of an object has own metadata for the provided key. Declaration export declare function hasOwnParameterMetadata(target: object, propertyKey: PropertyKey, parameterIndex: number, metadataKey: MetadataKey): boolean; Parameters Name Type Description target object propertyKey PropertyKey parameterIndex number metadataKey MetadataKey Returns Type Description boolean hasOwnPropertyMetadata(target, propertyKey, metadataKey) Tests whether a property of an object has own metadata for the provided key. Declaration export declare function hasOwnPropertyMetadata(target: object, propertyKey: PropertyKey, metadataKey: MetadataKey): boolean; Parameters Name Type Description target object propertyKey PropertyKey metadataKey MetadataKey Returns Type Description boolean hasParameterMetadata(target, propertyKey, parameterIndex, metadataKey) Tests whether a parameter of a method of an object or its prototypes have metadata for the provided key. Declaration export declare function hasParameterMetadata(target: object, propertyKey: PropertyKey, parameterIndex: number, metadataKey: MetadataKey): boolean; Parameters Name Type Description target object propertyKey PropertyKey parameterIndex number metadataKey MetadataKey Returns Type Description boolean hasPropertyMetadata(target, propertyKey, metadataKey) Tests whether a property of an object or its prototypes have metadata for the provided key. Declaration export declare function hasPropertyMetadata(target: object, propertyKey: PropertyKey, metadataKey: MetadataKey): boolean; Parameters Name Type Description target object propertyKey PropertyKey metadataKey MetadataKey Returns Type Description boolean"
  },
  "api/indexed-object.html": {
    "href": "api/indexed-object.html",
    "title": "Package @esfx/indexed-object | @esfx API Reference",
    "keywords": "Package @esfx/indexed-object Provides a base class for custom integer-indexed collections. The underlying implementation uses a Proxy to trap integer indexes in a fashion similar to the Integer-Indexed Exotic Object in the ECMAScript specification. Overview Installation Usage Installation npm i @esfx/indexed-object Usage TypeScript JavaScript (CommonJS) import { IntegerIndexedObject } from \"indexed-object\"; class BooleansCollection extends IntegerIndexedObject<boolean> { protected getLength() { return 2; } protected getIndex(index: number) { switch (index) { case 0: return false; case 1: return true; default: return undefined; } } // hasIndex(index): boolean // setIndex(index, value): boolean // deleteIndex(index): boolean } const booleans = new BooleansCollection(); console.log(booleans[0]); // false console.log(booleans[1]); // true const { IntegerIndexedObject } = require(\"indexed-object\"); class BooleansCollection extends IntegerIndexedObject { /** @protected */ getLength() { return 2; } /** @protected */ getIndex(index) { switch (index) { case 0: return false; case 1: return true; default: return undefined; } } // hasIndex(index): boolean // setIndex(index, value): boolean // deleteIndex(index): boolean } const booleans = new BooleansCollection(); console.log(booleans[0]); // false console.log(booleans[1]); // true"
  },
  "api/decorators.html": {
    "href": "api/decorators.html",
    "title": "Package @esfx/decorators | @esfx API Reference",
    "keywords": "Package @esfx/decorators Provides a number of frequently used decorators. Overview Installation Usage Installation npm i @esfx/decorators Usage TypeScript"
  },
  "api/collections-linkedlist.html": {
    "href": "api/collections-linkedlist.html",
    "title": "Package @esfx/collections-linkedlist | @esfx API Reference",
    "keywords": "Package @esfx/collections-linkedlist Provides the LinkedList class, a linked-list implementation that utilizes @esfx/collection-core and @esfx/equatable . Overview Installation Usage Installation npm i @esfx/collections-linkedlist Usage TypeScript JavaScript (CommonJS) import { LinkedList, LinkedListNode } from \"equatable/collections-linkedlist\"; const list = new LinkedList<string>(); const n1: LinkedListNode<string> = list.push(\"first\"); const n2: LinkedListNode<string> = list.push(\"second\"); n2.value = \"second updated\"; [...list]; // first,second updated const { LinkedList } = require(\"equatable/collections-linkedlist\"); const list = new LinkedList(); const n1 = list.push(\"first\"); const n2 = list.push(\"second\"); n2.value = \"second updated\"; [...list]; // first,second updated"
  },
  "api/collection-core-shim.html": {
    "href": "api/collection-core-shim.html",
    "title": "Package @esfx/collection-core-shim | @esfx API Reference",
    "keywords": "Package @esfx/collection-core-shim Provides a global shim to add default @esfx/collection-core behaviors to global objects. Overview Installation Usage Installation npm i @esfx/collection-core-shim Usage The global shim adds a default implementation the collection interfaces to the following global objects: Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.Collection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" @\"collection-core.IndexedCollection\" Uint8Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Uint8ClampedArray implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Uint16Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Uint32Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Int8Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Int16Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Int32Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Float32Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Float64Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" BigUint64Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" BigInt64Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Set implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.Collection\" Map implements: @\"collection-core.ReadonlyKeyedCollection\" @\"collection-core.KeyedCollection\" To install the global shim, import @esfx/collection-core-shim : TypeScript JavaScript (CommonJS) import \"@esfx/collection-core-shim\"; // triggers global-scope side effects import { Collection } from \"@esfx/collection-core\"; [1, 2, 3][Collection.size]; // 3 require(\"@esfx/collection-core-shim\"); // triggers global-scope side effects const { Collection } = require(\"@esfx/collection-core\"); [1, 2, 3][Collection.size]; // 3"
  },
  "api/cancelable-dom.html": {
    "href": "api/cancelable-dom.html",
    "title": "Package @esfx/cancelable-dom | @esfx API Reference",
    "keywords": "Package @esfx/cancelable-dom The @esfx/cancelable-dom package provides a DOM interop library for @esfx/cancelable . Overview Installation Usage Installation npm i @esfx/cancelable-dom Usage TypeScript JavaScript (CommonJS) import { Cancelable } from \"@esfx/cancelable\"; import { toAbortSignal } from \"@esfx/cancelable-dom\"; async function doSomeWork(cancelable: Cancelable) { await fetch(\"some/uri\", { signal: toAbortSignal(cancelable) }); } const { Cancelable } = require(\"@esfx/cancelable\"); const { toAbortSignal } = require(\"@esfx/cancelable-dom\"); async function doSomeWork(cancelable) { await fetch(\"some/uri\", { signal: toAbortSignal(cancelable) }); } Functions toAbortSignal(cancelable) Declaration export declare function toAbortSignal(cancelable: Cancelable): AbortSignal; Parameters Name Type Description cancelable Cancelable Returns Type Description AbortSignal"
  },
  "api/async-stack.html": {
    "href": "api/async-stack.html",
    "title": "Package @esfx/async-stack | @esfx API Reference",
    "keywords": "Package @esfx/async-stack The @esfx/async-stack package provides the AsyncStack class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-stack Usage TypeScript JavaScript (CommonJS) import { AsyncStack } from \"@esfx/async-stack\"; async function main() { const stack = new AsyncStack<number>(); // push two items on the stack stack.push(1); stack.push(Promise.resolve(2)); // take two items from the stack await stack.pop(); // 2 await stack.pop(); // 1 // take two more pending items from the stack const p3 = stack.get(); const p4 = stack.get(); // put two more items on the stack stack.put(3); stack.put(4); await p3; // 3 await p4; // 4 } const { AsyncStack } = require(\"@esfx/async-stack\"); async function main() { const stack = new AsyncStack(); // push two items on the stack stack.push(1); stack.push(Promise.resolve(2)); // take two items from the stack await stack.pop(); // 2 await stack.pop(); // 1 // take two more pending items from the stack const p3 = stack.get(); const p4 = stack.get(); // put two more items on the stack stack.put(3); stack.put(4); await p3; // 3 await p4; // 4 }"
  }
}