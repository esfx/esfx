{
  "index.html": {
    "href": "index.html",
    "title": "@esfx reference | @esfx API Reference",
    "keywords": "The @esfx suite of packages is designed to provide low-level interoperability between 3rd-party packages for a number of common operations. Packages The main packages in the @esfx suite include: @esfx/async - Provides a number of asynchronous coordination primitives from the following packages: @esfx/async-autoresetevent @esfx/async-barrier @esfx/async-canceltoken @esfx/async-conditionvariable @esfx/async-countdown @esfx/async-deferred @esfx/async-delay @esfx/async-lazy @esfx/async-lockable @esfx/async-manualresetevent @esfx/async-mutex @esfx/async-queue @esfx/async-readerwriterlock @esfx/async-semaphore @esfx/async-stack @esfx/async-waitqueue @esfx/cancelable - A low-level Symbol-based API for defining a common cancellation protocol. @esfx/collection-core - A low-level Symbol-based API for defining common collection behaviors. @esfx/collections - A common collections API composed of the following packages: @esfx/collections-hashmap @esfx/collections-hashset @esfx/collections-linkedlist @esfx/collections-sortedmap @esfx/collections-sortedset @esfx/disposable - A low-level Symbol-based API for defining explicit resource management. @esfx/equatable - A low-level Symbol-based API for defining equality. @esfx/events - A low-level API for defining events. @esfx/indexed-object - A base class for custom integer-indexed objects. @esfx/lazy - Provides a class to simplify lazy-initialization logic. @esfx/metadata - An API for defining metadata about an object. @esfx/ref - A low-level API for defining forward references. @esfx/threading - Thread synchronization primitives for use with Workers: @esfx/threading-autoresetevent @esfx/threading-conditionvariable @esfx/threading-countdown @esfx/threading-lockable @esfx/threading-manualresetevent @esfx/threading-mutex @esfx/threading-semaphore @esfx/threading-sleep @esfx/threading-spinwait @esfx/type-model - A number of useful types for TypeScript. Shims Shim packages augment built-in objects with functionality from the main packages. @esfx/cancelable-dom-shim @esfx/collection-core-shim @esfx/collection-core-dom-shim @esfx/equatable-shim @esfx/metadata-shim @esfx/reflect-metadata-compat Adapters Adapter packages provide functionality to simplify interoperability scenarios with different platforms: @esfx/cancelable-dom"
  },
  "api/async-barrier/asyncbarrier.html": {
    "href": "api/async-barrier/asyncbarrier.html",
    "title": "Class AsyncBarrier | @esfx API Reference",
    "keywords": "Class AsyncBarrier Enables multiple tasks to cooperatively work on an algorithm through multiple phases. Constructors constructor(participantCount, postPhaseAction) Initializes a new instance of the Barrier class. Declaration constructor(participantCount: number, postPhaseAction?: (barrier: AsyncBarrier) => void | PromiseLike<void>); Parameters participantCount number postPhaseAction ( barrier : AsyncBarrier ) => void | PromiseLike <void> Properties currentPhaseNumber Gets the number of the Barrier's current phase. Declaration readonly currentPhaseNumber: number; Property Value number participantCount Gets the total number of participants in the barrier. Declaration readonly participantCount: number; Property Value number remainingParticipants Gets the number of participants in the barrier that haven't yet signaled in the current phase. Declaration readonly remainingParticipants: number; Property Value number Methods add(participantCount) Notifies the Barrier there will be additional participants. Declaration add(participantCount?: number): void; Parameters participantCount number Returns void remove(participantCount) Notifies the Barrier there will be fewer participants. Declaration remove(participantCount?: number): void; Parameters participantCount number Returns void signalAndWait(cancelable) Signals that a participant has reached the barrier and waits for all other participants to reach the barrier. Declaration signalAndWait(cancelable?: Cancelable): Promise<void>; Parameters cancelable Cancelable Returns Promise <void>"
  },
  "api/async-autoresetevent/asyncautoresetevent.html": {
    "href": "api/async-autoresetevent/asyncautoresetevent.html",
    "title": "Class AsyncAutoResetEvent | @esfx API Reference",
    "keywords": "Class AsyncAutoResetEvent Represents a synchronization event that, when signaled, resets automatically after releasing a single waiting asynchronous operation. Constructors constructor(initialState) Initializes a new instance of the AutoResetEvent class. Declaration constructor(initialState?: boolean); Parameters initialState boolean Methods reset() Sets the state of the event to nonsignaled, causing asynchronous operations to pause. Declaration reset(): void; Returns void set() Sets the state of the event to signaled, resolving at most one waiting Promise. The event is then automatically reset. Declaration set(): boolean; Returns boolean true if the operation successfully resolved a waiting Promise; otherwise, false <!-- --> . wait(cancelable) Asynchronously waits for the event to become signaled. Declaration wait(cancelable?: Cancelable): Promise<void>; Parameters cancelable Cancelable Returns Promise <void>"
  },
  "api/threading-semaphore.html": {
    "href": "api/threading-semaphore.html",
    "title": "Package @esfx/threading-semaphore | @esfx API Reference",
    "keywords": "Package @esfx/threading-semaphore Provides the Semaphore class, a thread synchronization primitive for use with Workers. Overview Installation Usage Installation npm i @esfx/threading-semaphore Usage TypeScript JavaScript (CommonJS) import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; import { Semaphore } from \"@esfx/threading-semaphore\"; import { StructType, int32 } from \"@esfx/struct-type\"; import { sleep } from \"@esfx/threading-sleep\"; const SharedData = StructType([ { name: \"running\", type: int32 }, ] as const); function worker_thread() { const sem = new Semaphore(workerData[0]); while (true) { // wait until the thread can enter the semaphore sem.wait(); // do work inside the semaphore... // release this worker's spot sem.release(); // do work outside the semaphore... } } function main() { // create a semaphore that allows 5 workers to enter at once const sem = new Semaphore(5); // start 10 workers for (let i = 0; i < 10; i++) { new Worker(__filename, { workerData: [sem.buffer] }); } } if (isMainThread) { main(); } else { worker_thread(); } const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const { Semaphore } = require(\"@esfx/threading-semaphore\"); const { StructType, int32 } = require(\"@esfx/struct-type\"); const { sleep } = require(\"@esfx/threading-sleep\"); const SharedData = StructType([ { name: \"running\", type: int32 }, ]); function worker_thread() { const sem = new Semaphore(workerData[0]); while (true) { // wait until the thread can enter the semaphore sem.wait(); // do work inside the semaphore... // release this worker's spot sem.release(); // do work outside the semaphore... } } function main() { // create a semaphore that allows 5 workers to enter at once const sem = new Semaphore(5); // start 10 workers for (let i = 0; i < 10; i++) { new Worker(__filename, { workerData: [sem.buffer] }); } } if (isMainThread) { main(); } else { worker_thread(); }"
  },
  "api/threading-mutex.html": {
    "href": "api/threading-mutex.html",
    "title": "Package @esfx/threading-mutex | @esfx API Reference",
    "keywords": "Package @esfx/threading-mutex Provides the Mutex class which can be used to protect shared resources across Workers using a SharedArrayBuffer . Overview Installation Usage Installation npm i @esfx/threading-mutex Usage TypeScript JavaScript (CommonJS) import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; import { Mutex } from \"@esfx/threading-mutex\"; import { StructType, int32 } from \"@esfx/struct-type\"; import { sleep } from \"@esfx/threading-sleep\"; const SharedData = StructType([ { name: \"x\", type: int32 }, { name: \"y\", type: int32 }, ] as const); function worker_thread() { const m = new Mutex(workerData[0]); const data = new SharedData(workerData[1]); while (true) { sleep(250); m.lock(); try { // inside of the lock we can mutate 'data' without // main() seeing a partial update. data.x++; data.y--; } finally { m.unlock(); } } } function main() { const m = new Mutex(); const data = new SharedData(/*shared*/ true); const worker = new Worker(__filename, { workerData: [m.buffer, data.buffer] }); while (true) { sleep(500); m.lock(); try { // inside of the lock, we know that we can safely read // both 'x' and 'y' and the worker will not modify // either value until we unlock. console.log(`x: ${data.x}, y: ${data.y}`); } finally { m.unlock(); } } } if (isMainThread) { main(); } else { worker_thread(); } const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const { Mutex } = require(\"@esfx/threading-mutex\"); const { StructType, int32 } = require(\"@esfx/struct-type\"); const { sleep } = require(\"@esfx/threading-sleep\"); const SharedData = StructType([ { name: \"x\", type: int32 }, { name: \"y\", type: int32 }, ]); function worker_thread() { const m = new Mutex(workerData[0]); const data = new SharedData(workerData[1]); while (true) { sleep(250); m.lock(); try { // inside of the lock we can mutate 'data' without // main() seeing a partial update. data.x++; data.y--; } finally { m.unlock(); } } } function main() { const m = new Mutex(); const data = new SharedData(/*shared*/ true); const worker = new Worker(__filename, { workerData: [m.buffer, data.buffer] }); while (true) { sleep(500); m.lock(); try { // inside of the lock, we know that we can safely read // both 'x' and 'y' and the worker will not modify // either value until we unlock. console.log(`x: ${data.x}, y: ${data.y}`); } finally { m.unlock(); } } } if (isMainThread) { main(); } else { worker_thread(); }"
  },
  "api/struct-type.html": {
    "href": "api/struct-type.html",
    "title": "Package @esfx/struct-type | @esfx API Reference",
    "keywords": "Package @esfx/struct-type Define structured types using ArrayBuffer and SharedArrayBuffer . Overview Installation Usage Installation npm i @esfx/struct-type Usage Basic Usage TypeScript JavaScript (CommonJS) import { StructType, int32 } from \"@esfx/struct-type\"; // simple types const Point = StructType([ { name: \"x\", type: int32 }, { name: \"y\", type: int32 }, ] as const); // complex types const Line = StructType([ { name: \"from\", type: Point }, { name: \"to\", type: Point }, ] as const); // inherited types const Point3D = StructType(Point, [ { name: \"z\", type: int32 } ] as const); // create instances const p1 = new Point({ x: 1, y: 2 }); // by field name const p2 = new Point([3, 4]); // by field ordinal // copy contents const buffer = new ArrayBuffer(16); const l = new Line([p1, p2]); l.writeTo(buffer); // create from a buffer const l2 = new Line(buffer); // read from field names console.log(l1.from.x); // 1 console.log(l1.from.y); // 2 console.log(l1.to.x); // 3 console.log(l1.to.y); // 4 // read from field ordinals console.log(l1[0][0]); // 1 console.log(l1[0][1]); // 2 console.log(l1[1][0]); // 3 console.log(l1[1][1]); // 4 const { StructType, int32 } = require(\"@esfx/struct-type\"); // simple types const Point = StructType([ { name: \"x\", type: int32 }, { name: \"y\", type: int32 }, ]); // complex types const Line = StructType([ { name: \"from\", type: Point }, { name: \"to\", type: Point }, ]); // inherited types const Point3D = StructType(Point, [ { name: \"z\", type: int32 } ]); // create instances const p1 = new Point({ x: 1, y: 2 }); // by field name const p2 = new Point([3, 4]); // by field ordinal // copy contents const buffer = new ArrayBuffer(16); const l = new Line([p1, p2]); l.writeTo(buffer); // create from a buffer const l2 = new Line(buffer); // read from field names console.log(l1.from.x); // 1 console.log(l1.from.y); // 2 console.log(l1.to.x); // 3 console.log(l1.to.y); // 4 // read from field ordinals console.log(l1[0][0]); // 1 console.log(l1[0][1]); // 2 console.log(l1[1][0]); // 3 console.log(l1[1][1]); // 4 Using with Workers TypeScript JavaScript (CommonJS) import { StructType, int32 } from \"@esfx/struct-type\"; import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; const ThreadData = StructType([ { name: \"itemsRemaining\", type: int32 }, ] as const); function worker_thread() { // this is running in a background worker... const data = new ThreadData(workerData); // allocate struct using the SharedArrayBuffer while (data.itemsRemaining) { // do some work... data.itemsRemaining--; } parentPort.postMessage(\"done\"); } function main() { // this is running on the main thread... const data = new ThreadData(/*shared*/ true); // allocate struct using a SharedArrayBuffer data.itemsRemaining = 5; const worker = new Worker(__filename, { workerData: data.buffer }); worker.on(\"message\", message => { if (message === \"done\") { console.log(data.itemsRemaining); // 0 } }); } if (isMainThread) { main(); } else if (parentPort) { worker_thread(); } const { StructType, int32 } = require(\"@esfx/struct-type\"); const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const ThreadData = StructType([ { name: \"itemsRemaining\", type: int32 }, ]); function worker_thread() { // this is running in a background worker... const data = new ThreadData(workerData); // allocate struct using the SharedArrayBuffer while (data.itemsRemaining) { // do some work... data.itemsRemaining--; } parentPort.postMessage(\"done\"); } function main() { // this is running on the main thread... const data = new ThreadData(/*shared*/ true); // allocate struct using a SharedArrayBuffer data.itemsRemaining = 5; const worker = new Worker(__filename, { workerData: data.buffer }); worker.on(\"message\", message => { if (message === \"done\") { console.log(data.itemsRemaining); // 0 } }); } if (isMainThread) { main(); } else if (parentPort) { worker_thread(); } Type Aliases StructDefinition Declaration export declare type StructDefinition = readonly StructFieldDefinition[]; Type readonly StructFieldDefinition [] StructElements Declaration export declare type StructElements<TDef extends StructDefinition> = { [I in Extract<keyof TDef, number>]: StructFieldRuntimeType<TDef[I][\"type\"]>; }; Type { [ I in Extract <keyof TDef , number>]: StructFieldRuntimeType < TDef [ I ][\"type\"]>; } StructFieldRuntimeType Declaration export declare type StructFieldRuntimeType<T extends StructFieldType> = T extends StructPrimitiveType ? ReturnType<T> : T extends StructType ? InstanceType<T> : never; Type T extends StructPrimitiveType ? ReturnType < T > : T extends StructType ? InstanceType < T > : never StructFieldType Declaration export declare type StructFieldType = typeof int8 | typeof int16 | typeof int32 | typeof uint8 | typeof uint16 | typeof uint32 | typeof bigint64 | typeof biguint64 | typeof float32 | typeof float64 | StructType; Type typeof int8 | typeof int16 | typeof int32 | typeof uint8 | typeof uint16 | typeof uint32 | typeof bigint64 | typeof biguint64 | typeof float32 | typeof float64 | StructType StructInitElements Declaration export declare type StructInitElements<TDef extends StructDefinition> = { [I in keyof TDef]: TDef[I] extends StructFieldDefinition ? StructInitFieldType<TDef[I][\"type\"]> : never; }; Type { [ I in keyof TDef ]: TDef [ I ] extends StructFieldDefinition ? StructInitFieldType < TDef [ I ][\"type\"]> : never; } StructInitFieldType Declaration export declare type StructInitFieldType<T extends StructFieldType> = T extends StructPrimitiveType ? ReturnType<T> : T extends StructType<infer TDef> ? InstanceType<T> | StructInitProperties<TDef> | StructInitElements<TDef> : never; Type T extends StructPrimitiveType ? ReturnType < T > : T extends StructType <infer TDef > ? InstanceType < T > | StructInitProperties < TDef > | StructInitElements < TDef > : never StructInitProperties Declaration export declare type StructInitProperties<TDef extends StructDefinition> = { [P in TDef[number][\"name\"]]: StructInitFieldType<Extract<TDef[number], { readonly name: P; }>[\"type\"]>; }; Type { [ P in TDef [number][\"name\"]]: StructInitFieldType < Extract < TDef [number], { readonly name : P ; }>[\"type\"]>; } StructProperties Declaration export declare type StructProperties<TDef extends StructDefinition> = { [P in TDef[number][\"name\"]]: StructFieldRuntimeType<Extract<TDef[number], { readonly name: P; }>[\"type\"]>; }; Type { [ P in TDef [number][\"name\"]]: StructFieldRuntimeType < Extract < TDef [number], { readonly name : P ; }>[\"type\"]>; } TypedStruct Declaration export declare type TypedStruct<TDef extends StructDefinition> = Struct<TDef> & StructProperties<TDef> & StructElements<TDef>; Type Struct < TDef > & StructProperties < TDef > & StructElements < TDef > Variables bigint64 Declaration bigint64: StructPrimitiveType<\"bigint64\", bigint> Type StructPrimitiveType <\"bigint64\", bigint> biguint64 Declaration biguint64: StructPrimitiveType<\"biguint64\", bigint> Type StructPrimitiveType <\"biguint64\", bigint> float32 Declaration float32: StructPrimitiveType<\"float32\", number> Type StructPrimitiveType <\"float32\", number> float64 Declaration float64: StructPrimitiveType<\"float64\", number> Type StructPrimitiveType <\"float64\", number> int16 Declaration int16: StructPrimitiveType<\"int16\", number> Type StructPrimitiveType <\"int16\", number> int32 Declaration int32: StructPrimitiveType<\"int32\", number> Type StructPrimitiveType <\"int32\", number> int8 Declaration int8: StructPrimitiveType<\"int8\", number> Type StructPrimitiveType <\"int8\", number> StructType Declaration StructType: StructTypeConstructor Type StructTypeConstructor uint16 Declaration uint16: StructPrimitiveType<\"uint16\", number> Type StructPrimitiveType <\"uint16\", number> uint32 Declaration uint32: StructPrimitiveType<\"uint32\", number> Type StructPrimitiveType <\"uint32\", number> uint8 Declaration uint8: StructPrimitiveType<\"uint8\", number> Type StructPrimitiveType <\"uint8\", number>"
  },
  "api/reflect-metadata-compat.html": {
    "href": "api/reflect-metadata-compat.html",
    "title": "Package @esfx/reflect-metadata-compat | @esfx API Reference",
    "keywords": "Package @esfx/reflect-metadata-compat Provides a global shim that provides a drop-in replacement for reflect-metadata . Overview Installation Usage Installation npm i @esfx/reflect-metadata-compat Usage TypeScript import \"@esfx/reflect-metadata-compat\"; // TypeScript compiled with --emitDecoratorMetadata class MyClass { @someDecorator method(x: number): string { return \"\"; } } const c = new MyClass(); Reflect.getMetadata(\"design:returntype\", c, \"method\"); // String Reflect.getMetadata(\"design:paramtypes\", c, \"method\"); // [Number]"
  },
  "api/indexed-object.html": {
    "href": "api/indexed-object.html",
    "title": "Package @esfx/indexed-object | @esfx API Reference",
    "keywords": "Package @esfx/indexed-object Provides a base class for custom integer-indexed collections. The underlying implementation uses a Proxy to trap integer indexes in a fashion similar to the Integer-Indexed Exotic Object in the ECMAScript specification. Overview Installation Usage Installation npm i @esfx/indexed-object Usage TypeScript JavaScript (CommonJS) import { IntegerIndexedObject } from \"indexed-object\"; class BooleansCollection extends IntegerIndexedObject<boolean> { protected getLength() { return 2; } protected getIndex(index: number) { switch (index) { case 0: return false; case 1: return true; default: return undefined; } } // hasIndex(index): boolean // setIndex(index, value): boolean // deleteIndex(index): boolean } const booleans = new BooleansCollection(); console.log(booleans[0]); // false console.log(booleans[1]); // true const { IntegerIndexedObject } = require(\"indexed-object\"); class BooleansCollection extends IntegerIndexedObject { /** @protected */ getLength() { return 2; } /** @protected */ getIndex(index) { switch (index) { case 0: return false; case 1: return true; default: return undefined; } } // hasIndex(index): boolean // setIndex(index, value): boolean // deleteIndex(index): boolean } const booleans = new BooleansCollection(); console.log(booleans[0]); // false console.log(booleans[1]); // true"
  },
  "api/events.html": {
    "href": "api/events.html",
    "title": "Package @esfx/events | @esfx API Reference",
    "keywords": "Package @esfx/events Provides a low-level API for defining events. Overview Installation Usage Installation npm i @esfx/events Usage TypeScript JavaScript (CommonJS) import { Event } from \"@esfx/events\"; class MyService { private _loadedEvent = Event.create<(this: MyService) => void(this); readonly loadedEvent = this._loadedEvent.event; load() { ... this._loadedEvent.emit(); } } const svc = new MyService(); svc.loadedEvent.on(() => console.log(\"loaded\")); svc.load(); const { Event } = require(\"@esfx/events\"); class MyService { constructor() { this._loadedEvent = Event.create(this); this.loadedEvent = this._loadedEvent.event; } load() { ... this._loadedEvent.emit(); } } // Use const svc = new MyService(); svc.loadedEvent.on(() => console.log(\"loaded\")); svc.load(); Type Aliases EventListener Declaration export declare type EventListener<F extends (...args: any[]) => void> = (this: ThisParameterType<F>, ...args: Parameters<F>) => void; Type ( this : ThisParameterType < F >, ... args : Parameters < F >) => void"
  },
  "api/decorators-stage1-core.html": {
    "href": "api/decorators-stage1-core.html",
    "title": "Package @esfx/decorators-stage1-core | @esfx API Reference",
    "keywords": "Package @esfx/decorators-stage1-core Provides a low-level API for working with ECMAScript Stage 1 Decorators. Overview Installation Usage Installation npm i @esfx/decorators-stage1-core Usage TypeScript Functions createClassDescriptor(target) Declaration export declare function createClassDescriptor<T extends Function = Function>(target: T): ClassDescriptor<T>; Parameters target T Returns ClassDescriptor < T > createDecorator(decorator) Declaration export declare function createDecorator<S extends DecoratorSignature<[]>>(decorator: S): MappedDecoratorSignature<S>; Parameters decorator S Returns MappedDecoratorSignature < S > createDecoratorFactory(decorator) Declaration export declare function createDecoratorFactory<S extends DecoratorSignature>(decorator: S): MappedDecoratorFactorySignature<S>; Parameters decorator S Returns MappedDecoratorFactorySignature < S > createDecoratorOrDecoratorFactory(decorator) Declaration export declare function createDecoratorOrDecoratorFactory<S extends DecoratorSignature>(decorator: S): MappedDecoratorOrDecoratorFactorySignature<S>; Parameters decorator S Returns MappedDecoratorOrDecoratorFactorySignature < S > createMemberDescriptor(target, propertyKey, descriptor) Declaration export declare function createMemberDescriptor<T = any>(target: object, propertyKey: PropertyKey, descriptor?: TypedPropertyDescriptor<T>): MemberDescriptor<T>; Parameters target object propertyKey PropertyKey descriptor TypedPropertyDescriptor < T > Returns MemberDescriptor < T > createParameterDescriptor(target, propertyKey, parameterIndex) Declaration export declare function createParameterDescriptor(target: object, propertyKey: PropertyKey, parameterIndex: number): ParameterDescriptor; Parameters target object propertyKey PropertyKey parameterIndex number Returns ParameterDescriptor decorate(decorators, target) Declaration export declare function decorate(decorators: ((target: Function) => Function | void)[], target: Function): Function; Parameters decorators (( target : Function ) => Function | void)[] target Function Returns Function decorate(decorators, target, propertyKey, descriptor) Declaration export declare function decorate(decorators: ((target: object, propertyKey: PropertyKey, descriptor?: PropertyDescriptor) => PropertyDescriptor | void)[], target: object, propertyKey: PropertyKey, descriptor?: PropertyDescriptor): PropertyDescriptor | void; Parameters decorators (( target : object, propertyKey : PropertyKey , descriptor ?: PropertyDescriptor ) => PropertyDescriptor | void)[] target object propertyKey PropertyKey descriptor PropertyDescriptor Returns PropertyDescriptor | void decorateClass(decorators, target) Declaration export declare function decorateClass(decorators: ((target: Function) => Function | void)[], target: Function): Function; Parameters decorators (( target : Function ) => Function | void)[] target Function Returns Function decorateMember(decorators, target, propertyKey, descriptor) Declaration export declare function decorateMember(decorators: ((target: object, propertyKey: PropertyKey, descriptor?: PropertyDescriptor) => PropertyDescriptor | void)[], target: object, propertyKey: PropertyKey, descriptor?: PropertyDescriptor): PropertyDescriptor | void; Parameters decorators (( target : object, propertyKey : PropertyKey , descriptor ?: PropertyDescriptor ) => PropertyDescriptor | void)[] target object propertyKey PropertyKey descriptor PropertyDescriptor Returns PropertyDescriptor | void getDecoratorInfoFromArguments(args) Declaration export declare function getDecoratorInfoFromArguments(args: ClassDecoratorArguments): ClassDescriptor; Parameters args ClassDecoratorArguments Returns ClassDescriptor getDecoratorInfoFromArguments(args) Declaration export declare function getDecoratorInfoFromArguments(args: MemberDecoratorArguments): MemberDescriptor; Parameters args MemberDecoratorArguments Returns MemberDescriptor getDecoratorInfoFromArguments(args) Declaration export declare function getDecoratorInfoFromArguments(args: ParameterDecoratorArguments): ParameterDescriptor; Parameters args ParameterDecoratorArguments Returns ParameterDescriptor getDecoratorInfoFromArguments(args) Declaration export declare function getDecoratorInfoFromArguments(args: DecoratorArguments): DecoratorDescriptor; Parameters args DecoratorArguments Returns DecoratorDescriptor getDecoratorInfoFromArguments(args) Declaration export declare function getDecoratorInfoFromArguments(args: DecoratorArguments | IArguments): DecoratorDescriptor | undefined; Parameters args DecoratorArguments | IArguments Returns DecoratorDescriptor | undefined isAccessor(value) Declaration export declare function isAccessor(value: DecoratorDescriptor): value is AccessorMemberDescriptor; Parameters value DecoratorDescriptor Returns value is AccessorMemberDescriptor isClass(value) Declaration export declare function isClass(value: DecoratorDescriptor): value is ClassDescriptor; Parameters value DecoratorDescriptor Returns value is ClassDescriptor isClassDecoratorArguments(args) Declaration export declare function isClassDecoratorArguments(args: DecoratorArguments | IArguments | unknown[]): args is ClassDecoratorArguments; Parameters args DecoratorArguments | IArguments | unknown[] Returns args is ClassDecoratorArguments isDecoratorArguments(args) Declaration export declare function isDecoratorArguments(args: DecoratorArguments | IArguments | unknown[]): args is DecoratorArguments; Parameters args DecoratorArguments | IArguments | unknown[] Returns args is DecoratorArguments isField(value) Declaration export declare function isField(value: DecoratorDescriptor): value is FieldMemberDescriptor; Parameters value DecoratorDescriptor Returns value is FieldMemberDescriptor isMember(value) Declaration export declare function isMember(value: DecoratorDescriptor): value is MemberDescriptor; Parameters value DecoratorDescriptor Returns value is MemberDescriptor isMemberDecoratorArguments(args) Declaration export declare function isMemberDecoratorArguments(args: DecoratorArguments | IArguments | unknown[]): args is MemberDecoratorArguments; Parameters args DecoratorArguments | IArguments | unknown[] Returns args is MemberDecoratorArguments isMethod(value) Declaration export declare function isMethod(value: DecoratorDescriptor): value is MethodMemberDescriptor; Parameters value DecoratorDescriptor Returns value is MethodMemberDescriptor isNonStatic(value) Declaration export declare function isNonStatic(value: MemberDescriptor | ParameterDescriptor): boolean; Parameters value MemberDescriptor | ParameterDescriptor Returns boolean isParameter(value) Declaration export declare function isParameter(value: DecoratorDescriptor): value is ParameterDescriptor; Parameters value DecoratorDescriptor Returns value is ParameterDescriptor isParameterDecoratorArguments(args) Declaration export declare function isParameterDecoratorArguments(args: DecoratorArguments | IArguments | unknown[]): args is ParameterDecoratorArguments; Parameters args DecoratorArguments | IArguments | unknown[] Returns args is ParameterDecoratorArguments isStatic(value) Declaration export declare function isStatic(value: MemberDescriptor | ParameterDescriptor): boolean; Parameters value MemberDescriptor | ParameterDescriptor Returns boolean Type Aliases ClassDecoratorArguments Declaration export declare type ClassDecoratorArguments = Parameters<(target: Function) => void>; Type Parameters <( target : Function ) => void> DecoratorArguments Declaration export declare type DecoratorArguments = ClassDecoratorArguments | MemberDecoratorArguments | ParameterDecoratorArguments; Type ClassDecoratorArguments | MemberDecoratorArguments | ParameterDecoratorArguments DecoratorDescriptor Declaration export declare type DecoratorDescriptor = ClassDescriptor | MemberDescriptor | ParameterDescriptor; Type ClassDescriptor | MemberDescriptor | ParameterDescriptor MemberDecoratorArguments Declaration export declare type MemberDecoratorArguments = Parameters<(target: object, propertyKey: PropertyKey, descriptor?: PropertyDescriptor) => void>; Type Parameters <( target : object, propertyKey : PropertyKey , descriptor ?: PropertyDescriptor ) => void> ParameterDecoratorArguments Declaration export declare type ParameterDecoratorArguments = Parameters<(target: object, propertyKey: PropertyKey, parameterIndex: number) => void>; Type Parameters <( target : object, propertyKey : PropertyKey , parameterIndex : number) => void> Variables defaultAccessorAttributes Declaration defaultAccessorAttributes: Readonly<{ enumerable: boolean; configurable: boolean; }> Type Readonly <{ enumerable : boolean; configurable : boolean; }> defaultFieldAttributes Declaration defaultFieldAttributes: Readonly<{ enumerable: boolean; configurable: boolean; writable: boolean; }> Type Readonly <{ enumerable : boolean; configurable : boolean; writable : boolean; }> defaultMethodAttributes Declaration defaultMethodAttributes: Readonly<{ enumerable: boolean; configurable: boolean; writable: boolean; }> Type Readonly <{ enumerable : boolean; configurable : boolean; writable : boolean; }>"
  },
  "api/threading-spinwait/spinwait.html": {
    "href": "api/threading-spinwait/spinwait.html",
    "title": "Class SpinWait | @esfx API Reference",
    "keywords": "Class SpinWait Methods reset() Declaration reset(): void; Returns void spinOnce() Declaration spinOnce(): void; Returns void spinUntil(condition, ms) Declaration spinUntil(condition: () => boolean, ms?: number): boolean; Parameters condition () => boolean ms number Returns boolean"
  },
  "api/threading-manualresetevent/manualresetevent.html": {
    "href": "api/threading-manualresetevent/manualresetevent.html",
    "title": "Class ManualResetEvent | @esfx API Reference",
    "keywords": "Class ManualResetEvent Constructors constructor(initialState) Constructs a new instance of the ManualResetEvent class Declaration constructor(initialState?: boolean); Parameters initialState boolean constructor(buffer, byteOffset) Constructs a new instance of the ManualResetEvent class Declaration constructor(buffer: SharedArrayBuffer, byteOffset?: number); Parameters buffer SharedArrayBuffer byteOffset number Properties buffer Declaration readonly buffer: SharedArrayBuffer; Property Value SharedArrayBuffer byteLength Declaration readonly byteLength: number; Property Value number byteOffset Declaration readonly byteOffset: number; Property Value number isSet Declaration readonly isSet: boolean; Property Value boolean SIZE Declaration static readonly SIZE = 4; Methods [Disposable.dispose]() Declaration [Disposable.dispose](): void; Returns void close() Declaration close(): void; Returns void reset() Declaration reset(): boolean; Returns boolean set() Declaration set(): boolean; Returns boolean waitOne(ms) Declaration waitOne(ms?: number): boolean; Parameters ms number Returns boolean"
  },
  "api/threading-lockable/lockable_namespace.html": {
    "href": "api/threading-lockable/lockable_namespace.html",
    "title": "Namespace Lockable | @esfx API Reference",
    "keywords": "Namespace Lockable Variables lock Declaration lock: unique symbol Type unique symbol tryLock Declaration tryLock: unique symbol Type unique symbol unlock Declaration unlock: unique symbol Type unique symbol"
  },
  "api/threading-lockable/lockable_interface.html": {
    "href": "api/threading-lockable/lockable_interface.html",
    "title": "Interface Lockable | @esfx API Reference",
    "keywords": "Interface Lockable Methods [Lockable.lock](ms) Declaration [Lockable.lock](ms?: number): boolean; Parameters ms number Returns boolean [Lockable.tryLock]() Declaration [Lockable.tryLock]?(): boolean; Returns boolean [Lockable.unlock]() Declaration [Lockable.unlock](): boolean; Returns boolean"
  },
  "api/threading-countdown/countdownevent.html": {
    "href": "api/threading-countdown/countdownevent.html",
    "title": "Class CountdownEvent | @esfx API Reference",
    "keywords": "Class CountdownEvent Constructors constructor(initialCount) Constructs a new instance of the CountdownEvent class Declaration constructor(initialCount: number); Parameters initialCount number constructor(buffer, byteOffset) Constructs a new instance of the CountdownEvent class Declaration constructor(buffer: SharedArrayBuffer, byteOffset?: number); Parameters buffer SharedArrayBuffer byteOffset number Properties buffer Declaration readonly buffer: SharedArrayBuffer; Property Value SharedArrayBuffer byteLength Declaration readonly byteLength: number; Property Value number byteOffset Declaration readonly byteOffset: number; Property Value number initialCount Declaration readonly initialCount: number; Property Value number isSet Declaration readonly isSet: boolean; Property Value boolean remainingCount Declaration readonly remainingCount: number; Property Value number SIZE Declaration static readonly SIZE = 12; Methods [Disposable.dispose]() Declaration [Disposable.dispose](): void; Returns void add(count) Declaration add(count?: number): void; Parameters count number Returns void close() Declaration close(): void; Returns void reset(count) Declaration reset(count?: number): void; Parameters count number Returns void signal(count) Declaration signal(count?: number): boolean; Parameters count number Returns boolean tryAdd(count) Declaration tryAdd(count?: number): boolean; Parameters count number Returns boolean wait(ms) Declaration wait(ms?: number): boolean; Parameters ms number Returns boolean"
  },
  "api/struct-type/structtype_interface.html": {
    "href": "api/struct-type/structtype_interface.html",
    "title": "Interface StructType | @esfx API Reference",
    "keywords": "Interface StructType Properties [kFields] Declaration [kFields]: TDef; Property Value TDef SIZE Declaration readonly SIZE: number; Property Value number"
  },
  "api/collections-multimap/multimapoptions.html": {
    "href": "api/collections-multimap/multimapoptions.html",
    "title": "Interface MultiMapOptions | @esfx API Reference",
    "keywords": "Interface MultiMapOptions Properties keyEqualer Declaration keyEqualer?: Equaler<K>; Property Value Equaler < K > valueEqualer Declaration valueEqualer?: Equaler<V>; Property Value Equaler < V >"
  },
  "api/collections-multimap/multimap.html": {
    "href": "api/collections-multimap/multimap.html",
    "title": "Class MultiMap | @esfx API Reference",
    "keywords": "Class MultiMap Constructors constructor(options) Constructs a new instance of the MultiMap class Declaration constructor(options?: MultiMapOptions<K, V>); Parameters options MultiMapOptions < K , V > constructor(iterable, options) Constructs a new instance of the MultiMap class Declaration constructor(iterable?: Iterable<[K, V]>, options?: MultiMapOptions<K, V>); Parameters iterable Iterable <[ K , V ]> options MultiMapOptions < K , V > constructor(capacity, options) Constructs a new instance of the MultiMap class Declaration constructor(capacity: number, options?: MultiMapOptions<K, V>); Parameters capacity number options MultiMapOptions < K , V > Properties [ReadonlyKeyedMultiCollection.size] Declaration readonly [ReadonlyKeyedMultiCollection.size]: number; Property Value number [Symbol.toStringTag] Declaration [Symbol.toStringTag]: string; Property Value string keyEqualer Declaration readonly keyEqualer: Equaler<K>; Property Value Equaler < K > size Declaration readonly size: number; Property Value number valueEqualer Declaration readonly valueEqualer: Equaler<V>; Property Value Equaler < V > Methods [KeyedMultiCollection.add](key, value) Declaration [KeyedMultiCollection.add](key: K, value: V): void; Parameters key K value V Returns void [KeyedMultiCollection.clear]() Declaration [KeyedMultiCollection.clear](): void; Returns void [KeyedMultiCollection.delete](key) Declaration [KeyedMultiCollection.delete](key: K): number; Parameters key K Returns number [KeyedMultiCollection.deleteValue](key, value) Declaration [KeyedMultiCollection.deleteValue](key: K, value: V): boolean; Parameters key K value V Returns boolean [ReadonlyKeyedMultiCollection.get](key) Declaration [ReadonlyKeyedMultiCollection.get](key: K): ReadonlyHashSet<V> | undefined; Parameters key K Returns ReadonlyHashSet < V > | undefined [ReadonlyKeyedMultiCollection.has](key) Declaration [ReadonlyKeyedMultiCollection.has](key: K): boolean; Parameters key K Returns boolean [ReadonlyKeyedMultiCollection.hasValue](key, value) Declaration [ReadonlyKeyedMultiCollection.hasValue](key: K, value: V): boolean; Parameters key K value V Returns boolean [ReadonlyKeyedMultiCollection.keys]() Declaration [ReadonlyKeyedMultiCollection.keys](): IterableIterator<K>; Returns IterableIterator < K > [ReadonlyKeyedMultiCollection.values]() Declaration [ReadonlyKeyedMultiCollection.values](): IterableIterator<V>; Returns IterableIterator < V > [Symbol.iterator]() Declaration [Symbol.iterator](): IterableIterator<[K, V]>; Returns IterableIterator <[ K , V ]> add(key, value) Declaration add(key: K, value: V): this; Parameters key K value V Returns this clear() Declaration clear(): void; Returns void delete(key) Declaration delete(key: K): number; Parameters key K Returns number deleteValue(key, value) Declaration deleteValue(key: K, value: V): boolean; Parameters key K value V Returns boolean ensureCapacity(capacity) Declaration ensureCapacity(capacity: number): number; Parameters capacity number Returns number entries() Declaration entries(): IterableIterator<[K, V]>; Returns IterableIterator <[ K , V ]> forEach(callback, thisArg) Declaration forEach(callback: (value: V, key: K, map: this) => void, thisArg?: any): void; Parameters callback ( value : V , key : K , map : this) => void thisArg any Returns void get(key) Declaration get(key: K): ReadonlyHashSet<V> | undefined; Parameters key K Returns ReadonlyHashSet < V > | undefined has(key) Declaration has(key: K): boolean; Parameters key K Returns boolean hasValue(key, value) Declaration hasValue(key: K, value: V): boolean; Parameters key K value V Returns boolean keys() Declaration keys(): IterableIterator<K>; Returns IterableIterator < K > trimExcess(capacity) Declaration trimExcess(capacity?: number): void; Parameters capacity number Returns void values() Declaration values(): IterableIterator<V>; Returns IterableIterator < V >"
  },
  "api/collections-linkedlist/linkedlistnode.html": {
    "href": "api/collections-linkedlist/linkedlistnode.html",
    "title": "Class LinkedListNode | @esfx API Reference",
    "keywords": "Class LinkedListNode Constructors constructor(value) Constructs a new instance of the LinkedListNode class Declaration constructor(value: T); Parameters value T Properties [kList] Declaration [kList]: LinkedList<T> | undefined; Property Value LinkedList < T > | undefined [kNext] Declaration [kNext]: LinkedListNode<T> | undefined; Property Value LinkedListNode < T > | undefined [kPrevious] Declaration [kPrevious]: LinkedListNode<T> | undefined; Property Value LinkedListNode < T > | undefined [Symbol.toStringTag] Declaration [Symbol.toStringTag]: string; Property Value string list Declaration readonly list: LinkedList<T> | undefined; Property Value LinkedList < T > | undefined next Declaration readonly next: LinkedListNode<T> | undefined; Property Value LinkedListNode < T > | undefined previous Declaration readonly previous: LinkedListNode<T> | undefined; Property Value LinkedListNode < T > | undefined value Declaration value: T; Property Value T Methods detachSelf() Declaration detachSelf(): boolean; Returns boolean"
  },
  "api/collections-linkedlist/linkedlist.html": {
    "href": "api/collections-linkedlist/linkedlist.html",
    "title": "Class LinkedList | @esfx API Reference",
    "keywords": "Class LinkedList Constructors constructor(equaler) Constructs a new instance of the LinkedList class Declaration constructor(equaler?: EqualityComparison<T> | Equaler<T>); Parameters equaler EqualityComparison < T > | Equaler < T > constructor(iterable, equaler) Constructs a new instance of the LinkedList class Declaration constructor(iterable?: Iterable<T>, equaler?: EqualityComparison<T> | Equaler<T>); Parameters iterable Iterable < T > equaler EqualityComparison < T > | Equaler < T > Properties [ReadonlyCollection.size] Declaration readonly [ReadonlyCollection.size]: number; Property Value number [Symbol.toStringTag] Declaration [Symbol.toStringTag]: string; Property Value string equaler Declaration readonly equaler: Equaler<T>; Property Value Equaler < T > first Declaration readonly first: LinkedListNode<T> | undefined; Property Value LinkedListNode < T > | undefined last Declaration readonly last: LinkedListNode<T> | undefined; Property Value LinkedListNode < T > | undefined size Declaration readonly size: number; Property Value number Methods [Collection.add](value) Declaration [Collection.add](value: T): void; Parameters value T Returns void [Collection.clear]() Declaration [Collection.clear](): void; Returns void [Collection.delete](value) Declaration [Collection.delete](value: T): boolean; Parameters value T Returns boolean [ReadonlyCollection.has](value) Declaration [ReadonlyCollection.has](value: T): boolean; Parameters value T Returns boolean [Symbol.iterator]() Declaration [Symbol.iterator](): IterableIterator<T>; Returns IterableIterator < T > clear() Declaration clear(): void; Returns void delete(value) Declaration delete(value: T): LinkedListNode<T> | undefined; Parameters value T Returns LinkedListNode < T > | undefined deleteAll(predicate, thisArg) Declaration deleteAll(predicate: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): number; Parameters predicate ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => boolean thisArg any Returns number deleteNode(node) Declaration deleteNode(node: LinkedListNode<T> | null | undefined): boolean; Parameters node LinkedListNode < T > | null | undefined Returns boolean drain() Declaration drain(): IterableIterator<T>; Returns IterableIterator < T > every(callback, thisArg) Declaration every(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): boolean; Parameters callback ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => boolean thisArg any Returns boolean filter(callback, thisArg) Declaration filter<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): LinkedList<S>; Parameters callback ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => value is S thisArg any Returns LinkedList < S > filter(callback, thisArg) Declaration filter(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): LinkedList<T>; Parameters callback ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => boolean thisArg any Returns LinkedList < T > find(callback, thisArg) Declaration find<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): S | undefined; Parameters callback ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => value is S thisArg any Returns S | undefined find(callback, thisArg) Declaration find(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): T | undefined; Parameters callback ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => boolean thisArg any Returns T | undefined findLast(callback, thisArg) Declaration findLast<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): S | undefined; Parameters callback ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => value is S thisArg any Returns S | undefined findLast(callback, thisArg) Declaration findLast(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): T | undefined; Parameters callback ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => boolean thisArg any Returns T | undefined findLastNode(callback, thisArg) Declaration findLastNode<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): LinkedListNode<S> | undefined; Parameters callback ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => value is S thisArg any Returns LinkedListNode < S > | undefined findLastNode(callback, thisArg) Declaration findLastNode(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): LinkedListNode<T> | undefined; Parameters callback ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => boolean thisArg any Returns LinkedListNode < T > | undefined findNode(callback, thisArg) Declaration findNode<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): LinkedListNode<S> | undefined; Parameters callback ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => value is S thisArg any Returns LinkedListNode < S > | undefined findNode(callback, thisArg) Declaration findNode(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): LinkedListNode<T> | undefined; Parameters callback ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => boolean thisArg any Returns LinkedListNode < T > | undefined forEach(callback, thisArg) Declaration forEach(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => void, thisArg?: any): void; Parameters callback ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => void thisArg any Returns void has(value) Declaration has(value: T): boolean; Parameters value T Returns boolean insertAfter(node, value) Declaration insertAfter(node: LinkedListNode<T> | null | undefined, value: T): LinkedListNode<T>; Parameters node LinkedListNode < T > | null | undefined value T Returns LinkedListNode < T > insertBefore(node, value) Declaration insertBefore(node: LinkedListNode<T> | null | undefined, value: T): LinkedListNode<T>; Parameters node LinkedListNode < T > | null | undefined value T Returns LinkedListNode < T > insertNodeAfter(node, newNode) Declaration insertNodeAfter(node: LinkedListNode<T> | null | undefined, newNode: LinkedListNode<T>): void; Parameters node LinkedListNode < T > | null | undefined newNode LinkedListNode < T > Returns void insertNodeBefore(node, newNode) Declaration insertNodeBefore(node: LinkedListNode<T> | null | undefined, newNode: LinkedListNode<T>): void; Parameters node LinkedListNode < T > | null | undefined newNode LinkedListNode < T > Returns void lastNodeOf(value, fromNode) Declaration lastNodeOf(value: T, fromNode?: LinkedListNode<T>): LinkedListNode<T> | undefined; Parameters value T fromNode LinkedListNode < T > Returns LinkedListNode < T > | undefined map(callback, thisArg) Declaration map<U>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => U, thisArg?: any): LinkedList<U>; Parameters callback ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => U thisArg any Returns LinkedList < U > nodeOf(value, fromNode) Declaration nodeOf(value: T, fromNode?: LinkedListNode<T>): LinkedListNode<T> | undefined; Parameters value T fromNode LinkedListNode < T > Returns LinkedListNode < T > | undefined nodes() Declaration nodes(): IterableIterator<LinkedListNode<T>>; Returns IterableIterator < LinkedListNode < T >> pop() Declaration pop(): T | undefined; Returns T | undefined popNode() Declaration popNode(): LinkedListNode<T> | undefined; Returns LinkedListNode < T > | undefined push(value) Declaration push(value: T): LinkedListNode<T>; Parameters value T Returns LinkedListNode < T > pushNode(newNode) Declaration pushNode(newNode: LinkedListNode<T>): void; Parameters newNode LinkedListNode < T > Returns void reduce(callback) Declaration reduce(callback: (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T): T; Parameters callback ( previousValue : T , value : T , node : LinkedListNode < T >, list : LinkedList < T >) => T Returns T reduce(callback, initialValue) Declaration reduce(callback: (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T, initialValue: T): T; Parameters callback ( previousValue : T , value : T , node : LinkedListNode < T >, list : LinkedList < T >) => T initialValue T Returns T reduce(callback, initialValue) Declaration reduce<U>(callback: (previousValue: U, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => U, initialValue: U): U; Parameters callback ( previousValue : U , value : T , node : LinkedListNode < T >, list : LinkedList < T >) => U initialValue U Returns U reduceRight(callback) Declaration reduceRight(callback: (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T): T; Parameters callback ( previousValue : T , value : T , node : LinkedListNode < T >, list : LinkedList < T >) => T Returns T reduceRight(callback, initialValue) Declaration reduceRight(callback: (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T, initialValue: T): T; Parameters callback ( previousValue : T , value : T , node : LinkedListNode < T >, list : LinkedList < T >) => T initialValue T Returns T reduceRight(callback, initialValue) Declaration reduceRight<U>(callback: (previousValue: U, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => U, initialValue: U): U; Parameters callback ( previousValue : U , value : T , node : LinkedListNode < T >, list : LinkedList < T >) => U initialValue U Returns U shift() Declaration shift(): T | undefined; Returns T | undefined shiftNode() Declaration shiftNode(): LinkedListNode<T> | undefined; Returns LinkedListNode < T > | undefined some(callback, thisArg) Declaration some(callback?: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): boolean; Parameters callback ( value : T , node : LinkedListNode < T >, list : LinkedList < T >) => boolean thisArg any Returns boolean unshift(value) Declaration unshift(value: T): LinkedListNode<T>; Parameters value T Returns LinkedListNode < T > unshiftNode(newNode) Declaration unshiftNode(newNode: LinkedListNode<T>): void; Parameters newNode LinkedListNode < T > Returns void values() Declaration values(): IterableIterator<T>; Returns IterableIterator < T >"
  },
  "api/async-stack/asyncstack.html": {
    "href": "api/async-stack/asyncstack.html",
    "title": "Class AsyncStack | @esfx API Reference",
    "keywords": "Class AsyncStack An asynchronous Stack. Constructors constructor(iterable) Initializes a new instance of the AsyncStack class. Declaration constructor(iterable?: Iterable<T | PromiseLike<T>>); Parameters iterable Iterable < T | PromiseLike < T >> Properties done Gets a value indicating whether the stack has ended and there are no more items available. Declaration readonly done: boolean; Property Value boolean readable Gets a value indicating whether items can be read from the stack. Declaration readonly readable: boolean; Property Value boolean size Gets the number of entries in the stack. When positive, indicates the number of entries available to get. When negative, indicates the number of requests waiting to be fulfilled. Declaration readonly size: number; Property Value number writable Gets a value indicating whether new items can be added to the stack. Declaration readonly writable: boolean; Property Value boolean Methods doneReading() Blocks attempts to read from the stack until it is empty. Available items in the stack can still be read until the stack is empty. Declaration doneReading(): void; Returns void doneWriting() Blocks attempts to write to the stack. Pending requests in the stack can still be resolved until the stack is empty. Declaration doneWriting(): void; Returns void end() Blocks future attempts to read or write from the stack. Available items in the stack can still be read until the stack is empty. Pending reads from the stack are rejected with a CancelError <!-- --> . Declaration end(): void; Returns void pop(cancelable) Removes and returns a Promise for the top value of the stack. If the stack is empty, returns a Promise for the next value to be pushed on to the stack. Declaration pop(cancelable?: Cancelable): Promise<T>; Parameters cancelable Cancelable Returns Promise < T > push(this) Adds a value to the top of the stack. If the stack is empty but has a pending pop request, the value will be popped and the request fulfilled. Declaration push(this: AsyncStack<void>): void; Parameters this AsyncStack <void> Returns void push(value) Adds a value to the top of the stack. If the stack is empty but has a pending pop request, the value will be popped and the request fulfilled. Declaration push(value: T | PromiseLike<T>): void; Parameters value T | PromiseLike < T > Returns void"
  },
  "api/async-semaphore/asyncsemaphore.html": {
    "href": "api/async-semaphore/asyncsemaphore.html",
    "title": "Class AsyncSemaphore | @esfx API Reference",
    "keywords": "Class AsyncSemaphore Limits the number of asynchronous operations that can access a resource or pool of resources. Constructors constructor(initialCount, maxCount) Initializes a new instance of the Semaphore class. Declaration constructor(initialCount: number, maxCount?: number); Parameters initialCount number maxCount number Properties count Gets the number of remaining asynchronous operations that can enter the Semaphore. Declaration readonly count: number; Property Value number Methods release(count) Releases the [[Semaphore]] one or more times. Declaration release(count?: number): void; Parameters count number Returns void wait(cancelable) Asynchronously waits for the event to become signaled. Declaration wait(cancelable?: Cancelable): Promise<void>; Parameters cancelable Cancelable Returns Promise <void>"
  },
  "api/async-countdown/asynccountdownevent.html": {
    "href": "api/async-countdown/asynccountdownevent.html",
    "title": "Class AsyncCountdownEvent | @esfx API Reference",
    "keywords": "Class AsyncCountdownEvent An event that is set when all participants have signaled. Constructors constructor(initialCount) Initializes a new instance of the CountdownEvent class. Declaration constructor(initialCount: number); Parameters initialCount number Properties initialCount Gets the number of signals initially required to set the event. Declaration readonly initialCount: number; Property Value number remainingCount Gets the number of remaining signals required to set the event. Declaration readonly remainingCount: number; Property Value number Methods add(count) Increments the event's current count by one or more. Declaration add(count?: number): void; Parameters count number Returns void reset(count) Resets the remaining and initial count to the specified value, or the initial count. Declaration reset(count?: number): void; Parameters count number Returns void signal(count) Registers one or more signals with the CountdownEvent, decrementing the remaining count. Declaration signal(count?: number): boolean; Parameters count number Returns boolean wait(cancelable) Asynchronously waits for the event to become signaled. Declaration wait(cancelable?: Cancelable): Promise<void>; Parameters cancelable Cancelable Returns Promise <void>"
  },
  "api/async-conditionvariable/asyncconditionvariable.html": {
    "href": "api/async-conditionvariable/asyncconditionvariable.html",
    "title": "Class AsyncConditionVariable | @esfx API Reference",
    "keywords": "Class AsyncConditionVariable Methods notifyAll() Notifies all current waiters to reacquire their locks. Declaration notifyAll(): void; Returns void notifyOne() Notifies one waiter to reacquire its lock. Declaration notifyOne(): void; Returns void wait(lock, cancelable) Releases lock <!-- --> , waiting until notified before reacquiring lock <!-- --> . Declaration wait(lock: AsyncLockable, cancelable?: Cancelable): Promise<void>; Parameters lock AsyncLockable cancelable Cancelable Returns Promise <void> wait(lock, condition, cancelable) Releases lock <!-- --> , waiting until notified before reacquiring lock <!-- --> . Declaration wait(lock: AsyncLockable, condition?: () => boolean, cancelable?: Cancelable): Promise<void>; Parameters lock AsyncLockable condition () => boolean cancelable Cancelable Returns Promise <void>"
  },
  "api/equatable.html": {
    "href": "api/equatable.html",
    "title": "Package @esfx/equatable | @esfx API Reference",
    "keywords": "Package @esfx/equatable Provides a low level API for defining equality. Overview Installation Usage Installation npm i @esfx/equatable Usage TypeScript JavaScript (CommonJS) import { Equatable, Equaler, Comparable, Comparer } from \"@esfx/equatable\"; class Person { firstName: string; lastName: string; constructor(firstName: string, lastName: string) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other: unknown) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other: unknown) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const people = [ new Person(\"Alice\", \"Johnson\") new Person(\"Bob\", \"Clark\"), ]; people.sort(Comparer.defaultComparer.compare); console.log(people); // Bob Clark,Alice Johnson const obj1 = new Person(\"Bob\", \"Clark\"); const obj2 = new Person(\"Bob\", \"Clark\"); obj1 === obj2; // false Equaler.defaultEqualer.equals(obj1, obj2); // true const { Equatable, Equaler, Comparable, Comparer } = require(\"@esfx/equatable\"); class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const people = [ new Person(\"Alice\", \"Johnson\") new Person(\"Bob\", \"Clark\"), ]; people.sort(Comparer.defaultComparer.compare); console.log(people); // Bob Clark,Alice Johnson const obj1 = new Person(\"Bob\", \"Clark\"); const obj2 = new Person(\"Bob\", \"Clark\"); obj1 === obj2; // false Equaler.defaultEqualer.equals(obj1, obj2); // true Type Aliases Comparison Declaration export declare type Comparison<T> = (x: T, y: T) => number; Type ( x : T , y : T ) => number EqualityComparison Declaration export declare type EqualityComparison<T> = (x: T, y: T) => boolean; Type ( x : T , y : T ) => boolean HashGenerator Declaration export declare type HashGenerator<T> = (x: T) => number; Type ( x : T ) => number"
  },
  "api/equatable-shim.html": {
    "href": "api/equatable-shim.html",
    "title": "Package @esfx/equatable-shim | @esfx API Reference",
    "keywords": "Package @esfx/equatable-shim Provides a global shim that adds @esfx/equatable functionality to various ECMAScript built-ins. Overview Installation Usage Installation npm i @esfx/equatable-shim Usage The global shim adds a default implementation of Equatable to Object.prototype and default implementations of @\"comparable.Comparable_Interface\" to String.prototype , Number.prototype , Boolean.prototype , and BigInt.prototype . To install the global shim, import @esfx/equatable-shim : TypeScript JavaScript (CommonJS) import \"@esfx/equatable-shim\"; // triggers global-scope side effects import { Equatable } from \"@esfx/equatable\"; 123[Equatable.hash]() // 123 require(\"@esfx/equatable-shim\"); // triggers global-scope side effects const { Equatable } = require(\"@esfx/equatable\"); 123[Equatable.hash]() // 123"
  },
  "api/struct-type/struct.html": {
    "href": "api/struct-type/struct.html",
    "title": "Class Struct | @esfx API Reference",
    "keywords": "Class Struct Constructors constructor() Constructs a new instance of the Struct class Declaration constructor(); constructor(shared) Constructs a new instance of the Struct class Declaration constructor(shared: boolean); Parameters shared boolean constructor(buffer, byteOffset) Constructs a new instance of the Struct class Declaration constructor(buffer: ArrayBufferLike, byteOffset?: number); Parameters buffer ArrayBufferLike byteOffset number constructor(object, shared) Constructs a new instance of the Struct class Declaration constructor(object: Partial<StructInitProperties<TDef>>, shared?: boolean); Parameters object Partial < StructInitProperties < TDef >> shared boolean constructor(elements, shared) Constructs a new instance of the Struct class Declaration constructor(elements: Partial<StructInitElements<TDef>>, shared?: boolean); Parameters elements Partial < StructInitElements < TDef >> shared boolean Properties buffer Declaration readonly buffer: ArrayBuffer | SharedArrayBuffer; Property Value ArrayBuffer | SharedArrayBuffer byteLength Declaration readonly byteLength: number; Property Value number byteOffset Declaration readonly byteOffset: number; Property Value number SIZE Declaration static readonly SIZE: number; Property Value number Methods get(key) Declaration get<K extends keyof StructProperties<TDef>>(key: K): StructProperties<TDef>[K]; Parameters key K Returns StructProperties < TDef >[ K ] getIndex(index) Declaration getIndex<I extends keyof StructElements<TDef>>(index: I): StructElements<TDef>[I]; Parameters index I Returns StructElements < TDef >[ I ] set(key, value) Declaration set<K extends keyof StructProperties<TDef>>(key: K, value: StructProperties<TDef>[K]): void; Parameters key K value StructProperties < TDef >[ K ] Returns void setIndex(index, value) Declaration setIndex<I extends keyof StructElements<TDef>>(index: I, value: StructElements<TDef>[I]): boolean; Parameters index I value StructElements < TDef >[ I ] Returns boolean writeTo(buffer, byteOffset) Declaration writeTo(buffer: ArrayBufferLike, byteOffset?: number): void; Parameters buffer ArrayBufferLike byteOffset number Returns void"
  },
  "api/ref/ref_namespace.html": {
    "href": "api/ref/ref_namespace.html",
    "title": "Namespace ref | @esfx API Reference",
    "keywords": "Namespace ref Functions _for(value) Creates a ref for an initial value. Declaration function _for<T>(value: T): Reference<T>; Parameters value T Returns Reference < T > _is(value) Determines whether value is a [[ref]]. Declaration function _is(value: unknown): value is Reference<any>; Parameters value unknown Returns value is Reference <any> at(object, key, readonly) Creates a ref to a property of an object. Declaration function at<T, K extends keyof T>(object: T, key: K, readonly?: boolean): Reference<T[K]>; Parameters object T key K readonly boolean Returns Reference < T [ K ]> out() Creates a ref that must be set before it can be read. Declaration function out<T>(): Reference<T>; Returns Reference < T > out(get, set) Declaration function out<T>(get: () => T, set: (value: T) => void): Reference<T>; Parameters get () => T set ( value : T ) => void Returns Reference < T > Variables prototype Declaration prototype: Reference<unknown> Type Reference <unknown>"
  },
  "api/equatable/equaler_namespace.html": {
    "href": "api/equatable/equaler_namespace.html",
    "title": "Namespace Equaler | @esfx API Reference",
    "keywords": "Namespace Equaler Functions create(equalityComparison, hashGenerator) Creates an Equaler from a comparison function and an optional hash generator. Declaration function create<T>(equalityComparison: EqualityComparison<T>, hashGenerator?: HashGenerator<T>): Equaler<T>; Parameters equalityComparison EqualityComparison < T > hashGenerator HashGenerator < T > Returns Equaler < T > Variables defaultEqualer Gets the default Equaler <!-- --> . Declaration defaultEqualer: Equaler<unknown> Type Equaler <unknown> structuralEqualer Gets a default Equaler that supports StructuralEquatable values. Declaration structuralEqualer: Equaler<unknown> Type Equaler <unknown> tupleEqualer An Equaler that compares array values rather than the arrays themselves. Declaration tupleEqualer: Equaler<readonly unknown[]> Type Equaler <readonly unknown[]> tupleStructuralEqualer An Equaler that compares array values that may be StructuralEquatable rather than the arrays themselves. Declaration tupleStructuralEqualer: Equaler<readonly unknown[]> Type Equaler <readonly unknown[]>"
  },
  "api/equatable/comparable_interface.html": {
    "href": "api/equatable/comparable_interface.html",
    "title": "Interface Comparable | @esfx API Reference",
    "keywords": "Interface Comparable Represents a value that can compare itself relationally with another value. Methods [Comparable.compareTo](other) Compares this value with another value: - A negative value indicates this value is lesser. - A positive value indicates this value is greater. - A zero value indicates this value is the same. Declaration [Comparable.compareTo](other: unknown): number; Parameters other unknown Returns number"
  },
  "api/disposable/disposable_namespace.html": {
    "href": "api/disposable/disposable_namespace.html",
    "title": "Namespace Disposable | @esfx API Reference",
    "keywords": "Namespace Disposable Functions create(dispose) Creates a Disposable wrapper around a callback used to dispose of a resource. Declaration function create(dispose: () => void): Disposable; Parameters dispose () => void Returns Disposable from(disposables) Creates a Disposable wrapper around a set of other disposables. Declaration function from(disposables: Iterable<Disposable | null | undefined>): Disposable; Parameters disposables Iterable < Disposable | null | undefined> Returns Disposable isDisposable(value) Determines whether a value is [[Disposable]]. Declaration function isDisposable(value: unknown): value is Disposable; Parameters value unknown Returns value is Disposable use(resource, callback) Executes a callback with the provided Disposable resource, disposing the resource when the callback completes. Declaration function use<T extends Disposable | null | undefined, U>(resource: T, callback: (resource: T) => U): U; Parameters resource T callback ( resource : T ) => U Returns U Variables dispose A well-known symbol used to define an explicit resource disposal method on an object. Declaration dispose: unique symbol Type unique symbol"
  },
  "api/collections-hashset/hashset.html": {
    "href": "api/collections-hashset/hashset.html",
    "title": "Class HashSet | @esfx API Reference",
    "keywords": "Class HashSet Constructors constructor(equaler) Constructs a new instance of the HashSet class Declaration constructor(equaler?: Equaler<T>); Parameters equaler Equaler < T > constructor(iterable, equaler) Constructs a new instance of the HashSet class Declaration constructor(iterable?: Iterable<T>, equaler?: Equaler<T>); Parameters iterable Iterable < T > equaler Equaler < T > constructor(capacity, equaler) Constructs a new instance of the HashSet class Declaration constructor(capacity: number, equaler?: Equaler<T>); Parameters capacity number equaler Equaler < T > Properties [Collection.size] Declaration readonly [Collection.size]: number; Property Value number [Symbol.toStringTag] Declaration [Symbol.toStringTag]: string; Property Value string equaler Declaration readonly equaler: Equaler<T>; Property Value Equaler < T > size Declaration readonly size: number; Property Value number Methods [Collection.add](value) Declaration [Collection.add](value: T): void; Parameters value T Returns void [Collection.clear]() Declaration [Collection.clear](): void; Returns void [Collection.delete](value) Declaration [Collection.delete](value: T): boolean; Parameters value T Returns boolean [Collection.has](value) Declaration [Collection.has](value: T): boolean; Parameters value T Returns boolean [Symbol.iterator]() Declaration [Symbol.iterator](): IterableIterator<T>; Returns IterableIterator < T > add(value) Declaration add(value: T): this; Parameters value T Returns this clear() Declaration clear(): void; Returns void delete(value) Declaration delete(value: T): boolean; Parameters value T Returns boolean ensureCapacity(capacity) Declaration ensureCapacity(capacity: number): number; Parameters capacity number Returns number entries() Declaration entries(): IterableIterator<[T, T]>; Returns IterableIterator <[ T , T ]> forEach(callback, thisArg) Declaration forEach(callback: (value: T, key: T, map: this) => void, thisArg?: any): void; Parameters callback ( value : T , key : T , map : this) => void thisArg any Returns void has(value) Declaration has(value: T): boolean; Parameters value T Returns boolean keys() Declaration keys(): IterableIterator<T>; Returns IterableIterator < T > trimExcess(capacity) Declaration trimExcess(capacity?: number): void; Parameters capacity number Returns void values() Declaration values(): IterableIterator<T>; Returns IterableIterator < T >"
  },
  "api/equatable/equatable_namespace.html": {
    "href": "api/equatable/equatable_namespace.html",
    "title": "Namespace Equatable | @esfx API Reference",
    "keywords": "Namespace Equatable Functions isEquatable(value) Determines whether a value is Equatable. Declaration function isEquatable(value: unknown): value is Equatable; Parameters value unknown Returns value is Equatable Variables equals A well-known symbol used to define an equality test method on a value. Declaration equals: unique symbol Type unique symbol hash A well-known symbol used to define a hashing method on a value. Declaration hash: unique symbol Type unique symbol"
  },
  "api/disposable/disposable_interface.html": {
    "href": "api/disposable/disposable_interface.html",
    "title": "Interface Disposable | @esfx API Reference",
    "keywords": "Interface Disposable Indicates an object that has resources that can be explicitly disposed. Methods [Disposable.dispose]() Dispose this object's resources. Declaration [Disposable.dispose](): void; Returns void"
  },
  "api/disposable/asyncdisposable_namespace.html": {
    "href": "api/disposable/asyncdisposable_namespace.html",
    "title": "Namespace AsyncDisposable | @esfx API Reference",
    "keywords": "Namespace AsyncDisposable Functions create(dispose) Creates an AsyncDisposable wrapper around a callback used to dispose resources. Declaration function create(dispose: () => void | PromiseLike<void>): AsyncDisposable; Parameters dispose () => void | PromiseLike <void> Returns AsyncDisposable from(resources) Creates an AsyncDisposable wrapper around a set of other disposables. Declaration function from(resources: Iterable<AsyncDisposable | Disposable | null | undefined>): AsyncDisposable; Parameters resources Iterable < AsyncDisposable | Disposable | null | undefined> Returns AsyncDisposable isAsyncDisposable(value) Determines whether a value is [[AsyncDisposable]]. Declaration function isAsyncDisposable(value: unknown): value is AsyncDisposable; Parameters value unknown Returns value is AsyncDisposable use(resource, callback) Executes a callback with the provided AsyncDisposable resource, disposing the resource when the callback completes asynchronously. Declaration function use<T extends AsyncDisposable | Disposable | null | undefined, U>(resource: T, callback: (resource: T) => U | PromiseLike<U>): Promise<U>; Parameters resource T callback ( resource : T ) => U | PromiseLike < U > Returns Promise < U > Variables asyncDispose A well-known symbol used to define an async explicit resource disposal method on an object. Declaration asyncDispose: unique symbol Type unique symbol"
  },
  "api/disposable/asyncdisposable_interface.html": {
    "href": "api/disposable/asyncdisposable_interface.html",
    "title": "Interface AsyncDisposable | @esfx API Reference",
    "keywords": "Interface AsyncDisposable Indicates an object that has resources that can be explicitly disposed asynchronously. Methods [AsyncDisposable.asyncDispose]() Dispose this object's resources. Declaration [AsyncDisposable.asyncDispose](): Promise<void>; Returns Promise <void>"
  },
  "api/decorators-stage1-core/parameterdescriptor.html": {
    "href": "api/decorators-stage1-core/parameterdescriptor.html",
    "title": "Interface ParameterDescriptor | @esfx API Reference",
    "keywords": "Interface ParameterDescriptor Properties index Declaration index: number; Property Value number key Declaration key: string | symbol; Property Value string | symbol kind Declaration kind: \"parameter\"; Property Value \"parameter\" target Declaration target: object; Property Value object"
  },
  "api/collections-sortedset/sortedset.html": {
    "href": "api/collections-sortedset/sortedset.html",
    "title": "Class SortedSet | @esfx API Reference",
    "keywords": "Class SortedSet Constructors constructor(comparer) Constructs a new instance of the SortedSet class Declaration constructor(comparer?: Comparison<T> | Comparer<T>); Parameters comparer Comparison < T > | Comparer < T > constructor(iterable, comparer) Constructs a new instance of the SortedSet class Declaration constructor(iterable?: Iterable<T>, comparer?: Comparison<T> | Comparer<T>); Parameters iterable Iterable < T > comparer Comparison < T > | Comparer < T > Properties [Collection.size] Declaration readonly [Collection.size]: number; Property Value number [Symbol.toStringTag] Declaration [Symbol.toStringTag]: string; Property Value string comparer Declaration readonly comparer: Comparer<T>; Property Value Comparer < T > size Declaration readonly size: number; Property Value number Methods [Collection.add](value) Declaration [Collection.add](value: T): void; Parameters value T Returns void [Collection.clear]() Declaration [Collection.clear](): void; Returns void [Collection.delete](value) Declaration [Collection.delete](value: T): boolean; Parameters value T Returns boolean [Collection.has](value) Declaration [Collection.has](value: T): boolean; Parameters value T Returns boolean [Symbol.iterator]() Declaration [Symbol.iterator](): IterableIterator<T>; Returns IterableIterator < T > add(value) Declaration add(value: T): this; Parameters value T Returns this clear() Declaration clear(): void; Returns void delete(value) Declaration delete(value: T): boolean; Parameters value T Returns boolean entries() Declaration entries(): IterableIterator<[T, T]>; Returns IterableIterator <[ T , T ]> forEach(cb, thisArg) Declaration forEach(cb: (value: T, key: T, map: this) => void, thisArg?: unknown): void; Parameters cb ( value : T , key : T , map : this) => void thisArg unknown Returns void has(value) Declaration has(value: T): boolean; Parameters value T Returns boolean keys() Declaration keys(): IterableIterator<T>; Returns IterableIterator < T > values() Declaration values(): IterableIterator<T>; Returns IterableIterator < T >"
  },
  "api/collections-sortedset/readonlysortedset.html": {
    "href": "api/collections-sortedset/readonlysortedset.html",
    "title": "Interface ReadonlySortedSet | @esfx API Reference",
    "keywords": "Interface ReadonlySortedSet Properties comparer Declaration readonly comparer: Comparer<T>; Property Value Comparer < T > Methods [Symbol.iterator]() Declaration [Symbol.iterator](): IterableIterator<T>; Returns IterableIterator < T >"
  },
  "api/collections-sortedmap/sortedmap.html": {
    "href": "api/collections-sortedmap/sortedmap.html",
    "title": "Class SortedMap | @esfx API Reference",
    "keywords": "Class SortedMap Constructors constructor(comparer) Constructs a new instance of the SortedMap class Declaration constructor(comparer?: Comparison<K> | Comparer<K>); Parameters comparer Comparison < K > | Comparer < K > constructor(iterable, comparer) Constructs a new instance of the SortedMap class Declaration constructor(iterable?: Iterable<[K, V]>, comparer?: Comparison<K> | Comparer<K>); Parameters iterable Iterable <[ K , V ]> comparer Comparison < K > | Comparer < K > Properties [KeyedCollection.size] Declaration readonly [KeyedCollection.size]: number; Property Value number [Symbol.toStringTag] Declaration [Symbol.toStringTag]: string; Property Value string comparer Declaration readonly comparer: Comparer<K>; Property Value Comparer < K > size Declaration readonly size: number; Property Value number Methods [KeyedCollection.clear]() Declaration [KeyedCollection.clear](): void; Returns void [KeyedCollection.delete](key) Declaration [KeyedCollection.delete](key: K): boolean; Parameters key K Returns boolean [KeyedCollection.get](key) Declaration [KeyedCollection.get](key: K): V | undefined; Parameters key K Returns V | undefined [KeyedCollection.has](key) Declaration [KeyedCollection.has](key: K): boolean; Parameters key K Returns boolean [KeyedCollection.keys]() Declaration [KeyedCollection.keys](): IterableIterator<K>; Returns IterableIterator < K > [KeyedCollection.set](key, value) Declaration [KeyedCollection.set](key: K, value: V): void; Parameters key K value V Returns void [KeyedCollection.values]() Declaration [KeyedCollection.values](): IterableIterator<V>; Returns IterableIterator < V > [Symbol.iterator]() Declaration [Symbol.iterator](): IterableIterator<[K, V]>; Returns IterableIterator <[ K , V ]> clear() Declaration clear(): void; Returns void delete(key) Declaration delete(key: K): boolean; Parameters key K Returns boolean entries() Declaration entries(): IterableIterator<[K, V]>; Returns IterableIterator <[ K , V ]> forEach(cb, thisArg) Declaration forEach(cb: (value: V, key: K, map: this) => void, thisArg?: unknown): void; Parameters cb ( value : V , key : K , map : this) => void thisArg unknown Returns void get(key) Declaration get(key: K): V | undefined; Parameters key K Returns V | undefined has(key) Declaration has(key: K): boolean; Parameters key K Returns boolean keys() Declaration keys(): IterableIterator<K>; Returns IterableIterator < K > set(key, value) Declaration set(key: K, value: V): this; Parameters key K value V Returns this values() Declaration values(): IterableIterator<V>; Returns IterableIterator < V >"
  },
  "api/collections-sortedmap/readonlysortedmap.html": {
    "href": "api/collections-sortedmap/readonlysortedmap.html",
    "title": "Interface ReadonlySortedMap | @esfx API Reference",
    "keywords": "Interface ReadonlySortedMap Properties comparer Declaration readonly comparer: Comparer<K>; Property Value Comparer < K > Methods [Symbol.iterator]() Declaration [Symbol.iterator](): IterableIterator<[K, V]>; Returns IterableIterator <[ K , V ]>"
  },
  "api/collection-core/keyedcollection_namespace.html": {
    "href": "api/collection-core/keyedcollection_namespace.html",
    "title": "Namespace KeyedCollection | @esfx API Reference",
    "keywords": "Namespace KeyedCollection Functions isKeyedCollection(value) Tests whether a value supports the minimal representation of a KeyedCollection <!-- --> . Declaration function isKeyedCollection<K, V>(value: Iterable<[K, V]>): value is KeyedCollection<K, V>; Parameters value Iterable <[ K , V ]> Returns value is KeyedCollection < K , V > isKeyedCollection(value) Tests whether a value supports the minimal representation of a KeyedCollection <!-- --> . Declaration function isKeyedCollection(value: unknown): value is KeyedCollection<unknown, unknown>; Parameters value unknown Returns value is KeyedCollection <unknown, unknown> Variables | Improve this Doc delete A well-known symbol used to define the KeyedCollection#[KeyedCollection.delete] method. Declaration delete: unique symbol Type unique symbol clear A well-known symbol used to define the KeyedCollection#[KeyedCollection.clear] method. Declaration clear: unique symbol Type unique symbol set A well-known symbol used to define the KeyedCollection#[KeyedCollection.set] method. Declaration set: unique symbol Type unique symbol"
  },
  "api/collection-core/keyedcollection_interface.html": {
    "href": "api/collection-core/keyedcollection_interface.html",
    "title": "Interface KeyedCollection | @esfx API Reference",
    "keywords": "Interface KeyedCollection Methods [KeyedCollection.clear]() Clears the collection. Declaration [KeyedCollection.clear](): void; Returns void [KeyedCollection.delete](key) Deletes a key and its associated value from the collection. Declaration [KeyedCollection.delete](key: K): boolean; Parameters key K Returns boolean true if the key was found and removed; otherwise, false <!-- --> . [KeyedCollection.set](key, value) Sets a value in the collection for the provided key. Declaration [KeyedCollection.set](key: K, value: V): void; Parameters key K value V Returns void"
  },
  "api/collection-core/indexedcollection_namespace.html": {
    "href": "api/collection-core/indexedcollection_namespace.html",
    "title": "Namespace IndexedCollection | @esfx API Reference",
    "keywords": "Namespace IndexedCollection Functions isIndexedCollection(value) Tests whether a value supports the minimal representation of an IndexedCollection <!-- --> . Declaration function isIndexedCollection<T>(value: Iterable<T>): value is IndexedCollection<T>; Parameters value Iterable < T > Returns value is IndexedCollection < T > isIndexedCollection(value) Tests whether a value supports the minimal representation of an IndexedCollection <!-- --> . Declaration function isIndexedCollection(value: unknown): value is IndexedCollection<unknown>; Parameters value unknown Returns value is IndexedCollection <unknown> Variables | Improve this Doc delete Declaration delete: unique symbol Type typeof Collection . delete insertAt A well-known symbol used to define the IndexedCollection#[IndexedCollection.insertAt] method. Declaration insertAt: unique symbol Type unique symbol removeAt A well-known symbol used to define the IndexedCollection#[IndexedCollection.removeAt] method. Declaration removeAt: unique symbol Type unique symbol"
  },
  "api/collection-core/indexedcollection_interface.html": {
    "href": "api/collection-core/indexedcollection_interface.html",
    "title": "Interface IndexedCollection | @esfx API Reference",
    "keywords": "Interface IndexedCollection Methods [IndexedCollection.insertAt](index, value) Inserts a value at the specified index in the collection, shifting any following elements to the right one position. Declaration [IndexedCollection.insertAt](index: number, value: T): void; Parameters index number value T Returns void [IndexedCollection.removeAt](index) Removes the value at the specified index in the collection, shifting any following elements to the left one position. Declaration [IndexedCollection.removeAt](index: number): void; Parameters index number Returns void"
  },
  "api/cancelable/cancelablesource_namespace.html": {
    "href": "api/cancelable/cancelablesource_namespace.html",
    "title": "Namespace CancelableSource | @esfx API Reference",
    "keywords": "Namespace CancelableSource Functions isCancelableSource(value) Determines whether a value is a CancelableSource object. Declaration function isCancelableSource(value: unknown): value is CancelableSource; Parameters value unknown Returns value is CancelableSource Variables cancel Declaration cancel: unique symbol Type unique symbol"
  },
  "api/cancelable/cancelablesource_interface.html": {
    "href": "api/cancelable/cancelablesource_interface.html",
    "title": "Interface CancelableSource | @esfx API Reference",
    "keywords": "Interface CancelableSource Represents an object that is a source for cancelation. Methods [CancelableSource.cancel]() Cancels the source, notifying the associated [[CancelSignal]]. Declaration [CancelableSource.cancel](): void; Returns void"
  },
  "api/cancelable/cancelablecancelsignal.html": {
    "href": "api/cancelable/cancelablecancelsignal.html",
    "title": "Interface CancelableCancelSignal | @esfx API Reference",
    "keywords": "Interface CancelableCancelSignal Methods [Cancelable.cancelSignal]() Declaration [Cancelable.cancelSignal](): CancelableCancelSignal; Returns CancelableCancelSignal"
  },
  "api/struct-type/structtypeconstructor.html": {
    "href": "api/struct-type/structtypeconstructor.html",
    "title": "Interface StructTypeConstructor | @esfx API Reference",
    "keywords": "Interface StructTypeConstructor Properties prototype Declaration prototype: typeof Struct; Property Value typeof Struct"
  },
  "api/struct-type/structprimitivetype.html": {
    "href": "api/struct-type/structprimitivetype.html",
    "title": "Interface StructPrimitiveType | @esfx API Reference",
    "keywords": "Interface StructPrimitiveType Properties name Declaration readonly name: K; Property Value K SIZE Declaration readonly SIZE: number; Property Value number"
  },
  "api/struct-type/structfielddefinition.html": {
    "href": "api/struct-type/structfielddefinition.html",
    "title": "Interface StructFieldDefinition | @esfx API Reference",
    "keywords": "Interface StructFieldDefinition Properties name Declaration readonly name: string | symbol; Property Value string | symbol type Declaration readonly type: StructFieldType; Property Value StructFieldType"
  },
  "api/lazy/lazy.html": {
    "href": "api/lazy/lazy.html",
    "title": "Class Lazy | @esfx API Reference",
    "keywords": "Class Lazy Constructors constructor(factory) Constructs a new instance of the Lazy class Declaration constructor(factory: () => T); Parameters factory () => T Properties hasValue Declaration readonly hasValue: boolean; Property Value boolean value Declaration readonly value: T; Property Value T Methods for(value) Declaration static for<T>(value: T): Lazy<T>; Parameters value T Returns Lazy < T > from(factory, args) Declaration static from<T, A extends any[]>(factory: (...args: A) => T, ...args: A): Lazy<T>; Parameters factory (... args : A ) => T args A Returns Lazy < T >"
  },
  "api/indexed-object/integerindexedobject.html": {
    "href": "api/indexed-object/integerindexedobject.html",
    "title": "Class IntegerIndexedObject | @esfx API Reference",
    "keywords": "Class IntegerIndexedObject Represents an object that can be indexed by an integer value similar to a native Array or TypedArray. Constructors constructor() Constructs a new instance of the IntegerIndexedObject class Declaration constructor(); Methods deleteIndex(index) Deletes the value at the specified index/ Declaration protected deleteIndex(index: number): boolean; Parameters index number Returns boolean true if the value was successfully deleted; otherwise, false <!-- --> . getIndex(index) Gets the value at the specified index. Declaration protected abstract getIndex(index: number): T; Parameters index number Returns T getLength() Gets the \"length\" of the indexed object, which should be one more than the largest index stored in the object. Declaration protected abstract getLength(): number; Returns number hasIndex(index) Determines whether the object contains a value at the specified index. Declaration protected hasIndex(index: number): boolean; Parameters index number Returns boolean setIndex(index, value) Sets the value at the specified index. Declaration protected setIndex(index: number, value: T): boolean; Parameters index number value T Returns boolean true if the value could be set; otherwise, false <!-- --> ."
  },
  "api/events/event_interface.html": {
    "href": "api/events/event_interface.html",
    "title": "Interface Event | @esfx API Reference",
    "keywords": "Interface Event"
  },
  "api/events/event_class.html": {
    "href": "api/events/event_class.html",
    "title": "Class Event | @esfx API Reference",
    "keywords": "Class Event Properties count Declaration readonly count: number; Property Value number owner Declaration readonly owner: ThisParameterType<F>; Property Value ThisParameterType < F > Methods addListener(listener) Declaration addListener(listener: EventListener<F>): ThisParameterType<F>; Parameters listener EventListener < F > Returns ThisParameterType < F > create() Declaration static create<F extends (this: undefined, ...args: any[]) => void>(): EventSource<F>; Returns EventSource < F > create(owner) Declaration static create<F extends (...args: any[]) => void>(owner: ThisParameterType<F>): EventSource<F>; Parameters owner ThisParameterType < F > Returns EventSource < F > listeners() Declaration listeners(): IterableIterator<EventListener<F>>; Returns IterableIterator < EventListener < F >> off(listener) Declaration off(listener: EventListener<F>): ThisParameterType<F>; Parameters listener EventListener < F > Returns ThisParameterType < F > on(listener) Declaration on(listener: EventListener<F>): ThisParameterType<F>; Parameters listener EventListener < F > Returns ThisParameterType < F > once(listener) Declaration once(listener: EventListener<F>): ThisParameterType<F>; Parameters listener EventListener < F > Returns ThisParameterType < F > prependListener(listener) Declaration prependListener(listener: EventListener<F>): ThisParameterType<F>; Parameters listener EventListener < F > Returns ThisParameterType < F > prependOnceListener(listener) Declaration prependOnceListener(listener: EventListener<F>): ThisParameterType<F>; Parameters listener EventListener < F > Returns ThisParameterType < F > rawListeners() Declaration rawListeners(): IterableIterator<EventListener<F>>; Returns IterableIterator < EventListener < F >> removeAllListeners() Declaration removeAllListeners(): ThisParameterType<F>; Returns ThisParameterType < F > removeListener(listener) Declaration removeListener(listener: EventListener<F>): ThisParameterType<F>; Parameters listener EventListener < F > Returns ThisParameterType < F >"
  },
  "api/collection-core/readonlycollection_namespace.html": {
    "href": "api/collection-core/readonlycollection_namespace.html",
    "title": "Namespace ReadonlyCollection | @esfx API Reference",
    "keywords": "Namespace ReadonlyCollection Functions isReadonlyCollection(value) Tests whether a value supports the minimal representation of a ReadonlyCollection <!-- --> . Declaration function isReadonlyCollection<T>(value: Iterable<T>): value is ReadonlyCollection<T>; Parameters value Iterable < T > Returns value is ReadonlyCollection < T > isReadonlyCollection(value) Tests whether a value supports the minimal representation of a ReadonlyCollection <!-- --> . Declaration function isReadonlyCollection(value: any): value is ReadonlyCollection<unknown>; Parameters value any Returns value is ReadonlyCollection <unknown> Variables has A well-known symbol used to define the ReadonlyCollection#[ReadonlyCollection.has] method. Declaration has: unique symbol Type unique symbol size A well-known symbol used to define the ReadonlyCollection#[ReadonlyCollection.size] property. Declaration size: unique symbol Type unique symbol"
  },
  "api/collection-core/readonlycollection_interface.html": {
    "href": "api/collection-core/readonlycollection_interface.html",
    "title": "Interface ReadonlyCollection | @esfx API Reference",
    "keywords": "Interface ReadonlyCollection Properties [ReadonlyCollection.size] Gets the number of elements in the collection. Declaration readonly [ReadonlyCollection.size]: number; Property Value number Methods [ReadonlyCollection.has](value) Tests whether an element is present in the collection. Declaration [ReadonlyCollection.has](value: T): boolean; Parameters value T Returns boolean"
  },
  "api/collection-core/keyedmulticollection_namespace.html": {
    "href": "api/collection-core/keyedmulticollection_namespace.html",
    "title": "Namespace KeyedMultiCollection | @esfx API Reference",
    "keywords": "Namespace KeyedMultiCollection Functions isKeyedMultiCollection(value) Tests whether a value supports the minimal representation of a KeyedMultiCollection <!-- --> . Declaration function isKeyedMultiCollection<K, V>(value: Iterable<[K, V]>): value is KeyedMultiCollection<K, V>; Parameters value Iterable <[ K , V ]> Returns value is KeyedMultiCollection < K , V > isKeyedMultiCollection(value) Tests whether a value supports the minimal representation of a KeyedMultiCollection <!-- --> . Declaration function isKeyedMultiCollection(value: unknown): value is KeyedMultiCollection<unknown, unknown>; Parameters value unknown Returns value is KeyedMultiCollection <unknown, unknown> Variables _delete A well-known symbol used to define the KeyedMultiCollection#[KeyedMultiCollection.delete] method. Declaration _delete: unique symbol Type unique symbol add A well-known symbol used to define the KeyedMultiCollection#[KeyedMultiCollection.add] method. Declaration add: unique symbol Type unique symbol clear A well-known symbol used to define the KeyedMultiCollection#[KeyedMultiCollection.clear] method. Declaration clear: unique symbol Type unique symbol deleteValue A well-known symbol used to define the KeyedMultiCollection#[KeyedMultiCollection.deleteValue] method. Declaration deleteValue: unique symbol Type unique symbol"
  },
  "api/collection-core/keyedmulticollection_interface.html": {
    "href": "api/collection-core/keyedmulticollection_interface.html",
    "title": "Interface KeyedMultiCollection | @esfx API Reference",
    "keywords": "Interface KeyedMultiCollection Methods [KeyedMultiCollection.add](key, value) Adds a value to the collection for the provided key. Declaration [KeyedMultiCollection.add](key: K, value: V): void; Parameters key K value V Returns void [KeyedMultiCollection.clear]() Clears the collection. Declaration [KeyedMultiCollection.clear](): void; Returns void [KeyedMultiCollection.delete](key) Deletes a key and its associated values from the collection. Declaration [KeyedMultiCollection.delete](key: K): number; Parameters key K Returns number The number of values removed when the key was deleted. [KeyedMultiCollection.deleteValue](key, value) Deletes a key and its associated value from the collection. Declaration [KeyedMultiCollection.deleteValue](key: K, value: V): boolean; Parameters key K value V Returns boolean true if the key and value were found and removed; otherwise, false <!-- --> ."
  },
  "api/cancelable/cancelsubscription_namespace.html": {
    "href": "api/cancelable/cancelsubscription_namespace.html",
    "title": "Namespace CancelSubscription | @esfx API Reference",
    "keywords": "Namespace CancelSubscription Functions create(unsubscribe) Creates a CancelSubscription object for an unsubscribe callback. Declaration function create(unsubscribe: () => void): CancelSubscription; Parameters unsubscribe () => void Returns CancelSubscription"
  },
  "api/cancelable/cancelsubscription_interface.html": {
    "href": "api/cancelable/cancelsubscription_interface.html",
    "title": "Interface CancelSubscription | @esfx API Reference",
    "keywords": "Interface CancelSubscription An object used to unsubscribe from a cancellation signal Methods unsubscribe() Unsubscribes from a cancellation signal. Declaration unsubscribe(): void; Returns void"
  },
  "api/cancelable/cancelsignal.html": {
    "href": "api/cancelable/cancelsignal.html",
    "title": "Interface CancelSignal | @esfx API Reference",
    "keywords": "Interface CancelSignal An object that represents a cancellation signal. Properties signaled Gets a value indicating whether cancellation was signaled. Declaration readonly signaled: boolean; Property Value boolean Methods subscribe(onSignaled) Subscribes to notifications for when the object becomes signaled. Declaration subscribe(onSignaled: () => void): CancelSubscription; Parameters onSignaled () => void Returns CancelSubscription"
  },
  "api/cancelable/cancelerror.html": {
    "href": "api/cancelable/cancelerror.html",
    "title": "Class CancelError | @esfx API Reference",
    "keywords": "Class CancelError Constructors constructor(message) Constructs a new instance of the CancelError class Declaration constructor(message?: string); Parameters message string"
  },
  "api/async-readerwriterlock/asyncreaderwriterlockwriter.html": {
    "href": "api/async-readerwriterlock/asyncreaderwriterlockwriter.html",
    "title": "Interface AsyncReaderWriterLockWriter | @esfx API Reference",
    "keywords": "Interface AsyncReaderWriterLockWriter Properties owner Gets the AsyncReaderWriterLock that owns this object. Declaration readonly owner: AsyncReaderWriterLock; Property Value AsyncReaderWriterLock"
  },
  "api/async-canceltoken/cancelsource.html": {
    "href": "api/async-canceltoken/cancelsource.html",
    "title": "Interface CancelSource | @esfx API Reference",
    "keywords": "Interface CancelSource Signals a CancelToken when cancellation has been requested. Properties token Gets the CancelToken linked to this source. Declaration readonly token: CancelToken; Property Value CancelToken Methods cancel() Cancels the source, evaluating any subscribed callbacks. If any callback raises an exception, the exception is propagated to a host specific unhanedle exception mechanism. Declaration cancel(): void; Returns void close() Closes the source, preventing the possibility of future cancellation. Declaration close(): void; Returns void"
  },
  "api/threading-spinwait.html": {
    "href": "api/threading-spinwait.html",
    "title": "Package @esfx/threading-spinwait | @esfx API Reference",
    "keywords": "Package @esfx/threading-spinwait Provides the SpinWait class, a thread synchronization primitive for use with Workers. Overview Installation Usage Installation npm i @esfx/threading-spinwait Usage TypeScript JavaScript (CommonJS) import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; import { SpinWait } from \"@esfx/threading-spinwait\"; import { StructType, int32 } from \"@esfx/struct-type\"; const SharedData = StructType([ { name: \"ready\", type: int32 }, ] as const); function worker_thread() { const data = new SharedData(workerData); // do some long running process... // signal that the work has completed. data.ready = 1; } function main() { const data = new SharedData(/*shared*/ true); const worker = new Worker(__filename, { workerData: data.buffer }); // start spinning until the condition is met. // this results in the thread sleeping periodically // while it waits for the condition. const spinWait = new SpinWait(); spinWait.spinUntil(() => data.ready === 1); } if (isMainThread) { main(); } else { worker_thread(); } const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const { SpinWait } = require(\"@esfx/threading-spinwait\"); const { StructType, int32 } = require(\"@esfx/struct-type\"); const SharedData = StructType([ { name: \"ready\", type: int32 }, ]); function worker_thread() { const data = new SharedData(workerData); // do some long running process... // signal that the work has completed. data.ready = 1; } function main() { const data = new SharedData(/*shared*/ true); const worker = new Worker(__filename, { workerData: data.buffer }); // start spinning until the condition is met. // this results in the thread sleeping periodically // while it waits for the condition. const spinWait = new SpinWait(); spinWait.spinUntil(() => data.ready === 1); } if (isMainThread) { main(); } else { worker_thread(); }"
  },
  "api/threading-sleep.html": {
    "href": "api/threading-sleep.html",
    "title": "Package @esfx/threading-sleep | @esfx API Reference",
    "keywords": "Package @esfx/threading-sleep Provides the sleep(ms) function which causes the current execution thread to sleep until the timeout expires. Overview Installation Usage Installation npm i @esfx/threading-sleep Usage TypeScript JavaScript import { sleep } from \"@esfx/threading-sleep\"; // block the main thread for half a second sleep(500); const { sleep } = require(\"@esfx/threading-sleep\"); // block the main thread for half a second sleep(500); Functions sleep(ms) Causes the current thread of execution to sleep until the specified timeout expires. Declaration export declare function sleep(ms: number): void; Parameters ms number Returns void"
  },
  "api/threading-conditionvariable.html": {
    "href": "api/threading-conditionvariable.html",
    "title": "Package @esfx/threading-conditionvariable | @esfx API Reference",
    "keywords": "Package @esfx/threading-conditionvariable Provides the ConditionVariable class, a thread synchronization primitive for use with Workers. Overview Installation Usage Installation npm i @esfx/threading-conditionvariable Usage TypeScript JavaScript (CommonJS) import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; import { Mutex } from \"@esfx/threading-mutex\"; import { ConditionVariable } from \"@esfx/threading-conditionvariable\"; import { StructType, int32 } from \"@esfx/struct-type\"; const SharedData = StructType([ { name: \"ready\", type: int32 }, { name: \"processed\", type: int32 }, ] as const); function worker_thread() { const m = new Mutex(workerData[0]); const cv = new ConditionVariable(workerData[1]); const data = new SharedData(workerData[2]); m.lock(); try { // release the lock and wait until main() sends data cv.wait(m, () => data.ready === 1); // after waiting we once again own the lock console.log(\"worker thread is processing data\"); // send data back to main() data.processed = 1; console.log(\"worker thread is done\"); } finally { m.unlock(); } cv.notifyOne(); } function main() { const m = new Mutex(); const cv = new ConditionVariable(); const data = new SharedData(/*shared*/ true); // start the Worker, passing the buffers of the shared objects const worker = new Worker(__filename, { workerData: [m.buffer, cv.buffer, data.buffer], stdout: true, }); // pipe stdout for console.log in worker worker.stdout.pipe(process.stdout); // send data to the worker m.lock(); try { data.ready = 1; console.log(\"main is ready\"); } finally { m.unlock(); } // notify the waiting worker cv.notifyOne(); m.lock(); try { // release the lock and wait for the worker to finish processing cv.wait(m, () => data.processed === 1); } finally { m.unlock(); } } if (isMainThread) { main(); } else { worker_thread(); } const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const { Mutex } = require(\"@esfx/threading-mutex\"); const { ConditionVariable } = require(\"@esfx/threading-conditionvariable\"); const { StructType, int32 } = require(\"@esfx/struct-type\"); const SharedData = StructType([ { name: \"ready\", type: int32 }, { name: \"processed\", type: int32 }, ]); function worker_thread() { const m = new Mutex(workerData[0]); const cv = new ConditionVariable(workerData[1]); const data = new SharedData(workerData[2]); m.lock(); try { // release the lock and wait until main() sends data cv.wait(m, () => data.ready === 1); // after waiting we once again own the lock console.log(\"worker thread is processing data\"); // send data back to main() data.processed = 1; console.log(\"worker thread is done\"); } finally { m.unlock(); } cv.notifyOne(); } function main() { const m = new Mutex(); const cv = new ConditionVariable(); const data = new SharedData(/*shared*/ true); // start the Worker, passing the buffers of the shared objects const worker = new Worker(__filename, { workerData: [m.buffer, cv.buffer, data.buffer], stdout: true, }); // pipe stdout for console.log in worker worker.stdout.pipe(process.stdout); // send data to the worker m.lock(); try { data.ready = 1; console.log(\"main is ready\"); } finally { m.unlock(); } // notify the waiting worker cv.notifyOne(); m.lock(); try { // release the lock and wait for the worker to finish processing cv.wait(m, () => data.processed === 1); } finally { m.unlock(); } } if (isMainThread) { main(); } else { worker_thread(); }"
  },
  "api/threading-autoresetevent.html": {
    "href": "api/threading-autoresetevent.html",
    "title": "Package @esfx/threading-autoresetevent | @esfx API Reference",
    "keywords": "Package @esfx/threading-autoresetevent Provides the AutoResetEvent class, a threading primitive for use with Workers. Overview Installation Usage Installation npm i @esfx/threading-autoresetevent Usage TypeScript JavaScript (CommonJS) import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; import { createInterface } from \"readline\"; import { AutoResetEvent } from \"@esfx/threading-autoresetevent\"; function worker_thread() { const workerReadyEvent = new AutoResetEvent(workerData[0]); const continueEvent = new AutoResetEvent(workerData[1]); // signal the main thread we are ready workerReadyEvent.set(); let count = 0; while (true) { // wait for the main thread to set 'continueEvent' continueEvent.wait(); parentPort.postMessage(`counter=${count++}`); } } function main() { // create two AutoResetEvents in the main thread const workerReadyEvent = new AutoResetEvent(); const continueEvent = new AutoResetEvent(); // create a Worker, passing the buffers of the two events const worker = new Worker(__filename, { workerData: [workerReadyEvent.buffer, continueEvent.buffer] }); // wait for the worker to tell us it is ready workerReadyEvent.wait(); console.log(\"worker is ready. Press ENTER to continue the worker...\"); worker.on(\"message\", message => { console.log(`worker says: ${message}`); }); const rl = createInterface({ input: process.stdin, output: process.stdout }); rl.on(\"line\", () => { // event is automatically reset as soon as a single waiter is signaled continueEvent.set(); }); } if (isMainThread) { main(); } else { worker_thread(); } const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const { createInterface } = require(\"readline\"); const { AutoResetEvent } = require(\"@esfx/threading-autoresetevent\"); function worker_thread() { const workerReadyEvent = new AutoResetEvent(workerData[0]); const continueEvent = new AutoResetEvent(workerData[1]); // signal the main thread we are ready workerReadyEvent.set(); let count = 0; while (true) { // wait for the main thread to set 'continueEvent' continueEvent.wait(); parentPort.postMessage(`counter=${count++}`); } } function main() { // create two AutoResetEvents in the main thread const workerReadyEvent = new AutoResetEvent(); const continueEvent = new AutoResetEvent(); // create a Worker, passing the buffers of the two events const worker = new Worker(__filename, { workerData: [workerReadyEvent.buffer, continueEvent.buffer] }); // wait for the worker to tell us it is ready workerReadyEvent.wait(); console.log(\"worker is ready. Press ENTER to continue the worker...\"); worker.on(\"message\", message => { console.log(`worker says: ${message}`); }); const rl = createInterface({ input: process.stdin, output: process.stdout }); rl.on(\"line\", () => { // event is automatically reset as soon as a single waiter is signaled continueEvent.set(); }); } if (isMainThread) { main(); } else { worker_thread(); }"
  },
  "api/metadata-shim.html": {
    "href": "api/metadata-shim.html",
    "title": "Package @esfx/metadata-shim | @esfx API Reference",
    "keywords": "Package @esfx/metadata-shim Provides a global shim that adds minimal @esfx/metadata functionality to the Reflect global object. This provides partial compatibility with TypeScript's --emitDecoratorMetadata flag. Overview Installation Usage Installation npm i @esfx/metadata-shim Usage TypeScript import \"@esfx/metadata-shim\"; import { getMemberMetadata } from \"@esfx/metadata\"; // TypeScript compiled with --emitDecoratorMetadata class MyClass { @someDecorator method(x: number): string { return \"\"; } } const c = new MyClass(); getMemberMetadata(c, \"method\", \"design:returntype\"); // String getMemberMetadata(c, \"method\", \"design:paramtypes\"); // [Number]"
  },
  "api/lazy.html": {
    "href": "api/lazy.html",
    "title": "Package @esfx/lazy | @esfx API Reference",
    "keywords": "Package @esfx/lazy Provides a class to simplify lazy-initialization logic. Overview Installation Usage Installation npm i @esfx/lazy Usage TypeScript JavaScript (CommonJS) import { Lazy } from \"@esfx/lazy\"; // lazy initialize an object const lazy1 = new Lazy(() => new SomeObject()); lazy1.hasValue; // false lazy1.value; // SomeObject {} lazy1.hasValue; // true // lazy initialize with arguments const lazy2 = Lazy.from((a, b) => a + b, 1, 2); lazy2.hasValue; // false lazy2.value; // 3 lazy2.hasValue; // true // initialized \"lazy\" const lazy3 = Lazy.for(\"test\"); lazy3.hasValue; // true lazy3.value; // \"test\" const { Lazy } = require(\"@esfx/lazy\"); // lazy initialize an object const lazy1 = new Lazy(() => new SomeObject()); lazy1.hasValue; // false lazy1.value; // SomeObject {} lazy1.hasValue; // true // lazy initialize with arguments const lazy2 = Lazy.from((a, b) => a + b, 1, 2); lazy2.hasValue; // false lazy2.value; // 3 lazy2.hasValue; // true // initialized \"lazy\" const lazy3 = Lazy.for(\"test\"); lazy3.hasValue; // true lazy3.value; // \"test\""
  },
  "api/disposable.html": {
    "href": "api/disposable.html",
    "title": "Package @esfx/disposable | @esfx API Reference",
    "keywords": "Package @esfx/disposable Provides a low-level API for defining explicit resource management that third-party libraries can use to interoperate. Overview Installation Usage Installation npm i @esfx/disposable Usage TypeScript JavaScript (CommonJS) import { Disposable } from \"@esfx/disposable\"; class MyFileResouce { private _handle?: number; constructor() { this._handle = fs.openSync(\"path/to/file\"); } close() { if (this._handle !== undefined) { fs.closeSync(this._handle); this._handle = undefined; } } // provide low-level 'dispose' primitive for interop [Disposable.dispose]() { this.close(); } } const { Disposable } = require(\"@esfx/disposable\"); class MyFileResouce { constructor() { this._handle = fs.openSync(\"path/to/file\"); } close() { if (this._handle !== undefined) { fs.closeSync(this._handle); this._handle = undefined; } } // provide low-level 'dispose' primitive for interop [Disposable.dispose]() { this.close(); } }"
  },
  "api/collection-core-shim.html": {
    "href": "api/collection-core-shim.html",
    "title": "Package @esfx/collection-core-shim | @esfx API Reference",
    "keywords": "Package @esfx/collection-core-shim Provides a global shim to add default @esfx/collection-core behaviors to global objects. Overview Installation Usage Installation npm i @esfx/collection-core-shim Usage The global shim adds a default implementation the collection interfaces to the following global objects: Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.Collection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" @\"collection-core.IndexedCollection\" Uint8Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Uint8ClampedArray implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Uint16Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Uint32Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Int8Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Int16Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Int32Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Float32Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Float64Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" BigUint64Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" BigInt64Array implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.FixedSizeIndexedCollection\" Set implements: @\"collection-core.ReadonlyCollection\" @\"collection-core.Collection\" Map implements: @\"collection-core.ReadonlyKeyedCollection\" @\"collection-core.KeyedCollection\" To install the global shim, import @esfx/collection-core-shim : TypeScript JavaScript (CommonJS) import \"@esfx/collection-core-shim\"; // triggers global-scope side effects import { Collection } from \"@esfx/collection-core\"; [1, 2, 3][Collection.size]; // 3 require(\"@esfx/collection-core-shim\"); // triggers global-scope side effects const { Collection } = require(\"@esfx/collection-core\"); [1, 2, 3][Collection.size]; // 3"
  },
  "api/cancelable-dom-shim.html": {
    "href": "api/cancelable-dom-shim.html",
    "title": "Package @esfx/cancelable-dom-shim | @esfx API Reference",
    "keywords": "Package @esfx/cancelable-dom-shim The @esfx/cancelable-dom-shim package provides a global shim to make the DOM AbortController and AbortSignal classes compatible with @esfx/cancelable . Overview Installation Usage Installation npm i @esfx/cancelable-dom-shim Usage The global shim adds a default implementation the collection interfaces to the following global DOM objects: AbortController implements: @\"cancelable.CancelableSource\" @\"cancelable.Cancelable\" AbortSignal implements: @\"cancelable.Cancelable\" To install the global shim, import @esfx/cancelable/global : TypeScript JavaScript (CommonJS) import \"@esfx/cancelable-dom-shim\"; // triggers global-scope side effects import { Cancelable } from \"@esfx/cancelable\"; const abortController = new AbortController(); const signal = abortController[Cancelable.cancelSignal](); require(\"@esfx/cancelable-dom-shim\"); // triggers global-scope side effects const { Cancelable } = require(\"@esfx/cancelable\"); const abortController = new AbortController(); const signal = abortController[Cancelable.cancelSignal]();"
  },
  "api/async.html": {
    "href": "api/async.html",
    "title": "Package @esfx/async | @esfx API Reference",
    "keywords": "Package @esfx/async Provides a number of asynchronous coordination primitives from the following packages: @esfx/async-autoresetevent @esfx/async-barrier @esfx/async-canceltoken @esfx/async-conditionvariable @esfx/async-countdown @esfx/async-deferred @esfx/async-delay @esfx/async-lazy @esfx/async-lockable @esfx/async-manualresetevent @esfx/async-mutex @esfx/async-queue @esfx/async-readerwriterlock @esfx/async-semaphore @esfx/async-stack @esfx/async-waitqueue Installation npm i @esfx/async"
  },
  "api/async-stack.html": {
    "href": "api/async-stack.html",
    "title": "Package @esfx/async-stack | @esfx API Reference",
    "keywords": "Package @esfx/async-stack The @esfx/async-stack package provides the AsyncStack class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-stack Usage TypeScript JavaScript (CommonJS) import { AsyncStack } from \"@esfx/async-stack\"; async function main() { const stack = new AsyncStack<number>(); // push two items on the stack stack.push(1); stack.push(Promise.resolve(2)); // take two items from the stack await stack.pop(); // 2 await stack.pop(); // 1 // take two more pending items from the stack const p3 = stack.get(); const p4 = stack.get(); // put two more items on the stack stack.put(3); stack.put(4); await p3; // 3 await p4; // 4 } const { AsyncStack } = require(\"@esfx/async-stack\"); async function main() { const stack = new AsyncStack(); // push two items on the stack stack.push(1); stack.push(Promise.resolve(2)); // take two items from the stack await stack.pop(); // 2 await stack.pop(); // 1 // take two more pending items from the stack const p3 = stack.get(); const p4 = stack.get(); // put two more items on the stack stack.put(3); stack.put(4); await p3; // 3 await p4; // 4 }"
  },
  "api/async-readerwriterlock.html": {
    "href": "api/async-readerwriterlock.html",
    "title": "Package @esfx/async-readerwriterlock | @esfx API Reference",
    "keywords": "Package @esfx/async-readerwriterlock The @esfx/async-readerwriterlock package provides the AsyncReaderWriterLock class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-readerwriterlock Usage TypeScript JavaScript (CommonJS) import { AsyncReaderWriterLock } from \"@esfx/async-readerwriterlock\"; interface User { id: string, name: string, email: string } // 'rwlock' protects access to 'userCache' and data stored on disk const rwlock = new AsyncReaderWriterLock(); const userCache = new Map<string, User>(); async function getUser(id: string) { // get read access const lk = await rwlock.read(); try { let user = userCache.get(id); if (!user) { user = await readUserFromDisk(id); userCache.set(id, user); } return user; } finally { // release read access lk.unlock(); } } async function addUser(user: User) { // get write access const lk = await rwlock.write(); try { userCache.set(user.id, user); await writeUserToDisk(user.id, user); } finally { // release write access lk.unlock(); } } async function updateUser(id: string, oldData: User, newData: User) { // get upgradeable read access const lk = await rwlock.upgradeableRead(); try { // verify that we are ok to make changes... let user = userCache.get(id); if (!user || user.name === oldData.name && user.email === oldData.email) { // looks safe, so upgrade to a write lock const updlk = await lk.upgrade(); try { if (!user) { user = { id } as User; userCache.set(id, user); } user.name = newData.name; user.email = newData.email; await writeUserToDisk(user.id, user); } finally { updlk.unlock(); // release the write lock } } } finally { lk.unlock(); // release the read lock } } const { AsyncReaderWriterLock } = require(\"@esfx/async-readerwriterlock\"); // 'rwlock' protects access to 'userCache' and data stored on disk const rwlock = new AsyncReaderWriterLock(); const userCache = new Map(); async function getUser(id) { // get read access const lk = await rwlock.read(); try { let user = userCache.get(id); if (!user) { user = await readUserFromDisk(id); userCache.set(id, user); } return user; } finally { // release read access lk.unlock(); } } async function addUser(user) { // get write access const lk = await rwlock.write(); try { userCache.set(user.id, user); await writeUserToDisk(user.id, user); } finally { // release write access lk.unlock(); } } async function updateUser(id, oldData, newData) { // get upgradeable read access const lk = await rwlock.upgradeableRead(); try { // verify that we are ok to make changes... let user = userCache.get(id); if (!user || user.name === oldData.name && user.email === oldData.email) { // looks safe, so upgrade to a write lock const updlk = await lk.upgrade(); try { if (!user) { user = { id }; userCache.set(id, user); } user.name = newData.name; user.email = newData.email; await writeUserToDisk(user.id, user); } finally { updlk.unlock(); // release the write lock } } } finally { lk.unlock(); // release the read lock } }"
  },
  "api/async-mutex.html": {
    "href": "api/async-mutex.html",
    "title": "Package @esfx/async-mutex | @esfx API Reference",
    "keywords": "Package @esfx/async-mutex Provides the AsyncMutex class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-mutex Usage TypeScript JavaScript (CommonJS) import { AsyncMutex } from \"@esfx/async-mutex\"; const m = new AsyncMutex(); let counter = 0; async function worker() { for (let i = 0; i < 3; i++) { // get exclusive access to 'm', which protects 'counter'. const lk = await m.lock(); try { const current = counter; await doSomethingElse(); // we still have exclusive access to 'm', which protects 'counter'. counter = current + 1; } finally { // release the lock lk.unlock(); } } } async function main() { // start two workers that share a resource await Promise.all([worker(), worker()]); counter; // 6 } const { AsyncMutex } = require(\"@esfx/async-mutex\"); const m = new AsyncMutex(); let counter = 0; async function worker() { for (let i = 0; i < 3; i++) { // get exclusive access to 'm', which protects 'counter'. const lk = await m.lock(); try { const current = counter; await doSomethingElse(); // we still have exclusive access to 'm', which protects 'counter'. counter = current + 1; } finally { // release the lock lk.unlock(); } } } async function main() { // start two workers that share a resource await Promise.all([worker(), worker()]); counter; // 6 }"
  },
  "api/async-lockable.html": {
    "href": "api/async-lockable.html",
    "title": "Package @esfx/async-lockable | @esfx API Reference",
    "keywords": "Package @esfx/async-lockable A low-level Symbol-based common API for async coordination primitives. Overview Installation Installation npm i @esfx/async-lockable"
  },
  "api/async-delay.html": {
    "href": "api/async-delay.html",
    "title": "Package @esfx/async-delay | @esfx API Reference",
    "keywords": "Package @esfx/async-delay The @esfx/async-delay package provides the @\"async-delay.delay\" function. Overview Installation Usage Installation npm i @esfx/async-delay Usage TypeScript JavaScript (CommonJS) import { delay } from \"@esfx/async-delay\"; async function doSomeAction() { // wait 10 seconds await delay(10 * 1000); } const { delay } = require(\"@esfx/async-delay\"); async function doSomeAction() { // wait 10 seconds await delay(10 * 1000); } Functions delay(msec) Waits the specified number of milliseconds before resolving. Declaration export declare function delay(msec: number): Promise<void>; Parameters msec number Returns Promise <void> delay(msec, value) Waits the specified number of milliseconds before resolving with the provided value. Declaration export declare function delay<T>(msec: number, value: T | PromiseLike<T>): Promise<T>; Parameters msec number value T | PromiseLike < T > Returns Promise < T > delay(cancelable, msec) Waits the specified number of milliseconds before resolving. Declaration export declare function delay(cancelable: Cancelable, msec: number): Promise<void>; Parameters cancelable Cancelable msec number Returns Promise <void> delay(cancelable, msec, value) Waits the specified number of milliseconds before resolving with the provided value. Declaration export declare function delay<T>(cancelable: Cancelable, msec: number, value: T | PromiseLike<T>): Promise<T>; Parameters cancelable Cancelable msec number value T | PromiseLike < T > Returns Promise < T >"
  },
  "api/collection-core/readonlykeyedmulticollection_namespace.html": {
    "href": "api/collection-core/readonlykeyedmulticollection_namespace.html",
    "title": "Namespace ReadonlyKeyedMultiCollection | @esfx API Reference",
    "keywords": "Namespace ReadonlyKeyedMultiCollection Functions isReadonlyKeyedMultiCollection(value) Tests whether a value supports the minimal representation of a ReadonlyKeyedMultiCollection <!-- --> . Declaration function isReadonlyKeyedMultiCollection<K, V>(value: Iterable<[K, V]>): value is ReadonlyKeyedMultiCollection<K, V>; Parameters value Iterable <[ K , V ]> Returns value is ReadonlyKeyedMultiCollection < K , V > isReadonlyKeyedMultiCollection(value) Tests whether a value supports the minimal representation of a ReadonlyKeyedMultiCollection <!-- --> . Declaration function isReadonlyKeyedMultiCollection(value: unknown): value is ReadonlyKeyedMultiCollection<unknown, unknown>; Parameters value unknown Returns value is ReadonlyKeyedMultiCollection <unknown, unknown> Variables get A well-known symbol used to define the ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.get] method. Declaration get: unique symbol Type unique symbol has A well-known symbol used to define the ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.has] method. Declaration has: unique symbol Type unique symbol hasValue A well-known symbol used to define the ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.hasValue] method. Declaration hasValue: unique symbol Type unique symbol keys A well-known symbol used to define the ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.keys] method. Declaration keys: unique symbol Type unique symbol size A well-known symbol used to define the ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.size] property. Declaration size: unique symbol Type unique symbol values A well-known symbol used to define the ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.values] method. Declaration values: unique symbol Type unique symbol"
  },
  "api/collection-core/readonlykeyedmulticollection_interface.html": {
    "href": "api/collection-core/readonlykeyedmulticollection_interface.html",
    "title": "Interface ReadonlyKeyedMultiCollection | @esfx API Reference",
    "keywords": "Interface ReadonlyKeyedMultiCollection Properties [ReadonlyKeyedMultiCollection.size] Gets the number of elements in the collection. Declaration readonly [ReadonlyKeyedMultiCollection.size]: number; Property Value number Methods [ReadonlyKeyedMultiCollection.get](key) Gets the value in the collection associated with the provided key, if it exists. Declaration [ReadonlyKeyedMultiCollection.get](key: K): Iterable<V> | undefined; Parameters key K Returns Iterable < V > | undefined [ReadonlyKeyedMultiCollection.has](key) Tests whether a key is present in the collection. Declaration [ReadonlyKeyedMultiCollection.has](key: K): boolean; Parameters key K Returns boolean [ReadonlyKeyedMultiCollection.hasValue](key, value) Tests whether a key and value is present in the collection. Declaration [ReadonlyKeyedMultiCollection.hasValue](key: K, value: V): boolean; Parameters key K value V Returns boolean [ReadonlyKeyedMultiCollection.keys]() Gets an IterableIterator for the keys present in the collection. Declaration [ReadonlyKeyedMultiCollection.keys](): IterableIterator<K>; Returns IterableIterator < K > [ReadonlyKeyedMultiCollection.values]() Gets an IterableIterator for the values present in the collection. Declaration [ReadonlyKeyedMultiCollection.values](): IterableIterator<V>; Returns IterableIterator < V >"
  },
  "api/collection-core/readonlykeyedcollection_namespace.html": {
    "href": "api/collection-core/readonlykeyedcollection_namespace.html",
    "title": "Namespace ReadonlyKeyedCollection | @esfx API Reference",
    "keywords": "Namespace ReadonlyKeyedCollection Functions isReadonlyKeyedCollection(value) Tests whether a value supports the minimal representation of a ReadonlyKeyedCollection <!-- --> . Declaration function isReadonlyKeyedCollection<K, V>(value: Iterable<[K, V]>): value is ReadonlyKeyedCollection<K, V>; Parameters value Iterable <[ K , V ]> Returns value is ReadonlyKeyedCollection < K , V > isReadonlyKeyedCollection(value) Tests whether a value supports the minimal representation of a ReadonlyKeyedCollection <!-- --> . Declaration function isReadonlyKeyedCollection(value: unknown): value is ReadonlyKeyedCollection<unknown, unknown>; Parameters value unknown Returns value is ReadonlyKeyedCollection <unknown, unknown> Variables get A well-known symbol used to define the ReadonlyKeyedCollection#[ReadonlyKeyedCollection.get] method. Declaration get: unique symbol Type unique symbol has A well-known symbol used to define the ReadonlyKeyedCollection#[ReadonlyKeyedCollection.has] method. Declaration has: unique symbol Type unique symbol keys A well-known symbol used to define the ReadonlyKeyedCollection#[ReadonlyKeyedCollection.keys] method. Declaration keys: unique symbol Type unique symbol size A well-known symbol used to define the ReadonlyKeyedCollection#[ReadonlyKeyedCollection.size] property. Declaration size: unique symbol Type unique symbol values A well-known symbol used to define the ReadonlyKeyedCollection#[ReadonlyKeyedCollection.values] method. Declaration values: unique symbol Type unique symbol"
  },
  "api/collection-core/readonlykeyedcollection_interface.html": {
    "href": "api/collection-core/readonlykeyedcollection_interface.html",
    "title": "Interface ReadonlyKeyedCollection | @esfx API Reference",
    "keywords": "Interface ReadonlyKeyedCollection Properties [ReadonlyKeyedCollection.size] Gets the number of elements in the collection. Declaration readonly [ReadonlyKeyedCollection.size]: number; Property Value number Methods [ReadonlyKeyedCollection.get](key) Gets the value in the collection associated with the provided key, if it exists. Declaration [ReadonlyKeyedCollection.get](key: K): V | undefined; Parameters key K Returns V | undefined [ReadonlyKeyedCollection.has](key) Tests whether a key is present in the collection. Declaration [ReadonlyKeyedCollection.has](key: K): boolean; Parameters key K Returns boolean [ReadonlyKeyedCollection.keys]() Gets an IterableIterator for the keys present in the collection. Declaration [ReadonlyKeyedCollection.keys](): IterableIterator<K>; Returns IterableIterator < K > [ReadonlyKeyedCollection.values]() Gets an IterableIterator for the values present in the collection. Declaration [ReadonlyKeyedCollection.values](): IterableIterator<V>; Returns IterableIterator < V >"
  },
  "api/collection-core/readonlyindexedcollection_namespace.html": {
    "href": "api/collection-core/readonlyindexedcollection_namespace.html",
    "title": "Namespace ReadonlyIndexedCollection | @esfx API Reference",
    "keywords": "Namespace ReadonlyIndexedCollection Functions isReadonlyIndexedCollection(value) Tests whether a value supports the minimal representation of a ReadonlyIndexedCollection <!-- --> . Declaration function isReadonlyIndexedCollection<T>(value: Iterable<T>): value is ReadonlyIndexedCollection<T>; Parameters value Iterable < T > Returns value is ReadonlyIndexedCollection < T > isReadonlyIndexedCollection(value) Tests whether a value supports the minimal representation of a ReadonlyIndexedCollection <!-- --> . Declaration function isReadonlyIndexedCollection(value: unknown): value is ReadonlyIndexedCollection<unknown>; Parameters value unknown Returns value is ReadonlyIndexedCollection <unknown> Variables getAt A well-known symbol used to define the ReadonlyIndexedCollection#[ReadonlyIndexedCollection.getAt] method. Declaration getAt: unique symbol Type unique symbol indexOf A well-known symbol used to define the ReadonlyIndexedCollection#[ReadonlyIndexedCollection.indexOf] method. Declaration indexOf: unique symbol Type unique symbol"
  },
  "api/collection-core/readonlyindexedcollection_interface.html": {
    "href": "api/collection-core/readonlyindexedcollection_interface.html",
    "title": "Interface ReadonlyIndexedCollection | @esfx API Reference",
    "keywords": "Interface ReadonlyIndexedCollection Methods [ReadonlyIndexedCollection.getAt](index) Gets the value at the specified index in the collection, or undefined if the index was outside of the bounds of the collection. Declaration [ReadonlyIndexedCollection.getAt](index: number): T | undefined; Parameters index number Returns T | undefined [ReadonlyIndexedCollection.indexOf](value, fromIndex) Gets the index for a value in the collection, or -1 if the value was not found. Declaration [ReadonlyIndexedCollection.indexOf](value: T, fromIndex?: number): number; Parameters value T fromIndex number Returns number"
  },
  "api/collection-core/fixedsizeindexedcollection_namespace.html": {
    "href": "api/collection-core/fixedsizeindexedcollection_namespace.html",
    "title": "Namespace FixedSizeIndexedCollection | @esfx API Reference",
    "keywords": "Namespace FixedSizeIndexedCollection Functions isFixedSizeIndexedCollection(value) Tests whether a value supports the minimal representation of a FixedSizeIndexedCollection <!-- --> . Declaration function isFixedSizeIndexedCollection<T>(value: Iterable<T>): value is FixedSizeIndexedCollection<T>; Parameters value Iterable < T > Returns value is FixedSizeIndexedCollection < T > isFixedSizeIndexedCollection(value) Tests whether a value supports the minimal representation of a FixedSizeIndexedCollection <!-- --> . Declaration function isFixedSizeIndexedCollection(value: unknown): value is FixedSizeIndexedCollection<unknown>; Parameters value unknown Returns value is FixedSizeIndexedCollection <unknown> Variables setAt A well-known symbol used to define the FixedSizeIndexedCollection#[FixedSizeIndexedCollection.setAt] method. Declaration setAt: unique symbol Type unique symbol"
  },
  "api/collection-core/fixedsizeindexedcollection_interface.html": {
    "href": "api/collection-core/fixedsizeindexedcollection_interface.html",
    "title": "Interface FixedSizeIndexedCollection | @esfx API Reference",
    "keywords": "Interface FixedSizeIndexedCollection Methods [FixedSizeIndexedCollection.setAt](index, value) Sets a value at the specified index in the collection. Declaration [FixedSizeIndexedCollection.setAt](index: number, value: T): boolean; Parameters index number value T Returns boolean true if the value was set at the provided index, otherwise false <!-- --> ."
  },
  "api/collection-core/collection_namespace.html": {
    "href": "api/collection-core/collection_namespace.html",
    "title": "Namespace Collection | @esfx API Reference",
    "keywords": "Namespace Collection Functions isCollection(value) Tests whether a value supports the minimal representation of a Collection <!-- --> . Declaration function isCollection<T>(value: Iterable<T>): value is Collection<T>; Parameters value Iterable < T > Returns value is Collection < T > isCollection(value) Tests whether a value supports the minimal representation of a Collection <!-- --> . Declaration function isCollection(value: any): value is Collection<unknown>; Parameters value any Returns value is Collection <unknown> Variables | Improve this Doc delete A well-known symbol used to define the Collection#[Collection.delete] method. Declaration delete: unique symbol Type unique symbol add A well-known symbol used to define the Collection#[Collection.add] method. Declaration add: unique symbol Type unique symbol clear A well-known symbol used to define the Collection#[Collection.clear] method. Declaration clear: unique symbol Type unique symbol"
  },
  "api/collection-core/collection_interface.html": {
    "href": "api/collection-core/collection_interface.html",
    "title": "Interface Collection | @esfx API Reference",
    "keywords": "Interface Collection Methods [Collection.add](value) Adds an element to the collection. Declaration [Collection.add](value: T): void; Parameters value T Returns void [Collection.clear]() Clears the collection. Declaration [Collection.clear](): void; Returns void [Collection.delete](value) Deletes an element from the collection. Declaration [Collection.delete](value: T): boolean; Parameters value T Returns boolean"
  },
  "api/cancelable/cancelable_namespace.html": {
    "href": "api/cancelable/cancelable_namespace.html",
    "title": "Namespace Cancelable | @esfx API Reference",
    "keywords": "Namespace Cancelable Functions isCancelable(value) Determines whether a value is a Cancelable object. Declaration function isCancelable(value: unknown): value is Cancelable; Parameters value unknown Returns value is Cancelable isSignaled(cancelable) Determines whether cancelable is in the signaled state. Declaration function isSignaled(cancelable: Cancelable | undefined): boolean; Parameters cancelable Cancelable | undefined Returns boolean subscribe(cancelable, onSignaled) Subscribes to be notified when a cancelable becomes signaled. Declaration function subscribe(cancelable: Cancelable | undefined, onSignaled: () => void): CancelSubscription; Parameters cancelable Cancelable | undefined onSignaled () => void Returns CancelSubscription throwIfSignaled(cancelable) Throws a CancelError exception if the provided cancelable is in the signaled state. Declaration function throwIfSignaled(cancelable: Cancelable | undefined): void; Parameters cancelable Cancelable | undefined Returns void Variables canceled A Cancelable that is already signaled. Declaration canceled: CancelableCancelSignal Type CancelableCancelSignal cancelSignal A well-known symbol used to define a method to retrieve the CancelSignal for an object. Declaration cancelSignal: unique symbol Type unique symbol none A Cancelable that can never be signaled. Declaration none: CancelableCancelSignal Type CancelableCancelSignal"
  },
  "api/cancelable/cancelable_interface.html": {
    "href": "api/cancelable/cancelable_interface.html",
    "title": "Interface Cancelable | @esfx API Reference",
    "keywords": "Interface Cancelable An object that can be canceled from an external source. Methods [Cancelable.cancelSignal]() Gets the [[CancelSignal]] for this [[Cancelable]]. Declaration [Cancelable.cancelSignal](): CancelSignal; Returns CancelSignal"
  },
  "api/threading.html": {
    "href": "api/threading.html",
    "title": "Package @esfx/threading | @esfx API Reference",
    "keywords": "Package @esfx/threading Provides a number Thread synchronization primitives for use with Workers from the following packages: @esfx/threading-autoresetevent @esfx/threading-conditionvariable @esfx/threading-countdown @esfx/threading-lockable @esfx/threading-manualresetevent @esfx/threading-mutex @esfx/threading-semaphore @esfx/threading-sleep @esfx/threading-spinwait Installation npm i @esfx/threading"
  },
  "api/threading-manualresetevent.html": {
    "href": "api/threading-manualresetevent.html",
    "title": "Package @esfx/threading-manualresetevent | @esfx API Reference",
    "keywords": "Package @esfx/threading-manualresetevent Provides the ManualResetEvent class, a threading primitive for use with Workers. Overview Installation Usage Installation npm i @esfx/threading-manualresetevent Usage TypeScript JavaScript (CommonJS) import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; import { createInterface } from \"readline\"; import { ManualResetEvent } from \"@esfx/threading-manualresetevent\"; import { sleep } from \"@esfx/threading-sleep\"; function worker_thread() { const mre = new ManualResetEvent(workerData); let count = 0; while (true) { mre.wait(); // wait until signaled console.log(`counter: ${count++}`); sleep(500); } } function main() { const mre = new ManualResetEvent(); const worker = new Worker(__filename, { workerData: mre.buffer, stdout: true }); worker.stdout.pipe(process.stdout); console.log(\"Press ENTER to start counter:\"); const rl = createInterface({ input: process.stdin, output: process.stdout }); rl.on(\"line\", () => { if (mre.isSet) { mre.reset(); console.log(\"Press ENTER to start counter:\"); } else { console.log(\"Press ENTER to stop counter:\"); mre.set(); } }); } if (isMainThread) { main(); } else { worker_thread(); } const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const { createInterface } = require(\"readline\"); const { ManualResetEvent } = require(\"@esfx/threading-manualresetevent\"); const { sleep } = require(\"@esfx/threading-sleep\"); function worker_thread() { const mre = new ManualResetEvent(workerData); let count = 0; while (true) { mre.wait(); // wait until signaled console.log(`counter: ${count++}`); sleep(500); } } function main() { const mre = new ManualResetEvent(); const worker = new Worker(__filename, { workerData: mre.buffer, stdout: true }); worker.stdout.pipe(process.stdout); console.log(\"Press ENTER to start counter:\"); const rl = createInterface({ input: process.stdin, output: process.stdout }); rl.on(\"line\", () => { if (mre.isSet) { mre.reset(); console.log(\"Press ENTER to start counter:\"); } else { console.log(\"Press ENTER to stop counter:\"); mre.set(); } }); } if (isMainThread) { main(); } else { worker_thread(); }"
  },
  "api/threading-lockable.html": {
    "href": "api/threading-lockable.html",
    "title": "Package @esfx/threading-lockable | @esfx API Reference",
    "keywords": "Package @esfx/threading-lockable A low-level Symbol-based API for defining locking semantics for thread synchronization primitives for Workers. Installation npm i @esfx/threading-lockable"
  },
  "api/threading-countdown.html": {
    "href": "api/threading-countdown.html",
    "title": "Package @esfx/threading-countdown | @esfx API Reference",
    "keywords": "Package @esfx/threading-countdown Provides the CountdownEvent class, a thread synchronization primitive for use with Workers. Overview Installation Usage Installation npm i @esfx/threading-countdown Usage TypeScript JavaScript (CommonJS) import { Worker, isMainThread, parentPort, workerData } from \"worker_threads\"; import { CountdownEvent } from \"@esfx/threading-countdown\"; function worker_thread() { const countdown = new CountdownEvent(workerData); // do work in background... // signal worker is finished countdown.signal(); } function main() { const countdown = new CountdownEvent(5); // start 5 workers for (let i = 0; i < 5; i++) { new Worker(__filename, { workerData: countdown.buffer }); } // wait for the workers to finish countdown.wait(); } if (isMainThread) { main(); } else { worker_thread(); } const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\"); const { CountdownEvent } = require(\"@esfx/threading-countdown\"); function worker_thread() { const countdown = new CountdownEvent(workerData); // do work in background... // signal worker is finished countdown.signal(); } function main() { const countdown = new CountdownEvent(5); // start 5 workers for (let i = 0; i < 5; i++) { new Worker(__filename, { workerData: countdown.buffer }); } // wait for the workers to finish countdown.wait(); } if (isMainThread) { main(); } else { worker_thread(); }"
  },
  "api/threading-mutex/mutex.html": {
    "href": "api/threading-mutex/mutex.html",
    "title": "Class Mutex | @esfx API Reference",
    "keywords": "Class Mutex Constructors constructor(initiallyOwned) Constructs a new instance of the Mutex class Declaration constructor(initiallyOwned?: boolean); Parameters initiallyOwned boolean constructor(buffer, byteOffset) Constructs a new instance of the Mutex class Declaration constructor(buffer: SharedArrayBuffer, byteOffset?: number); Parameters buffer SharedArrayBuffer byteOffset number Properties buffer Declaration readonly buffer: SharedArrayBuffer; Property Value SharedArrayBuffer byteLength Declaration readonly byteLength: number; Property Value number byteOffset Declaration readonly byteOffset: number; Property Value number isLocked Declaration readonly isLocked: boolean; Property Value boolean ownsLock Declaration readonly ownsLock: boolean; Property Value boolean SIZE Declaration static readonly SIZE = 12; Methods [Disposable.dispose]() Declaration [Disposable.dispose](): void; Returns void [Lockable.lock](ms) Declaration [Lockable.lock](ms?: number): boolean; Parameters ms number Returns boolean [Lockable.tryLock]() Declaration [Lockable.tryLock](): boolean; Returns boolean [Lockable.unlock]() Declaration [Lockable.unlock](): boolean; Returns boolean close() Declaration close(): void; Returns void lock(ms) Declaration lock(ms?: number): boolean; Parameters ms number Returns boolean tryLock() Declaration tryLock(): boolean; Returns boolean unlock() Declaration unlock(): boolean; Returns boolean"
  },
  "api/threading-conditionvariable/conditionvariable.html": {
    "href": "api/threading-conditionvariable/conditionvariable.html",
    "title": "Class ConditionVariable | @esfx API Reference",
    "keywords": "Class ConditionVariable Constructors constructor(buffer, byteOffset) Constructs a new instance of the ConditionVariable class Declaration constructor(buffer?: SharedArrayBuffer, byteOffset?: number); Parameters buffer SharedArrayBuffer byteOffset number Properties buffer Declaration readonly buffer: SharedArrayBuffer; Property Value SharedArrayBuffer byteLength Declaration readonly byteLength: number; Property Value number byteOffset Declaration readonly byteOffset: number; Property Value number SIZE Declaration static readonly SIZE = 4; Methods [Disposable.dispose]() Declaration [Disposable.dispose](): void; Returns void close() Declaration close(): void; Returns void notifyAll() Declaration notifyAll(): number; Returns number notifyOne() Declaration notifyOne(): boolean; Returns boolean wait(mutex, condition) Declaration wait(mutex: Lockable, condition?: () => boolean): boolean; Parameters mutex Lockable condition () => boolean Returns boolean waitFor(mutex, ms, condition) Declaration waitFor(mutex: Lockable, ms: number, condition?: () => boolean): boolean; Parameters mutex Lockable ms number condition () => boolean Returns boolean"
  },
  "api/threading-autoresetevent/autoresetevent.html": {
    "href": "api/threading-autoresetevent/autoresetevent.html",
    "title": "Class AutoResetEvent | @esfx API Reference",
    "keywords": "Class AutoResetEvent Constructors constructor(initialState) Constructs a new instance of the AutoResetEvent class Declaration constructor(initialState?: boolean); Parameters initialState boolean constructor(buffer, byteOffset) Constructs a new instance of the AutoResetEvent class Declaration constructor(buffer: SharedArrayBuffer, byteOffset?: number); Parameters buffer SharedArrayBuffer byteOffset number Properties buffer Declaration readonly buffer: SharedArrayBuffer; Property Value SharedArrayBuffer byteLength Declaration readonly byteLength: number; Property Value number byteOffset Declaration readonly byteOffset: number; Property Value number SIZE Declaration static readonly SIZE = 4; Methods [Disposable.dispose]() Declaration [Disposable.dispose](): void; Returns void close() Declaration close(): void; Returns void reset() Declaration reset(): boolean; Returns boolean set() Declaration set(): boolean; Returns boolean waitOne(ms) Declaration waitOne(ms?: number): boolean; Parameters ms number Returns boolean"
  },
  "api/struct-type/structclass.html": {
    "href": "api/struct-type/structclass.html",
    "title": "Interface StructClass | @esfx API Reference",
    "keywords": "Interface StructClass Properties [kFields] Declaration [kFields]: TDef; Property Value TDef SIZE Declaration readonly SIZE: number; Property Value number"
  },
  "api/ref/reference.html": {
    "href": "api/ref/reference.html",
    "title": "Interface Reference | @esfx API Reference",
    "keywords": "Interface Reference A reference to a lexical value. Properties [Symbol.toStringTag] Declaration [Symbol.toStringTag]: string; Property Value string value Declaration value: T; Property Value T"
  },
  "api/events/eventsource.html": {
    "href": "api/events/eventsource.html",
    "title": "Class EventSource | @esfx API Reference",
    "keywords": "Class EventSource Properties event Declaration readonly event: Event<F>; Property Value Event < F > owner Declaration readonly owner: ThisParameterType<F>; Property Value ThisParameterType < F > Methods emit(args) Declaration emit(...args: Parameters<F>): boolean; Parameters args Parameters < F > Returns boolean"
  },
  "api/equatable/structuralequatable_namespace.html": {
    "href": "api/equatable/structuralequatable_namespace.html",
    "title": "Namespace StructuralEquatable | @esfx API Reference",
    "keywords": "Namespace StructuralEquatable Functions isStructuralEquatable(value) Determines whether a value is StructuralEquatable. Declaration function isStructuralEquatable(value: unknown): value is StructuralEquatable; Parameters value unknown Returns value is StructuralEquatable Variables structuralEquals A well-known symbol used to define a structural equality test method on a value. Declaration structuralEquals: unique symbol Type unique symbol structuralHash A well-known symbol used to define a structural hashing method on a value. Declaration structuralHash: unique symbol Type unique symbol"
  },
  "api/equatable/equatable_interface.html": {
    "href": "api/equatable/equatable_interface.html",
    "title": "Interface Equatable | @esfx API Reference",
    "keywords": "Interface Equatable Represents a value that can compare its equality with another value. Methods [Equatable.equals](other) Determines whether this value is equal to another value. Declaration [Equatable.equals](other: unknown): boolean; Parameters other unknown Returns boolean [Equatable.hash]() Compute a hash code for an value. Declaration [Equatable.hash](): number; Returns number"
  },
  "api/decorators-stage1-core/methodmemberdescriptor.html": {
    "href": "api/decorators-stage1-core/methodmemberdescriptor.html",
    "title": "Interface MethodMemberDescriptor | @esfx API Reference",
    "keywords": "Interface MethodMemberDescriptor Properties descriptor Declaration descriptor: MethodPropertyDescriptor<T>; Property Value MethodPropertyDescriptor < T >"
  },
  "api/collections-multimap/readonlymultimap.html": {
    "href": "api/collections-multimap/readonlymultimap.html",
    "title": "Interface ReadonlyMultiMap | @esfx API Reference",
    "keywords": "Interface ReadonlyMultiMap Properties keyEqualer Declaration readonly keyEqualer: Equaler<K>; Property Value Equaler < K > size Declaration readonly size: number; Property Value number valueEqualer Declaration readonly valueEqualer: Equaler<V>; Property Value Equaler < V > Methods entries() Declaration entries(): IterableIterator<[K, V]>; Returns IterableIterator <[ K , V ]> forEach(callback, thisArg) Declaration forEach(callback: (value: V, key: K, map: this) => void, thisArg?: any): void; Parameters callback ( value : V , key : K , map : this) => void thisArg any Returns void get(key) Declaration get(key: K): ReadonlyHashSet<V> | undefined; Parameters key K Returns ReadonlyHashSet < V > | undefined has(key, value) Declaration has(key: K, value: V): boolean; Parameters key K value V Returns boolean hasKey(key) Declaration hasKey(key: K): boolean; Parameters key K Returns boolean keys() Declaration keys(): IterableIterator<K>; Returns IterableIterator < K > values() Declaration values(): IterableIterator<V>; Returns IterableIterator < V >"
  },
  "api/collections-hashset/readonlyhashset.html": {
    "href": "api/collections-hashset/readonlyhashset.html",
    "title": "Interface ReadonlyHashSet | @esfx API Reference",
    "keywords": "Interface ReadonlyHashSet Properties equaler Declaration readonly equaler: Equaler<T>; Property Value Equaler < T > Methods [Symbol.iterator]() Declaration [Symbol.iterator](): IterableIterator<T>; Returns IterableIterator < T >"
  },
  "api/collections-hashmap/readonlyhashmap.html": {
    "href": "api/collections-hashmap/readonlyhashmap.html",
    "title": "Interface ReadonlyHashMap | @esfx API Reference",
    "keywords": "Interface ReadonlyHashMap Properties equaler Declaration readonly equaler: Equaler<K>; Property Value Equaler < K > Methods [Symbol.iterator]() Declaration [Symbol.iterator](): IterableIterator<[K, V]>; Returns IterableIterator <[ K , V ]>"
  },
  "api/type-model.html": {
    "href": "api/type-model.html",
    "title": "Package @esfx/type-model | @esfx API Reference",
    "keywords": "Package @esfx/type-model Provides a number of utility types for TypeScript. Installation npm i @esfx/type-model"
  },
  "api/async-waitqueue/waitqueue.html": {
    "href": "api/async-waitqueue/waitqueue.html",
    "title": "Class WaitQueue | @esfx API Reference",
    "keywords": "Class WaitQueue An async coordination primitive that provides a queue of Promises. Properties size Gets the number of pending entries in the queue. Declaration readonly size: number; Property Value number Methods cancelAll() Rejects all pending wait() operations with a CancelError <!-- --> . Declaration cancelAll(): number; Returns number The number of pending wait() operations that were rejected. cancelOne() Rejects the next pending wait() operation with a CancelError <!-- --> . Declaration cancelOne(): boolean; Returns boolean true if a pending wait() operation was rejected; otherwise, false <!-- --> . rejectAll(reason) Rejects all pending wait() operations with the provided reason. Declaration rejectAll(reason: unknown): number; Parameters reason unknown Returns number The number of pending wait() operations that were rejected. rejectOne(reason) Rejects the next pending wait() operation with the provided reason. Declaration rejectOne(reason: unknown): boolean; Parameters reason unknown Returns boolean true if a pending wait() operation was rejected; otherwise, false <!-- --> . resolveAll(this) Resolves all pending wait() operations with the provided value. Declaration resolveAll(this: WaitQueue<void>): number; Parameters this WaitQueue <void> Returns number The number of pending wait() operations that were resolved. resolveAll(value) Resolves all pending wait() operations with the provided value. Declaration resolveAll(value: T | PromiseLike<T>): number; Parameters value T | PromiseLike < T > Returns number The number of pending wait() operations that were resolved. resolveOne(this) Resolves a pending wait() operation with the provided value. Declaration resolveOne(this: WaitQueue<void>): boolean; Parameters this WaitQueue <void> Returns boolean true if a pending wait() operation was resolved; otherwise, false <!-- --> . resolveOne(value) Resolves a pending wait() operation with the provided value. Declaration resolveOne(value: T | PromiseLike<T>): boolean; Parameters value T | PromiseLike < T > Returns boolean true if a pending wait() operation was resolved; otherwise, false <!-- --> . wait(cancelable) Returns a Promise for the next value to be added to the queue. Declaration wait(cancelable?: Cancelable): Promise<T>; Parameters cancelable Cancelable Returns Promise < T >"
  },
  "api/async-readerwriterlock/asyncreaderwriterlock.html": {
    "href": "api/async-readerwriterlock/asyncreaderwriterlock.html",
    "title": "Class AsyncReaderWriterLock | @esfx API Reference",
    "keywords": "Class AsyncReaderWriterLock Coordinates readers and writers for a resource. Methods createReader() Creates a AsyncReaderWriterLockReader that can be used to take and release \"read\" locks on a resource. Declaration createReader(): AsyncReaderWriterLockReader; Returns AsyncReaderWriterLockReader createUpgradeableReader() Creates a AsyncReaderWriterLockUpgradeableReader that can be used to take and release \"read\" locks on a resource and can be later upgraded to take and release \"write\" locks. Declaration createUpgradeableReader(): AsyncReaderWriterLockUpgradeableReader; Returns AsyncReaderWriterLockUpgradeableReader createWriter() Creates a AsyncReaderWriterLockWriter that can be used to take and release \"write\" locks on a resource. Declaration createWriter(): AsyncReaderWriterLockWriter; Returns AsyncReaderWriterLockWriter read(cancelable) Asynchronously waits for and takes a read lock on a resource. Declaration read(cancelable?: Cancelable): Promise<AsyncReaderWriterLockReader>; Parameters cancelable Cancelable Returns Promise < AsyncReaderWriterLockReader > upgradeableRead(cancelable) Asynchronously waits for and takes a read lock on a resource that can later be upgraded to a write lock. Declaration upgradeableRead(cancelable?: Cancelable): Promise<AsyncReaderWriterLockUpgradeableReader>; Parameters cancelable Cancelable Returns Promise < AsyncReaderWriterLockUpgradeableReader > write(cancelable) Asynchronously waits for and takes a write lock on a resource. Declaration write(cancelable?: Cancelable): Promise<AsyncReaderWriterLockWriter>; Parameters cancelable Cancelable Returns Promise < AsyncReaderWriterLockWriter >"
  },
  "api/async-queue/asyncqueue.html": {
    "href": "api/async-queue/asyncqueue.html",
    "title": "Class AsyncQueue | @esfx API Reference",
    "keywords": "Class AsyncQueue An asynchronous queue. Constructors constructor(iterable) Initializes a new instance of the AsyncQueue class. Declaration constructor(iterable?: Iterable<T | PromiseLike<T>>); Parameters iterable Iterable < T | PromiseLike < T >> Properties done Gets a value indicating whether the queue has ended and there are no more items available. Declaration readonly done: boolean; Property Value boolean readable Gets a value indicating whether items can be read from the queue. Declaration readonly readable: boolean; Property Value boolean size Gets the number of entries in the queue. When positive, indicates the number of entries available to get. When negative, indicates the number of requests waiting to be fulfilled. Declaration readonly size: number; Property Value number writable Gets a value indicating whether new items can be added to the queue. Declaration readonly writable: boolean; Property Value boolean Methods doneReading() Blocks attempts to read from the queue until it is empty. Available items in the queue can still be read until the queue is empty. Declaration doneReading(): void; Returns void doneWriting() Blocks attempts to write to the queue. Pending requests in the queue can still be resolved until the queue is empty. Declaration doneWriting(): void; Returns void end() Blocks future attempts to read or write from the queue. Available items in the queue can still be read until the queue is empty. Pending reads from the queue are rejected with a CancelError <!-- --> . Declaration end(): void; Returns void get(cancelable) Removes and returns a Promise for the first value in the queue. If the queue is empty, returns a Promise for the next value to be added to the queue. Declaration get(cancelable?: Cancelable): Promise<T>; Parameters cancelable Cancelable Returns Promise < T > put(this) Adds a value to the end of the queue. If the queue is empty but has a pending dequeue request, the value will be dequeued and the request fulfilled. Declaration put(this: AsyncQueue<void>): void; Parameters this AsyncQueue <void> Returns void put(value) Adds a value to the end of the queue. If the queue is empty but has a pending dequeue request, the value will be dequeued and the request fulfilled. Declaration put(value: T | PromiseLike<T>): void; Parameters value T | PromiseLike < T > Returns void"
  },
  "api/async-mutex/asyncmutex.html": {
    "href": "api/async-mutex/asyncmutex.html",
    "title": "Class AsyncMutex | @esfx API Reference",
    "keywords": "Class AsyncMutex An async coordination primitive used to coordinate access to a protected resource. Properties isLocked Indicates whether the lock has been taken. Declaration readonly isLocked: boolean; Property Value boolean Methods [AsyncLockable.lock](cancelable) Declaration [AsyncLockable.lock](cancelable?: Cancelable): Promise<LockHandle<AsyncMutex>>; Parameters cancelable Cancelable Returns Promise < LockHandle < AsyncMutex >> [AsyncLockable.unlock]() Declaration [AsyncLockable.unlock](): void; Returns void lock(cancelable) Asynchronously waits for the lock to become available and then takes the lock. Declaration lock(cancelable?: Cancelable): Promise<LockHandle<AsyncMutex>>; Parameters cancelable Cancelable Returns Promise < LockHandle < AsyncMutex >> tryLock() Synchronously tries to take a lock. Declaration tryLock(): boolean; Returns boolean unlock() Releases the lock. Declaration unlock(): boolean; Returns boolean"
  },
  "api/async-manualresetevent/asyncmanualresetevent.html": {
    "href": "api/async-manualresetevent/asyncmanualresetevent.html",
    "title": "Class AsyncManualResetEvent | @esfx API Reference",
    "keywords": "Class AsyncManualResetEvent Asynchronously notifies one or more waiting Promises that an event has occurred. Constructors constructor(initialState) Initializes a new instance of the ManualResetEvent class. Declaration constructor(initialState?: boolean); Parameters initialState boolean Properties isSet Gets a value indicating whether the event is signaled. Declaration readonly isSet: boolean; Property Value boolean Methods reset() Sets the state of the event to nonsignaled, causing asynchronous operations to pause. Declaration reset(): void; Returns void set() Sets the state of the event to signaled, resolving one or more waiting Promises. Declaration set(): void; Returns void wait(cancelable) Asynchronously waits for the event to become signaled. Declaration wait(cancelable?: Cancelable): Promise<void>; Parameters cancelable Cancelable Returns Promise <void>"
  },
  "api/async-lockable/upgradeablelockhandle.html": {
    "href": "api/async-lockable/upgradeablelockhandle.html",
    "title": "Interface UpgradeableLockHandle | @esfx API Reference",
    "keywords": "Interface UpgradeableLockHandle An object used to release a held lock or upgrade to a stronger lock. Methods upgrade(cancelable) Upgrades the lock to a stronger lock. Declaration upgrade(cancelable?: Cancelable): Promise<LockHandle<TUpgradedMutex>>; Parameters cancelable Cancelable Returns Promise < LockHandle < TUpgradedMutex >>"
  },
  "api/async-lockable/lockhandle.html": {
    "href": "api/async-lockable/lockhandle.html",
    "title": "Interface LockHandle | @esfx API Reference",
    "keywords": "Interface LockHandle An object used to release a held lock. Properties mutex Gets the associated AsyncLockable object. Declaration readonly mutex: TMutex; Property Value TMutex ownsLock Indicates whether this handle owns its associated mutex <!-- --> . Declaration readonly ownsLock: boolean; Property Value boolean Methods lock(cancelable) Reacquires the lock. If this handle already owns the lock, an Error is thrown. Declaration lock(cancelable?: Cancelable): Promise<this>; Parameters cancelable Cancelable Returns Promise <this> unlock() Releases the lock. If this handle does not own the lock, an Error is thrown. Declaration unlock(): void; Returns void"
  },
  "api/async-semaphore.html": {
    "href": "api/async-semaphore.html",
    "title": "Package @esfx/async-semaphore | @esfx API Reference",
    "keywords": "Package @esfx/async-semaphore The @esfx/async-semaphore package provides the AsyncSemaphore class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-semaphore Usage TypeScript JavaScript (CommonJS) import { AsyncSemaphore } from \"@esfx/async-semaphore\"; // create a semaphore that allows one participant const semaphore = new AsyncSemaphore(1); async function updateResource(updates: UpdateObject) { // Wait for a lock on the semaphore await semaphore.wait(); try { // Between the 'wait' above and the 'release' below, // this function has exclusive access to a resource... // Await something async, allowing other logic to // execute. If some other event/timer/etc. calls // 'updateResource' before this async operation // finishes, they will be blocked at the 'wait' above. await doSomethingAsync(); // We still have exclusive access even after resuming, // so we can continue to use our exclusive access. } finally { // Release the semaphore. The next waiter will // be unblocked and will have the lock instead. semaphore.release(); } } const { AsyncSemaphore } = require(\"@esfx/async-semaphore\"); // create a semaphore that allows one participant const semaphore = new AsyncSemaphore(1); async function updateResource(updates) { // Wait for a lock on the semaphore await semaphore.wait(); try { // Between the 'wait' above and the 'release' below, // this function has exclusive access to a resource... // Await something async, allowing other logic to // execute. If some other event/timer/etc. calls // 'updateResource' before this async operation // finishes, they will be blocked at the 'wait' above. await doSomethingAsync(); // We still have exclusive access even after resuming, // so we can continue to use our exclusive access. } finally { // Release the semaphore. The next waiter will // be unblocked and will have the lock instead. semaphore.release(); } }"
  },
  "api/async-queue.html": {
    "href": "api/async-queue.html",
    "title": "Package @esfx/async-queue | @esfx API Reference",
    "keywords": "Package @esfx/async-queue The @esfx/async-queue package provides the AsyncQueue class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-queue Usage TypeScript JavaScript (CommonJS) import { AsyncQueue } from \"@esfx/async-queue\"; async function main() { const queue = new AsyncQueue<number>(); // put two items on the queue queue.put(1); queue.put(Promise.resolve(2)); // take two items from the queue await queue.get(); // 1 await queue.get(); // 2 // take two more pending items from the queue const p3 = queue.get(); const p4 = queue.get(); // put two more items on the queue queue.put(3); queue.put(4); await p3; // 3 await p4; // 4 } const { AsyncQueue } = require(\"@esfx/async-queue\"); async function main() { const queue = new AsyncQueue(); // put two items on the queue queue.put(1); queue.put(Promise.resolve(2)); // take two items from the queue await queue.get(); // 1 await queue.get(); // 2 // take two more pending items from the queue const p3 = queue.get(); const p4 = queue.get(); // put two more items on the queue queue.put(3); queue.put(4); await p3; // 3 await p4; // 4 }"
  },
  "api/async-manualresetevent.html": {
    "href": "api/async-manualresetevent.html",
    "title": "Package @esfx/async-manualresetevent | @esfx API Reference",
    "keywords": "Package @esfx/async-manualresetevent The @esfx/async-manualresetevent package provides the AsyncManualResetEvent class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-manualresetevent Usage TypeScript JavaScript (CommonJS) import { AsyncManualResetEvent } from \"@esfx/async-manualresetevent\"; const event = new AsyncManualResetEvent(); async function doSomeActivity() { // do some work asynchronously... // signal completion of the activity event.set(); } async function doSomeOtherActivity() { // do some work asynchronously... // wait for 'doSomeActivity' to finish await event.wait(); // keep working now that both activities have synchronized... } // start some work doSomeActivity(); // start some other work doSomeOtherActivity(); const { AsyncManualResetEvent } = require(\"@esfx/async-manualresetevent\"); const event = new AsyncManualResetEvent(); async function doSomeActivity() { // do some work asynchronously... // signal completion of the activity event.set(); } async function doSomeOtherActivity() { // do some work asynchronously... // wait for 'doSomeActivity' to finish await event.wait(); // keep working now that both activities have synchronized... } // start some work doSomeActivity(); // start some other work doSomeOtherActivity();"
  },
  "api/async-lazy.html": {
    "href": "api/async-lazy.html",
    "title": "Package @esfx/async-lazy | @esfx API Reference",
    "keywords": "Package @esfx/async-lazy Lazy-initialized asynchronous value. Overview Installation Usage Installation npm i @esfx/async-lazy Usage TypeScript JavaScript (CommonJS) import { AsyncLazy } from \"@esfx/async-lazy\"; async function main() { // lazy initialize an object const lazy1 = new AsyncLazy(() => new SomeObject()); lazy1.isStarted; // false const p1 = lazy1.value; // Promise {} lazy1.isStarted; // true await p1; // SomeObject {} // lazy initialize with arguments const lazy2 = Lazy.from( async (a, b) => (await a) + (await b), Promise.resolve(1), Promise.resolve(2)); lazy2.isStarted; // false const p2 = lazy2.value; // Promise {} lazy2.isStarted; // true await p2; // 3 // initialized \"lazy\" const lazy3 = Lazy.for(Promise.resolve(\"test\")); lazy3.isStarted; // true await lazy3.value; // \"test\" } main().catch(e => console.error(e)); const { AsyncLazy } = require(\"@esfx/async-lazy\"); async function main() { // lazy initialize an object const lazy1 = new AsyncLazy(() => new SomeObject()); lazy1.isStarted; // false const p1 = lazy1.value; // Promise {} lazy1.isStarted; // true await p1; // SomeObject {} // lazy initialize with arguments const lazy2 = Lazy.from( async (a, b) => (await a) + (await b), Promise.resolve(1), Promise.resolve(2)); lazy2.isStarted; // false const p2 = lazy2.value; // Promise {} lazy2.isStarted; // true await p2; // 3 // initialized \"lazy\" const lazy3 = Lazy.for(Promise.resolve(\"test\")); lazy3.isStarted; // true await lazy3.value; // \"test\" } main().catch(e => console.error(e));"
  },
  "api/async-deferred.html": {
    "href": "api/async-deferred.html",
    "title": "Package @esfx/async-deferred | @esfx API Reference",
    "keywords": "Package @esfx/async-deferred The @esfx/async-deferred package provides the Deferred class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-deferred Usage TypeScript JavaScript (CommonJS) import { Deferred } from \"@esfx/async-deferred\"; const deferred = new Deferred<number>(); // to resolve the deferred: deferred.resolve(1); // to reject the deferred: deferred.reject(new Error()); // get the promise for the deferred: deferred.promise; const { Deferred } = require(\"@esfx/async-deferred\"); const deferred = new Deferred(); // to resolve the deferred: deferred.resolve(1); // to reject the deferred: deferred.reject(new Error()); // get the promise for the deferred: deferred.promise;"
  },
  "api/async-autoresetevent.html": {
    "href": "api/async-autoresetevent.html",
    "title": "Package @esfx/async-autoresetevent | @esfx API Reference",
    "keywords": "Package @esfx/async-autoresetevent The @esfx/async-autoresetevent package provides the AsyncAutoResetEvent class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-autoresetevent Usage TypeScript JavaScript (CommonJS) import { AsyncAutoResetEvent } from \"@esfx/async-autoresetevent\"; const event = new AsyncAutoResetEvent(); async function doSomeActivity() { while (true) { // do some work asynchronously... // indicate 'waitForActivity' can resume. Event is immediately reset to // the signaled state. event.set(); } } async function waitForActivity() { while (true) { // wait for 'doSomeActivity' to set the event... await event.wait(); // do something asynchronous... } } doSomeActivity(); waitForActivity(); const { AsyncAutoResetEvent } = require(\"@esfx/async-autoresetevent\"); const event = new AsyncAutoResetEvent(); async function doSomeActivity() { while (true) { // do some work asynchronously... // indicate 'waitForActivity' can resume. Event is immediately reset to // the signaled state. event.set(); } } async function waitForActivity() { while (true) { // wait for 'doSomeActivity' to set the event... await event.wait(); // do something asynchronous... } } doSomeActivity(); waitForActivity();"
  },
  "api/async-readerwriterlock/asyncreaderwriterlockupgradedwriter.html": {
    "href": "api/async-readerwriterlock/asyncreaderwriterlockupgradedwriter.html",
    "title": "Interface AsyncReaderWriterLockUpgradedWriter | @esfx API Reference",
    "keywords": "Interface AsyncReaderWriterLockUpgradedWriter Properties owner Gets the AsyncReaderWriterLock that owns this object. Declaration readonly owner: AsyncReaderWriterLock; Property Value AsyncReaderWriterLock"
  },
  "api/async-readerwriterlock/asyncreaderwriterlockupgradeablereader.html": {
    "href": "api/async-readerwriterlock/asyncreaderwriterlockupgradeablereader.html",
    "title": "Interface AsyncReaderWriterLockUpgradeableReader | @esfx API Reference",
    "keywords": "Interface AsyncReaderWriterLockUpgradeableReader Properties owner Gets the AsyncReaderWriterLock that owns this object. Declaration readonly owner: AsyncReaderWriterLock; Property Value AsyncReaderWriterLock Methods createWriter() Creates a AsyncReaderWriterLockUpgradedWriter that can be used to take and release \"write\" locks on a resource. Declaration createWriter(): AsyncReaderWriterLockUpgradedWriter; Returns AsyncReaderWriterLockUpgradedWriter upgrade(cancelable) Asynchronously waits for and takes a write lock on a resource. Declaration upgrade(cancelable?: Cancelable): Promise<AsyncReaderWriterLockUpgradedWriter>; Parameters cancelable Cancelable Returns Promise < AsyncReaderWriterLockUpgradedWriter >"
  },
  "api/async-readerwriterlock/asyncreaderwriterlockreader.html": {
    "href": "api/async-readerwriterlock/asyncreaderwriterlockreader.html",
    "title": "Interface AsyncReaderWriterLockReader | @esfx API Reference",
    "keywords": "Interface AsyncReaderWriterLockReader Properties owner Gets the AsyncReaderWriterLock that owns this object. Declaration readonly owner: AsyncReaderWriterLock; Property Value AsyncReaderWriterLock"
  },
  "api/async-lockable/asynclockable_namespace.html": {
    "href": "api/async-lockable/asynclockable_namespace.html",
    "title": "Namespace AsyncLockable | @esfx API Reference",
    "keywords": "Namespace AsyncLockable Functions isAsyncLockable(value) Determines whether a value is AsyncLockable <!-- --> . Declaration function isAsyncLockable(value: unknown): value is AsyncLockable; Parameters value unknown Returns value is AsyncLockable Variables lock A well-known symbol used to define an locking method on an object. Declaration lock: unique symbol Type unique symbol unlock A well-known symbol used to define an unlocking method on an object. Declaration unlock: unique symbol Type unique symbol"
  },
  "api/async-lockable/asynclockable_interface.html": {
    "href": "api/async-lockable/asynclockable_interface.html",
    "title": "Interface AsyncLockable | @esfx API Reference",
    "keywords": "Interface AsyncLockable Represents a value that can be used to synchronize access to a resource. Methods [AsyncLockable.lock](cancelable) Takes a lock. Declaration [AsyncLockable.lock](cancelable?: Cancelable): Promise<LockHandle>; Parameters cancelable Cancelable Returns Promise < LockHandle > [AsyncLockable.unlock]() Releases a lock. Declaration [AsyncLockable.unlock](): void; Returns void"
  },
  "api/async-lazy/asynclazy.html": {
    "href": "api/async-lazy/asynclazy.html",
    "title": "Class AsyncLazy | @esfx API Reference",
    "keywords": "Class AsyncLazy A lazy-initialized asynchronous value. Constructors constructor(factory) Constructs a new instance of the AsyncLazy class Declaration constructor(factory: () => T | PromiseLike<T>); Parameters factory () => T | PromiseLike < T > Properties isStarted Declaration readonly isStarted: boolean; Property Value boolean value Declaration readonly value: Promise<T>; Property Value Promise < T > Methods for(value) Declaration static for<T>(value: T | PromiseLike<T>): AsyncLazy<T>; Parameters value T | PromiseLike < T > Returns AsyncLazy < T > from(factory, args) Declaration static from<T, A extends any[]>(factory: (...args: A) => T | PromiseLike<T>, ...args: A): AsyncLazy<T>; Parameters factory (... args : A ) => T | PromiseLike < T > args A Returns AsyncLazy < T >"
  },
  "api/async-deferred/deferred.html": {
    "href": "api/async-deferred/deferred.html",
    "title": "Class Deferred | @esfx API Reference",
    "keywords": "Class Deferred Encapsulates a Promise and exposes its resolve and reject callbacks. Constructors constructor() Initializes a new instance of the Deferred class. Declaration constructor(); Properties callback Gets a NodeJS-style callback that can be used to resolve or reject the promise. Declaration readonly callback: T extends void ? (err: Error | null | undefined) => void : (err: Error | null | undefined, value: T) => void; Property Value T extends void ? ( err : Error | null | undefined) => void : ( err : Error | null | undefined, value : T ) => void promise Gets the promise. Declaration readonly promise: Promise<T>; Property Value Promise < T > reject Gets the callback used to reject the promise. Declaration readonly reject: (reason: any) => void; Property Value ( reason : any) => void resolve Gets the callback used to resolve the promise. Declaration readonly resolve: (value?: T | PromiseLike<T> | undefined) => void; Property Value ( value ?: T | PromiseLike < T > | undefined) => void Methods createCallback(selector) Creates a NodeJS-style callback that can be used to resolve or reject the promise with multiple values. Declaration createCallback<A extends any[]>(selector: (...args: A) => T): (err: Error | null | undefined, ...args: A) => void; Parameters selector (... args : A ) => T Returns ( err : Error | null | undefined, ... args : A ) => void"
  },
  "api/async-canceltoken/canceltoken.html": {
    "href": "api/async-canceltoken/canceltoken.html",
    "title": "Class CancelToken | @esfx API Reference",
    "keywords": "Class CancelToken Propagates notifications that operations should be canceled. Properties canBeSignaled Gets a value indicating whether the token can be signaled. Declaration readonly canBeSignaled: boolean; Property Value boolean canceled Declaration static readonly canceled: CancelToken; Property Value CancelToken none Declaration static readonly none: CancelToken; Property Value CancelToken signaled Gets a value indicating whether the token is signaled. Declaration readonly signaled: boolean; Property Value boolean Methods [Cancelable.cancelSignal]() Declaration [Cancelable.cancelSignal](): CancelToken; Returns CancelToken all(cancelables) Returns a CancelToken that becomes signaled when **all** of the provided cancelables are signaled. Declaration static all(cancelables: Iterable<Cancelable>): CancelToken; Parameters cancelables Iterable < Cancelable > Returns CancelToken from(cancelable) Gets a CancelToken from a cancelable. Declaration static from(cancelable: Cancelable | null | undefined): CancelToken; Parameters cancelable Cancelable | null | undefined Returns CancelToken race(cancelables) Returns a CancelToken that becomes signaled when **any** of the provided cancelables are signaled. Declaration static race(cancelables: Iterable<Cancelable>): CancelToken; Parameters cancelables Iterable < Cancelable > Returns CancelToken source() Creates a new CancelSource. Declaration static source(): CancelSource; Returns CancelSource subscribe(onSignaled) Subscribes to notifications for when the object becomes signaled. Declaration subscribe(onSignaled: () => void): CancelSubscription; Parameters onSignaled () => void Returns CancelSubscription throwIfSignaled() Throws a CancelError if the token was signaled. Declaration throwIfSignaled(): void; Returns void"
  },
  "api/decorators.html": {
    "href": "api/decorators.html",
    "title": "Package @esfx/decorators | @esfx API Reference",
    "keywords": "Package @esfx/decorators Provides a number of frequently used decorators. Overview Installation Usage Installation npm i @esfx/decorators Usage TypeScript Variables autobind Declaration autobind: { (target: Function): void; (target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined): void; } Type { ( target : Function ): void; ( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined): void; } autoproperty Converts a field declaration into an accessor with a backing property. Declaration autoproperty: ((readonly?: boolean | undefined) => (target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void) & ((target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void) Type (( readonly ?: boolean | undefined) => ( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void) & (( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void) configurable Makes a method or accessor configurable. Declaration configurable: (() => (target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void) & ((target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void) Type (() => ( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void) & (( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void) enumerable Makes a method or accessor enumerable. Declaration enumerable: (() => (target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void) & ((target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void) Type (() => ( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void) & (( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void) lazyinit Declaration lazyinit: (initializer: () => unknown, attributes?: { enumerable?: boolean | undefined; configurable?: boolean | undefined; writable?: boolean | undefined; } | undefined) => (target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void Type ( initializer : () => unknown, attributes ?: { enumerable ?: boolean | undefined; configurable ?: boolean | undefined; writable ?: boolean | undefined; } | undefined) => ( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void mixin Declaration mixin: (...args: object[]) => (target: Function) => void Type (... args : object[]) => ( target : Function ) => void nonconfigurable Makes a method or accessor non-configurable. Declaration nonconfigurable: (() => (target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void) & ((target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void) Type (() => ( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void) & (( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void) nonenumerable Makes a method or accessor non-enumerable. Declaration nonenumerable: (() => (target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void) & ((target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void) Type (() => ( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void) & (( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void) obsolete Makes a member obsolete. Declaration obsolete: ((message?: string | undefined, error?: boolean | undefined) => { (target: Function): void; (target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined): void; }) & { <T extends Function>(target: T): void | T; (target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined): void; } Type (( message ?: string | undefined, error ?: boolean | undefined) => { ( target : Function ): void; ( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined): void; }) & { < T extends Function >( target : T ): void | T ; ( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined): void; } readonly Makes a method non-writable. Declaration readonly: (() => (target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void) & ((target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void) Type (() => ( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void) & (( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void) writable Makes a method writable. Declaration writable: (() => (target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void) & ((target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined) => void) Type (() => ( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void) & (( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined) => void)"
  },
  "api/collections-multimap.html": {
    "href": "api/collections-multimap.html",
    "title": "Package @esfx/collections-multimap | @esfx API Reference",
    "keywords": "Package @esfx/collections-multimap Provides the MultiMap class, a collection class that maps a single key to multiple values. Overview Installation Usage Installation npm i @esfx/collections-multimap Usage TypeScript JavaScript (CommonJS) import { MultiMap } from \"@esfx/collections-multimap\"; const multi = new MultiMap<string, number>(); multi.add(\"a\", 1); multi.add(\"a\", 2); multi.add(\"b\", 3); multi.size; // 3 [...multi.get(\"a\")]; // [1, 2] [...multi.get(\"b\")]; // [3] import { MultiMap } from \"@esfx/collections-multimap\"; const multi = new MultiMap(); multi.add(\"a\", 1); multi.add(\"a\", 2); multi.add(\"b\", 3); multi.size; // 3 [...multi.get(\"a\")]; // [1, 2] [...multi.get(\"b\")]; // [3]"
  },
  "api/collections-linkedlist.html": {
    "href": "api/collections-linkedlist.html",
    "title": "Package @esfx/collections-linkedlist | @esfx API Reference",
    "keywords": "Package @esfx/collections-linkedlist Provides the LinkedList class, a linked-list implementation that utilizes @esfx/collection-core and @esfx/equatable . Overview Installation Usage Installation npm i @esfx/collections-linkedlist Usage TypeScript JavaScript (CommonJS) import { LinkedList, LinkedListNode } from \"equatable/collections-linkedlist\"; const list = new LinkedList<string>(); const n1: LinkedListNode<string> = list.push(\"first\"); const n2: LinkedListNode<string> = list.push(\"second\"); n2.value = \"second updated\"; [...list]; // first,second updated const { LinkedList } = require(\"equatable/collections-linkedlist\"); const list = new LinkedList(); const n1 = list.push(\"first\"); const n2 = list.push(\"second\"); n2.value = \"second updated\"; [...list]; // first,second updated"
  },
  "api/collection-core.html": {
    "href": "api/collection-core.html",
    "title": "Package @esfx/collection-core | @esfx API Reference",
    "keywords": "Package @esfx/collection-core Provides a low-level Symbol-based API for defining common collection behaviors. Overview Installation Usage Installation npm i @esfx/collection-core Usage TypeScript JavaScript (CommonJS) import { Collection } from \"@esfx/collection-core\"; class MyCollection<T> { private _items = new Set<T>(); // Your implementation get count() { return this._items.size; } contains(value): T { return this._items.has(value); } add(value: T) { this._items.add(value); } remove(value: T) { return this._items.delete(value); } clear() { this._items.clear(); } // Implement the `Collection` interface for cross-library consistency get [Collection.size]() { return this.count; } [Collection.has](value) { return this.contains(value); } [Collection.add](value) { this.add(value); } [Collection.delete](value) { return this.remove(value); } [Collection.clear]() { this.clear(); } [Symbol.iterator]() { return this._items.values(); } } const { Collection } = require(\"@esfx/collection-core\"); class MyCollection { constructor() { this._items = new Set(); } // Your implementation get count() { return this._items.size; } contains(value) { return this._items.has(value); } add(value) { this._items.add(value); } remove(value) { return this._items.delete(value); } clear() { this._items.clear(); } // Implement the `Collection` interface for cross-library consistency get [Collection.size]() { return this.count; } [Collection.has](value) { return this.contains(value); } [Collection.add](value) { this.add(value); } [Collection.delete](value) { return this.remove(value); } [Collection.clear]() { this.clear(); } [Symbol.iterator]() { return this._items.values(); } }"
  },
  "api/async-countdown.html": {
    "href": "api/async-countdown.html",
    "title": "Package @esfx/async-countdown | @esfx API Reference",
    "keywords": "Package @esfx/async-countdown The @esfx/async-countdown package provides the AsyncCountdownEvent class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-countdown Usage TypeScript JavaScript (CommonJS) import { AsyncCountdownEvent } from \"@esfx/cancelable\"; async function main() { // create an AsyncCountdownEvent with 4 participants const countdown = new AsyncCountdownEvent(4); const worker = async () => { // dome some work async... // signal completion countdown.signal(); } // start 4 workers worker(); worker(); worker(); worker(); // wait for all 4 workers to signal completion... await countdown.wait(); } main().catch(e => console.error(e)); const { AsyncCountdownEvent } = require(\"@esfx/cancelable\"); async function main() { // create an AsyncCountdownEvent with 4 participants const countdown = new AsyncCountdownEvent(4); const worker = async () => { // dome some work async... // signal completion countdown.signal(); } // start 4 workers worker(); worker(); worker(); worker(); // wait for all 4 workers to signal completion... await countdown.wait(); } main().catch(e => console.error(e));"
  },
  "api/async-canceltoken.html": {
    "href": "api/async-canceltoken.html",
    "title": "Package @esfx/async-canceltoken | @esfx API Reference",
    "keywords": "Package @esfx/async-canceltoken The @esfx/async-canceltoken package provides the CancelToken class, an implementation of @esfx/cancelable . Overview Installation Usage Installation npm i @esfx/async-canceltoken Usage Basic Usage Linking Tokens Basic Usage TypeScript JavaScript (CommonJS) import { CancelToken } from \"@esfx/async-canceltoken\"; // consume a cancel token async function doWork(token = CancelToken.none) { // do some work await doSomeOtherWork(token); // throw an error if cancellation has been signaled since awaiting. token.throwIfSignaled(); } function doSomeOtherWork(token = CancelToken.none) { return new Promise((resolve, reject) => { token.throwIfSignaled(); // throw if cancellation has already been signaled. // setup some external async operation... const worker = ...; // listen for cancellation and abort the worker. const subscription = token.subscribe(() => { worker.abort(); reject(new CancelError()); }); // start working, resolve when done worker.start(resolve); }); } // call an async function that supports cancellation const source = CancelToken.source(); doWork(source.token).then(() => { // operation completed... source.close(); }, err => { if (err instanceof CancelError) { // operation was canceled.. } }); // cancel operation after 10 seconds setTimeout(() => source.cancel(), 1000 * 10); const { CancelToken } = require(\"@esfx/async-canceltoken\"); // consume a cancel token async function doWork(token = CancelToken.none) { // do some work await doSomeOtherWork(token); // throw an error if cancellation has been signaled since awaiting. token.throwIfSignaled(); } function doSomeOtherWork(token = CancelToken.none) { return new Promise((resolve, reject) => { token.throwIfSignaled(); // throw if cancellation has already been signaled. // setup some external async operation... const worker = ...; // listen for cancellation and abort the worker. const subscription = token.subscribe(() => { worker.abort(); reject(new CancelError()); }); // start working, resolve when done worker.start(resolve); }); } // call an async function that supports cancellation const source = CancelToken.source(); doWork(source.token).then(() => { // operation completed... source.close(); }, err => { if (err instanceof CancelError) { // operation was canceled.. } }); // cancel operation after 10 seconds setTimeout(() => source.cancel(), 1000 * 10); Linking Tokens TypeScript JavaScript (CommonJS) import { CancelToken } from \"@esfx/async-canceltoken\"; // You can compose a cancellation graph with a root CancelToken, allowing you to cancel a large // number of asynchronous operations all at once let rootSource = CancelToken.source(); function cancelAllDownloads() { // explicitly cancel all downloads rootSource.cancel(); // reset the root source rootSource = CancelToken.source(); } async function downloadFile(url, path, token = CancelToken.none) { // add own source for timeout after 60 seconds const timeoutSource = CancelToken.source(); setTimeout(() => timeoutSource.cancel(), 60 * 1000); // download can be canceled by either 'rootSource', 'timeoutSource' or 'token': const linkedToken = CancelToken.race([rootSource.token, timeoutSource.token, token]); // ... use linkedToken to observe cancellation. } const { CancelToken } = require(\"@esfx/async-canceltoken\"); // You can compose a cancellation graph with a root CancelToken, allowing you to cancel a large // number of asynchronous operations all at once let rootSource = CancelToken.source(); function cancelAllDownloads() { // explicitly cancel all downloads rootSource.cancel(); // reset the root source rootSource = CancelToken.source(); } async function downloadFile(url, path, token = CancelToken.none) { // add own source for timeout after 60 seconds const timeoutSource = CancelToken.source(); setTimeout(() => timeoutSource.cancel(), 60 * 1000); // download can be canceled by either 'rootSource', 'timeoutSource' or 'token': const linkedToken = CancelToken.race([rootSource.token, timeoutSource.token, token]); // ... use linkedToken to observe cancellation. }"
  },
  "api/equatable/equaler_interface.html": {
    "href": "api/equatable/equaler_interface.html",
    "title": "Interface Equaler | @esfx API Reference",
    "keywords": "Interface Equaler Represents an object that can be used to compare the equality of two objects. Methods equals(x, y) Tests whether two values are equal to each other. Declaration equals(x: T, y: T): boolean; Parameters x T y T Returns boolean hash(x) Generates a hash code for a value. Declaration hash(x: T): number; Parameters x T Returns number"
  },
  "api/equatable/comparer_namespace.html": {
    "href": "api/equatable/comparer_namespace.html",
    "title": "Namespace Comparer | @esfx API Reference",
    "keywords": "Namespace Comparer Functions create(comparison) Creates a Comparer from a comparison function. Declaration function create<T>(comparison: Comparison<T>): Comparer<T>; Parameters comparison Comparison < T > Returns Comparer < T > Variables defaultComparer The default Comparer <!-- --> . Declaration defaultComparer: Comparer<unknown> Type Comparer <unknown> structuralComparer A default Comparer that supports StructuralComparable values. Declaration structuralComparer: Comparer<unknown> Type Comparer <unknown> tupleComparer A default Comparer that compares array values rather than the arrays themselves. Declaration tupleComparer: Comparer<readonly unknown[]> Type Comparer <readonly unknown[]> tupleStructuralComparer A default Comparer that compares array values that may be StructuralComparable rather than the arrays themselves. Declaration tupleStructuralComparer: Comparer<readonly unknown[]> Type Comparer <readonly unknown[]>"
  },
  "api/equatable/comparer_interface.html": {
    "href": "api/equatable/comparer_interface.html",
    "title": "Interface Comparer | @esfx API Reference",
    "keywords": "Interface Comparer Represents an object that can be used to perform a relational comparison between two values. Methods compare(x, y) Compares two values: - A negative value indicates x is lesser than y <!-- --> . - A positive value indicates x is greater than y <!-- --> . - A zero value indicates x and y are equivalent. Declaration compare(x: T, y: T): number; Parameters x T y T Returns number"
  },
  "api/equatable/comparable_namespace.html": {
    "href": "api/equatable/comparable_namespace.html",
    "title": "Namespace Comparable | @esfx API Reference",
    "keywords": "Namespace Comparable Functions isComparable(value) Determines whether a value is Comparable. Declaration function isComparable(value: unknown): value is Comparable; Parameters value unknown Returns value is Comparable Variables compareTo A well-known symbol used to define a relational comparison method on a value. Declaration compareTo: unique symbol Type unique symbol"
  },
  "api/decorators-stage1-core/memberdescriptor.html": {
    "href": "api/decorators-stage1-core/memberdescriptor.html",
    "title": "Interface MemberDescriptor | @esfx API Reference",
    "keywords": "Interface MemberDescriptor Properties descriptor Declaration descriptor?: TypedPropertyDescriptor<T>; Property Value TypedPropertyDescriptor < T > key Declaration key: string | symbol; Property Value string | symbol kind Declaration kind: \"member\"; Property Value \"member\" target Declaration target: object; Property Value object"
  },
  "api/decorators-stage1-core/fieldmemberdescriptor.html": {
    "href": "api/decorators-stage1-core/fieldmemberdescriptor.html",
    "title": "Interface FieldMemberDescriptor | @esfx API Reference",
    "keywords": "Interface FieldMemberDescriptor Properties descriptor Declaration descriptor?: undefined; Property Value undefined"
  },
  "api/decorators-stage1-core/classdescriptor.html": {
    "href": "api/decorators-stage1-core/classdescriptor.html",
    "title": "Interface ClassDescriptor | @esfx API Reference",
    "keywords": "Interface ClassDescriptor Properties kind Declaration kind: \"class\"; Property Value \"class\" target Declaration target: T; Property Value T"
  },
  "api/decorators-stage1-core/accessormemberdescriptor.html": {
    "href": "api/decorators-stage1-core/accessormemberdescriptor.html",
    "title": "Interface AccessorMemberDescriptor | @esfx API Reference",
    "keywords": "Interface AccessorMemberDescriptor Properties descriptor Declaration descriptor: AccessorPropertyDescriptor<T>; Property Value AccessorPropertyDescriptor < T >"
  },
  "api/ref.html": {
    "href": "api/ref.html",
    "title": "Package @esfx/ref | @esfx API Reference",
    "keywords": "Package @esfx/ref Provides a low-level API for defining forward references. Note This implementation is an approximation of the Reference behavior from https://github.com/rbuckton/proposal-refs . Overview Installation Usage Installation npm i @esfx/ref Usage Note Examples adapted from https://github.com/rbuckton/proposal-refs#examples where applicable. Take a reference to a variable TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; let x = 1; const r = ref(() => x, _ => x = _); print(r.value); // 1 r.value = 2; print(x); // 2 const { ref } = require(\"@esfx/ref\"); let x = 1; const r = ref(() => x, _ => x = _); print(r.value); // 1 r.value = 2; print(x); // 2 Take a reference to a property TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; let o = { x: 1 }; const r = ref.at(o, \"x\"); print(r.value); // 1 r.value = 2; print(o); // { x: 2 } const { ref } = require(\"@esfx/ref\"); let o = { x: 1 }; const r = ref.at(o, \"x\"); print(r.value); // 1 r.value = 2; print(o); // { x: 2 } Take a reference to an element TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; let ar = [1]; const r = ref.at(ar, 0); print(r.value); // 1 r.value = 2; print(ar); // [2] const { ref } = require(\"@esfx/ref\"); let ar = [1]; const r = ref.at(ar, 0); print(r.value); // 1 r.value = 2; print(ar); // [2] Reference passing TypeScript JavaScript (CommonJS) import { ref, Reference } from \"@esfx/ref\"; function update(ref_r: Reference<number>) { ref_r.value = 2; } let x = 1; update(ref(() => x, _ => x = _)); print(x); // 2 const { ref } = require(\"@esfx/ref\"); function update(ref_r) { ref_r.value = 2; } let x = 1; update(ref(() => x, _ => x = _)); print(x); // 2 Referencing a local declaration creates a closure TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; function f() { let x = 1; return [ref(() => x, _ => x = _), () => print(x)] as const; } const [r, p] = f(); p(); // 1 r.value = 2; p(); // 2 const { ref } = require(\"@esfx/ref\"); function f() { let x = 1; return [ref(() => x, _ => x = _), () => print(x)]; } const [r, p] = f(); p(); // 1 r.value = 2; p(); // 2 More complex reference passing TypeScript JavaScript (CommonJS) import { ref, Reference } from \"@esfx/ref\"; function max(ref_first: Reference<number>, ref_second: Reference<number>, ref_third: Reference<number>) { const ref_max = ref_first.value > ref_second.value ? ref_first : ref_second; return ref_max.value > ref_third.value ? ref_max : ref_third; } let x = 1, y = 2, z = 3; const ref_x = ref(() => x, _ => x = _); const ref_y = ref(() => y, _ => y = _); const ref_z = ref(() => z, _ => z = _); const ref_w = max(ref_x, ref_y, ref_z); ref_w.value = 4; print(x); // 1 print(y); // 2 print(z); // 4 const { ref } = require(\"@esfx/ref\"); function max(ref_first, ref_second, ref_third) { const ref_max = ref_first.value > ref_second.value ? ref_first : ref_second; return ref_max.value > ref_third.value ? ref_max : ref_third; } let x = 1, y = 2, z = 3; const ref_x = ref(() => x, _ => x = _); const ref_y = ref(() => y, _ => y = _); const ref_z = ref(() => z, _ => z = _); const ref_w = max(ref_x, ref_y, ref_z); ref_w.value = 4; print(x); // 1 print(y); // 2 print(z); // 4 Forward reference to a var TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; const ref_a = ref(() => a, _ => a = _); ref_a.value = 1; // ok, no error as `a` is a var. var a: number; const { ref } = require(\"@esfx/ref\"); const ref_a = ref(() => a, _ => a = _); ref_a.value = 1; // ok, no error as `a` is a var. var a; Forward reference to a block-scoped variable TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; let a: number; const ref_a = ref(() => a, _ => a = _); ref_a.value = 1; // ok, no error as `a` has been declared. const ref_b = ref(() => b, _ => b = _); ref_b.value = 1; // error as `b` has not yet been declared. let b: number; const { ref } = require(\"@esfx/ref\"); let a; const ref_a = ref(() => a, _ => a = _); ref_a.value = 1; // ok, no error as `a` has been declared. const ref_b = ref(() => b, _ => b = _); ref_b.value = 1; // error as `b` has not yet been declared. let b; Forward reference to a member of a block-scoped variable TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; const ref_x = ref.at(b, \"x\"); // error, `b` has not yet been declared let b = { x: 1 }; const { ref } = require(\"@esfx/ref\"); const ref_x = ref.at(b, \"x\"); // error, `b` has not yet been declared let b = { x: 1 }; Forward references for decorators TypeScript import { ref, Reference } from \"@esfx/ref\"; import { metadata } from \"@esfx/metadata\"; const Type = (ref_type: Reference<Function>) => metadata(\"design:type\", ref_type); class Node { @Type(ref(() => Container)) get parent() { /*...*/ } @Type(ref(() => Node)) get nextSibling() { /*...*/ } } class Container extends Node { @Type(ref(() => Node)) get firstChild() { /*...*/ } } Side effects TypeScript JavaScript (CommonJS) import { ref } from \"@esfx/ref\"; let count = 0; let e = [0, 1, 2]; const ref_e = ref.at(e, count++); // `count++` is evaluated when Reference is taken. print(ref_e.value); // 0 print(ref_e.value); // 0 print(count); // 1 const { ref } = require(\"@esfx/ref\"); let count = 0; let e = [0, 1, 2]; const ref_e = ref.at(e, count++); // `count++` is evaluated when Reference is taken. print(ref_e.value); // 0 print(ref_e.value); // 0 print(count); // 1 Functions ref(get, set) Create a reference to a value in the current lexical scope. Declaration export declare function ref<T>(get: () => T, set?: (value: T) => void): Reference<T>; Parameters get () => T set ( value : T ) => void Returns Reference < T >"
  },
  "api/metadata.html": {
    "href": "api/metadata.html",
    "title": "Package @esfx/metadata | @esfx API Reference",
    "keywords": "Package @esfx/metadata Provides an API for defining metadata about an object. Overview Installation Usage Installation npm i @esfx/metadata Usage TypeScript JavaScript (CommonJS) import { Metadata, getClassMetadata, getMemberMetadata, getParameterMetadata } from \"@esfx/metadata\"; const Service = name => Metadata(\"Service\", name); const ReturnType = type => Metadata(\"ReturnType\", type); const Type = type => Metadata(\"Type\", type); @Service(\"MyService\") class MyClass { @ReturnType(\"string\") method(@Type(\"number\") x: number) { return \"hi\"; } } const c = new MyClass(); getClassMetadata(MyClass, \"Service\"); // \"MyService\" getMemberMetadata(c, \"method\", \"ReturnType\"); // \"string\" getParameterMetadata(c, \"method\", 0, \"Type\"); // \"number\" const { defineClassMetadata, defineMemberMetadata, defineParameterMetadata, getClassMetadata, getMemberMetadata, getParameterMetadata } = require(\"@esfx/metadata\"); class MyClass { method(x) { return \"hi\"; } } defineClassMetadata(MyClass, \"Service\", \"MyService\"); defineMemberMetadata(MyClass.prototype, \"method\", \"ReturnType\", \"string\"); defineParameterMetadata(MyClass.prototype, \"method\", 0, \"Type\", \"number\"); const c = new MyClass(); getClassMetadata(MyClass, \"Service\"); // \"MyService\" getMemberMetadata(c, \"method\", \"ReturnType\"); // \"string\" getParameterMetadata(c, \"method\", 0, \"Type\"); // \"number\" Functions defineObjectMetadata(target, metadataKey, metadataValue) Define metadata on an object. Declaration export declare function defineObjectMetadata(target: object, metadataKey: MetadataKey, metadataValue: unknown): void; Parameters target object metadataKey MetadataKey metadataValue unknown Returns void defineParameterMetadata(target, propertyKey, parameterIndex, metadataKey, metadataValue) Define metadata on a parameter of a method of an object. Declaration export declare function defineParameterMetadata(target: object, propertyKey: PropertyKey, parameterIndex: number, metadataKey: MetadataKey, metadataValue: unknown): void; Parameters target object propertyKey PropertyKey parameterIndex number metadataKey MetadataKey metadataValue unknown Returns void definePropertyMetadata(target, propertyKey, metadataKey, metadataValue) Define metadata for a property of an object. The property does not have to exist. Declaration export declare function definePropertyMetadata(target: object, propertyKey: PropertyKey, metadataKey: MetadataKey, metadataValue: unknown): void; Parameters target object propertyKey PropertyKey metadataKey MetadataKey metadataValue unknown Returns void deleteObjectMetadata(target, metadataKey) Deletes an own metadata key from an object. Declaration export declare function deleteObjectMetadata(target: object, metadataKey: MetadataKey): boolean; Parameters target object metadataKey MetadataKey Returns boolean deleteParameterMetadata(target, propertyKey, parameterIndex, metadataKey) Deletes an own metadata key from a parameter of a method of an object. Declaration export declare function deleteParameterMetadata(target: object, propertyKey: PropertyKey, parameterIndex: number, metadataKey: MetadataKey): boolean; Parameters target object propertyKey PropertyKey parameterIndex number metadataKey MetadataKey Returns boolean deletePropertyMetadata(target, propertyKey, metadataKey) Deletes an own metadata key from a property of an object. Declaration export declare function deletePropertyMetadata(target: object, propertyKey: PropertyKey, metadataKey: MetadataKey): boolean; Parameters target object propertyKey PropertyKey metadataKey MetadataKey Returns boolean getMetadataParameterLength(target, propertyKey) Gets the maximum known length of a method of an object or its prototypes from its parameters that have metadata metadata. Declaration export declare function getMetadataParameterLength(target: object, propertyKey: PropertyKey): number; Parameters target object propertyKey PropertyKey Returns number getMetadataProperties(target) Gets the property names for an object or its prototypes for which there is metadata defined. Declaration export declare function getMetadataProperties(target: object): (string | symbol)[]; Parameters target object Returns (string | symbol)[] getObjectMetadata(target, metadataKey) Gets the metadata value for a metadata key on an object or its prototypes. Declaration export declare function getObjectMetadata(target: object, metadataKey: MetadataKey): unknown; Parameters target object metadataKey MetadataKey Returns unknown getObjectMetadataKeys(target) Gets the metadata keys defined on an object or its prototypes. Declaration export declare function getObjectMetadataKeys(target: object): MetadataKey[]; Parameters target object Returns MetadataKey [] getOwnMetadataParameterLength(target, propertyKey) Gets the maximum known length of a method of an object from its parameters that have metadata metadata. Declaration export declare function getOwnMetadataParameterLength(target: object, propertyKey: PropertyKey): number; Parameters target object propertyKey PropertyKey Returns number getOwnMetadataProperties(target) Gets the own property names for an object for which there is metadata defined. Declaration export declare function getOwnMetadataProperties(target: object): (string | symbol)[]; Parameters target object Returns (string | symbol)[] getOwnObjectMetadata(target, metadataKey) Gets the metadata value for an own metadata key on an object. Declaration export declare function getOwnObjectMetadata(target: object, metadataKey: MetadataKey): unknown; Parameters target object metadataKey MetadataKey Returns unknown getOwnObjectMetadataKeys(target) Gets the own metadata keys defined on an object. Declaration export declare function getOwnObjectMetadataKeys(target: object): MetadataKey[]; Parameters target object Returns MetadataKey [] getOwnParameterMetadata(target, propertyKey, parameterIndex, metadataKey) Gets the metadata value for an own metadata key on a parameter of a method of an object. Declaration export declare function getOwnParameterMetadata(target: object, propertyKey: PropertyKey, parameterIndex: number, metadataKey: MetadataKey): unknown; Parameters target object propertyKey PropertyKey parameterIndex number metadataKey MetadataKey Returns unknown getOwnParameterMetadataKeys(target, propertyKey, parameterIndex) Gets the own metadata keys defined on a parameter of a method of an object. Declaration export declare function getOwnParameterMetadataKeys(target: object, propertyKey: PropertyKey, parameterIndex: number): MetadataKey[]; Parameters target object propertyKey PropertyKey parameterIndex number Returns MetadataKey [] getOwnPropertyMetadata(target, propertyKey, metadataKey) Gets the metadata value for an own metadata key on a property of an object. Declaration export declare function getOwnPropertyMetadata(target: object, propertyKey: PropertyKey, metadataKey: MetadataKey): unknown; Parameters target object propertyKey PropertyKey metadataKey MetadataKey Returns unknown getOwnPropertyMetadataKeys(target, propertyKey) Gets the own metadata keys defined on a property of an object. Declaration export declare function getOwnPropertyMetadataKeys(target: object, propertyKey: PropertyKey): MetadataKey[]; Parameters target object propertyKey PropertyKey Returns MetadataKey [] getParameterMetadata(target, propertyKey, parameterIndex, metadataKey) Gets the metadata value for a metadata key on a parameter of a method of an object or its prototypes. Declaration export declare function getParameterMetadata(target: object, propertyKey: PropertyKey, parameterIndex: number, metadataKey: MetadataKey): unknown; Parameters target object propertyKey PropertyKey parameterIndex number metadataKey MetadataKey Returns unknown getParameterMetadataKeys(target, propertyKey, parameterIndex) Gets the metadata keys defined on a parameter of a method of an object or its prototypes. Declaration export declare function getParameterMetadataKeys(target: object, propertyKey: PropertyKey, parameterIndex: number): MetadataKey[]; Parameters target object propertyKey PropertyKey parameterIndex number Returns MetadataKey [] getPropertyMetadata(target, propertyKey, metadataKey) Gets the metadata value for a metadata key on a property of an object or its prototypes. Declaration export declare function getPropertyMetadata(target: object, propertyKey: PropertyKey, metadataKey: MetadataKey): unknown; Parameters target object propertyKey PropertyKey metadataKey MetadataKey Returns unknown getPropertyMetadataKeys(target, propertyKey) Gets the metadata keys defined on a property of an object or its prototypes. Declaration export declare function getPropertyMetadataKeys(target: object, propertyKey: PropertyKey): MetadataKey[]; Parameters target object propertyKey PropertyKey Returns MetadataKey [] hasObjectMetadata(target, metadataKey) Tests whether an object or its prototypes have metadata for the provided key. Declaration export declare function hasObjectMetadata(target: object, metadataKey: MetadataKey): boolean; Parameters target object metadataKey MetadataKey Returns boolean hasOwnObjectMetadata(target, metadataKey) Tests whether an object has own metadata for the provided key. Declaration export declare function hasOwnObjectMetadata(target: object, metadataKey: MetadataKey): boolean; Parameters target object metadataKey MetadataKey Returns boolean hasOwnParameterMetadata(target, propertyKey, parameterIndex, metadataKey) Tests whether a parameter of a method of an object has own metadata for the provided key. Declaration export declare function hasOwnParameterMetadata(target: object, propertyKey: PropertyKey, parameterIndex: number, metadataKey: MetadataKey): boolean; Parameters target object propertyKey PropertyKey parameterIndex number metadataKey MetadataKey Returns boolean hasOwnPropertyMetadata(target, propertyKey, metadataKey) Tests whether a property of an object has own metadata for the provided key. Declaration export declare function hasOwnPropertyMetadata(target: object, propertyKey: PropertyKey, metadataKey: MetadataKey): boolean; Parameters target object propertyKey PropertyKey metadataKey MetadataKey Returns boolean hasParameterMetadata(target, propertyKey, parameterIndex, metadataKey) Tests whether a parameter of a method of an object or its prototypes have metadata for the provided key. Declaration export declare function hasParameterMetadata(target: object, propertyKey: PropertyKey, parameterIndex: number, metadataKey: MetadataKey): boolean; Parameters target object propertyKey PropertyKey parameterIndex number metadataKey MetadataKey Returns boolean hasPropertyMetadata(target, propertyKey, metadataKey) Tests whether a property of an object or its prototypes have metadata for the provided key. Declaration export declare function hasPropertyMetadata(target: object, propertyKey: PropertyKey, metadataKey: MetadataKey): boolean; Parameters target object propertyKey PropertyKey metadataKey MetadataKey Returns boolean Type Aliases MetadataKey Declaration export declare type MetadataKey = string | symbol | number | boolean | bigint | object; Type string | symbol | number | boolean | bigint | object Variables metadata Attaches metadata to a class, member, or parameter. Declaration metadata: ((metadataKey: MetadataKey, metadataValue?: unknown) => { (target: Function): void; (target: object, key: string | number | symbol, descriptor?: PropertyDescriptor | undefined): void; (target: object, key: string | number | symbol, parameterIndex: number): void; }) & { defineObjectMetadata: typeof defineObjectMetadata; deleteObjectMetadata: typeof deleteObjectMetadata; hasOwnObjectMetadata: typeof hasOwnObjectMetadata; hasObjectMetadata: typeof hasObjectMetadata; getOwnObjectMetadata: typeof getOwnObjectMetadata; getObjectMetadata: typeof getObjectMetadata; getOwnObjectMetadataKeys: typeof getOwnObjectMetadataKeys; getObjectMetadataKeys: typeof getObjectMetadataKeys; definePropertyMetadata: typeof definePropertyMetadata; deletePropertyMetadata: typeof deletePropertyMetadata; hasOwnPropertyMetadata: typeof hasOwnPropertyMetadata; hasPropertyMetadata: typeof hasPropertyMetadata; getOwnPropertyMetadata: typeof getOwnPropertyMetadata; getPropertyMetadata: typeof getPropertyMetadata; getOwnPropertyMetadataKeys: typeof getOwnPropertyMetadataKeys; getPropertyMetadataKeys: typeof getPropertyMetadataKeys; getOwnMetadataProperties: typeof getOwnMetadataProperties; getMetadataProperties: typeof getMetadataProperties; defineParameterMetadata: typeof defineParameterMetadata; deleteParameterMetadata: typeof deleteParameterMetadata; hasOwnParameterMetadata: typeof hasOwnParameterMetadata; hasParameterMetadata: typeof hasParameterMetadata; getOwnParameterMetadata: typeof getOwnParameterMetadata; getParameterMetadata: typeof getParameterMetadata; getOwnParameterMetadataKeys: typeof getOwnParameterMetadataKeys; getParameterMetadataKeys: typeof getParameterMetadataKeys; getOwnMetadataParameterLength: typeof getOwnMetadataParameterLength; getMetadataParameterLength: typeof getMetadataParameterLength; } Type (( metadataKey : MetadataKey , metadataValue ?: unknown) => { ( target : Function ): void; ( target : object, key : string | number | symbol, descriptor ?: PropertyDescriptor | undefined): void; ( target : object, key : string | number | symbol, parameterIndex : number): void; }) & { defineObjectMetadata : typeof defineObjectMetadata ; deleteObjectMetadata : typeof deleteObjectMetadata ; hasOwnObjectMetadata : typeof hasOwnObjectMetadata ; hasObjectMetadata : typeof hasObjectMetadata ; getOwnObjectMetadata : typeof getOwnObjectMetadata ; getObjectMetadata : typeof getObjectMetadata ; getOwnObjectMetadataKeys : typeof getOwnObjectMetadataKeys ; getObjectMetadataKeys : typeof getObjectMetadataKeys ; definePropertyMetadata : typeof definePropertyMetadata ; deletePropertyMetadata : typeof deletePropertyMetadata ; hasOwnPropertyMetadata : typeof hasOwnPropertyMetadata ; hasPropertyMetadata : typeof hasPropertyMetadata ; getOwnPropertyMetadata : typeof getOwnPropertyMetadata ; getPropertyMetadata : typeof getPropertyMetadata ; getOwnPropertyMetadataKeys : typeof getOwnPropertyMetadataKeys ; getPropertyMetadataKeys : typeof getPropertyMetadataKeys ; getOwnMetadataProperties : typeof getOwnMetadataProperties ; getMetadataProperties : typeof getMetadataProperties ; defineParameterMetadata : typeof defineParameterMetadata ; deleteParameterMetadata : typeof deleteParameterMetadata ; hasOwnParameterMetadata : typeof hasOwnParameterMetadata ; hasParameterMetadata : typeof hasParameterMetadata ; getOwnParameterMetadata : typeof getOwnParameterMetadata ; getParameterMetadata : typeof getParameterMetadata ; getOwnParameterMetadataKeys : typeof getOwnParameterMetadataKeys ; getParameterMetadataKeys : typeof getParameterMetadataKeys ; getOwnMetadataParameterLength : typeof getOwnMetadataParameterLength ; getMetadataParameterLength : typeof getMetadataParameterLength ; }"
  },
  "api/collections-sortedset.html": {
    "href": "api/collections-sortedset.html",
    "title": "Package @esfx/collections-sortedset | @esfx API Reference",
    "keywords": "Package @esfx/collections-sortedset Provides the SortedSet class, a collection class that utilizes @esfx/collection-core and @esfx/equatable . Overview Installation Usage Installation npm i @esfx/collections-sortedset Usage TypeScript JavaScript (CommonJS) import { SortedSet } from \"@esfx/collections-sortedset\"; import { Equatable, Equaler, Comparable, Comparer } from \"@esfx/equatable\"; class Person { firstName: string; lastName: string; constructor(firstName: string, lastName: string) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other: unknown) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other: unknown) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Alice\", \"Johnson\"); const obj2 = new Person(\"Bob\", \"Clark\"); // ECMAScript native set iterates in insertion order const set = new Set<Person>(); // native ECMAScript Set set.add(obj1); set.add(obj2); [...set]; // Alice Johnson,Bob Clark // SortedSet uses Comparable.compareTo if available const sortedSet = new SortedSet<Person>(); sortedSet.add(obj1); sortedSet.add(obj2); [...sortedSet]; // Bob Clark,Alice Johnson const { SortedSet } = require(\"@esfx/collections-sortedset\"); const { Equatable, Equaler, Comparable, Comparer } = require(\"@esfx/equatable\"); class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Alice\", \"Johnson\"); const obj2 = new Person(\"Bob\", \"Clark\"); // ECMAScript native set iterates in insertion order const set = new Set(); // native ECMAScript Set set.add(obj1); set.add(obj2); [...set]; // Alice Johnson,Bob Clark // SortedSet uses Comparable.compareTo if available const sortedSet = new SortedSet(); sortedSet.add(obj1); sortedSet.add(obj2); [...sortedSet]; // Bob Clark,Alice Johnson"
  },
  "api/collections-sortedmap.html": {
    "href": "api/collections-sortedmap.html",
    "title": "Package @esfx/collections-sortedmap | @esfx API Reference",
    "keywords": "Package @esfx/collections-sortedmap Provides the SortedMap class, a collection class that utilizes @esfx/collection-core and @esfx/equatable . Overview Installation Usage Installation npm i @esfx/collections-sortedmap Usage TypeScript JavaScript (CommonJS) import { SortedMap } from \"@esfx/collections-sortedmap\"; import { Equatable, Equaler, Comparable, Comparer } from \"@esfx/equatable\"; class Person { firstName: string; lastName: string; constructor(firstName: string, lastName: string) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other: unknown) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other: unknown) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Alice\", \"Johnson\"); const obj2 = new Person(\"Bob\", \"Clark\"); // ECMAScript native map iterates in insertion order const map = new Map<Person, string>(); // native ECMAScript Map set.set(obj1, \"obj1\"); set.set(obj2, \"obj2\"); [...set.keys()]; // Alice Johnson,Bob Clark // SortedMap uses Comparable.compareTo if available const sortedMap = new SortedMap<Person, string>(); sortedMap.set(obj1, \"obj1\"); sortedMap.set(obj2, \"obj2\"); [...sortedMap.keys()]; // Bob Clark,Alice Johnson const { SortedMap } = require(\"@esfx/collections-sortedmap\"); const { Equatable, Equaler, Comparable, Comparer } = require(\"@esfx/equatable\"); class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Alice\", \"Johnson\"); const obj2 = new Person(\"Bob\", \"Clark\"); // ECMAScript native map iterates in insertion order const map = new Map(); // native ECMAScript Map set.set(obj1, \"obj1\"); set.set(obj2, \"obj2\"); [...set.keys()]; // Alice Johnson,Bob Clark // SortedMap uses Comparable.compareTo if available const sortedMap = new SortedMap(); sortedMap.set(obj1, \"obj1\"); sortedMap.set(obj2, \"obj2\"); [...sortedMap.keys()]; // Bob Clark,Alice Johnson"
  },
  "api/async-barrier.html": {
    "href": "api/async-barrier.html",
    "title": "Package @esfx/async-barrier | @esfx API Reference",
    "keywords": "Package @esfx/async-barrier The @esfx/async-barrier package provides the AsyncBarrier class, an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-barrier Usage TypeScript JavaScript (CommonJS) import { AsyncBarrier } from \"@esfx/async-barrier\"; async function main() { let count = 0; // Create a barrier with 3 participants and a post-phase action to print results. // When phase 2 completes, throw an exception to be observed by all participants. const barrier = new AsyncBarrier(3, b => { console.log(`Post-phase action: count=${count}, phase=${b.currentPhaseNumber}`); if (b.currentPhaseNumber === 2) throw new Error(\"Oops\"); }); // Add two participants barrier.add(2); barrier.participantCount; // 5 // Remove one participant barrier.remove(); barrier.participantcount; // 4 const action = async () => { count++; // Wait for the current phase to end. During the post-phase action 'count' will be 4 and // 'phase' will be 0. await barrier.signalAndWait(); count++; // Wait for the current phase to end. During the post-phase action 'count' will be 8 and // 'phase' will be 1. await barrier.signalAndWait(); count++; // When phase 2 ends an exception is thrown to all participants: try { await barrier.signalAndWait(); } catch (e) { console.log(`Caught error: ${e.message}`); } // Wait for the current phase to end. During the post-phase action 'count' will be 16 and // 'phase' will be 3. await barrier.signalAndWait(); }; // Start 4 async actions to serve as the 4 participants. await Promise.all([action(), action(), action(), action()]); } main(); // prints: // Post-phase action: count=4, phase=0 // Post-phase action: count=8, phase=1 // Post-phase action: count=12, phase=2 // Caught error: Oops // Post-phase action: count=16, phase=3 const { AsyncBarrier } = require(\"@esfx/async-barrier\"); async function main() { let count = 0; // Create a barrier with 3 participants and a post-phase action to print results. // When phase 2 completes, throw an exception to be observed by all participants. const barrier = new AsyncBarrier(3, b => { console.log(`Post-phase action: count=${count}, phase=${b.currentPhaseNumber}`); if (b.currentPhaseNumber === 2) throw new Error(\"Oops\"); }); // Add two participants barrier.add(2); barrier.participantCount; // 5 // Remove one participant barrier.remove(); barrier.participantcount; // 4 const action = async () => { count++; // Wait for the current phase to end. During the post-phase action 'count' will be 4 and // 'phase' will be 0. await barrier.signalAndWait(); count++; // Wait for the current phase to end. During the post-phase action 'count' will be 8 and // 'phase' will be 1. await barrier.signalAndWait(); count++; // When phase 2 ends an exception is thrown to all participants: try { await barrier.signalAndWait(); } catch (e) { console.log(`Caught error: ${e.message}`); } // Wait for the current phase to end. During the post-phase action 'count' will be 16 and // 'phase' will be 3. await barrier.signalAndWait(); }; // Start 4 async actions to serve as the 4 participants. await Promise.all([action(), action(), action(), action()]); } main(); // prints: // Post-phase action: count=4, phase=0 // Post-phase action: count=8, phase=1 // Post-phase action: count=12, phase=2 // Caught error: Oops // Post-phase action: count=16, phase=3"
  },
  "api/threading-semaphore/semaphore.html": {
    "href": "api/threading-semaphore/semaphore.html",
    "title": "Class Semaphore | @esfx API Reference",
    "keywords": "Class Semaphore Constructors constructor(initialCount, maxCount) Constructs a new instance of the Semaphore class Declaration constructor(initialCount: number, maxCount?: number); Parameters initialCount number maxCount number constructor(buffer, byteOffset) Constructs a new instance of the Semaphore class Declaration constructor(buffer: SharedArrayBuffer, byteOffset?: number); Parameters buffer SharedArrayBuffer byteOffset number Properties buffer Declaration readonly buffer: SharedArrayBuffer; Property Value SharedArrayBuffer byteLength Declaration readonly byteLength: number; Property Value number byteOffset Declaration readonly byteOffset: number; Property Value number count Declaration readonly count: number; Property Value number SIZE Declaration static readonly SIZE = 16; Methods release(count) Declaration release(count?: number): number; Parameters count number Returns number wait(ms) Declaration wait(ms?: number): boolean; Parameters ms number Returns boolean"
  },
  "api/collections-hashmap/hashmap.html": {
    "href": "api/collections-hashmap/hashmap.html",
    "title": "Class HashMap | @esfx API Reference",
    "keywords": "Class HashMap Constructors constructor(equaler) Constructs a new instance of the HashMap class Declaration constructor(equaler?: Equaler<K>); Parameters equaler Equaler < K > constructor(iterable, equaler) Constructs a new instance of the HashMap class Declaration constructor(iterable?: Iterable<[K, V]>, equaler?: Equaler<K>); Parameters iterable Iterable <[ K , V ]> equaler Equaler < K > constructor(capacity, equaler) Constructs a new instance of the HashMap class Declaration constructor(capacity: number, equaler?: Equaler<K>); Parameters capacity number equaler Equaler < K > Properties [KeyedCollection.size] Declaration readonly [KeyedCollection.size]: number; Property Value number [Symbol.toStringTag] Declaration [Symbol.toStringTag]: string; Property Value string equaler Declaration readonly equaler: Equaler<K>; Property Value Equaler < K > size Declaration readonly size: number; Property Value number Methods [KeyedCollection.clear]() Declaration [KeyedCollection.clear](): void; Returns void [KeyedCollection.delete](key) Declaration [KeyedCollection.delete](key: K): boolean; Parameters key K Returns boolean [KeyedCollection.get](key) Declaration [KeyedCollection.get](key: K): V | undefined; Parameters key K Returns V | undefined [KeyedCollection.has](key) Declaration [KeyedCollection.has](key: K): boolean; Parameters key K Returns boolean [KeyedCollection.keys]() Declaration [KeyedCollection.keys](): IterableIterator<K>; Returns IterableIterator < K > [KeyedCollection.set](key, value) Declaration [KeyedCollection.set](key: K, value: V): void; Parameters key K value V Returns void [KeyedCollection.values]() Declaration [KeyedCollection.values](): IterableIterator<V>; Returns IterableIterator < V > [Symbol.iterator]() Declaration [Symbol.iterator](): IterableIterator<[K, V]>; Returns IterableIterator <[ K , V ]> clear() Declaration clear(): void; Returns void delete(key) Declaration delete(key: K): boolean; Parameters key K Returns boolean ensureCapacity(capacity) Declaration ensureCapacity(capacity: number): number; Parameters capacity number Returns number entries() Declaration entries(): IterableIterator<[K, V]>; Returns IterableIterator <[ K , V ]> forEach(callback, thisArg) Declaration forEach(callback: (value: V, key: K, map: this) => void, thisArg?: any): void; Parameters callback ( value : V , key : K , map : this) => void thisArg any Returns void get(key) Declaration get(key: K): V | undefined; Parameters key K Returns V | undefined has(key) Declaration has(key: K): boolean; Parameters key K Returns boolean keys() Declaration keys(): IterableIterator<K>; Returns IterableIterator < K > set(key, value) Declaration set(key: K, value: V): this; Parameters key K value V Returns this trimExcess(capacity) Declaration trimExcess(capacity?: number): void; Parameters capacity number Returns void values() Declaration values(): IterableIterator<V>; Returns IterableIterator < V >"
  },
  "api/async-conditionvariable.html": {
    "href": "api/async-conditionvariable.html",
    "title": "Package @esfx/async-conditionvariable | @esfx API Reference",
    "keywords": "Package @esfx/async-conditionvariable Provides AsyncConditionVariable , an async coordination primitive. Overview Installation Usage Installation npm i @esfx/async-conditionvariable Usage TypeScript JavaScript (CommonJS) import { AsyncConditionVariable } from \"@esfx/async-conditionvariable\"; import { AsyncMutex } from \"@esfx/async-mutex\"; // create a mutex used to lock a resource const m = new AsyncMutex(); // create a condition variable to maintain a list of waiters for a resource const cv = new AsyncConditionVariable(); let tasks = getTasksToPerform(); // get some array of tasks to perform. let ready = false; let currentTask!: () => Promise<number>; let taskResult!: number; async function worker() { // pause worker until we can acquire a lock on 'm'. const lk = await m.lock(); try { // pause execution and release the lock on 'm' until we are ready. await cv.wait(lk, () => ready); while (ready) { // pause execution and release the lock on 'm' until we are notified await cv.wait(lk); // We should now have the lock again for 'm', so do more work... taskResult = await currentTask(); } } finally { lk.unlock(); } } async function main() { const pWorker = worker(); // start the worker let task; // get the next task to perform while (task = tasks.shift()) { // pause main until we can acquire a lock on 'm'. let lk = await m.lock(); try { currentTask = task; } finally { lk.unlock(); } cv.notifyOne(); // pause main until we can acquire a lock on 'm'. lk = await m.lock(); try { // we should now have the lock again for 'm', so process the result... console.log(taskResult); } finally { lk.unlock(); } } } main().catch(e => console.error(e)); const { AsyncConditionVariable } = require(\"@esfx/async-conditionvariable\"); const { AsyncMutex } = require(\"@esfx/async-mutex\"); // create a mutex used to lock a resource const m = new AsyncMutex(); // create a condition variable to maintain a list of waiters for a resource const cv = new AsyncConditionVariable(); let tasks = getTasksToPerform(); // get some array of tasks to perform. let ready = false; let currentTask; let taskResult; async function worker() { // pause worker until we can acquire a lock on 'm'. const lk = await m.lock(); try { // pause execution and release the lock on 'm' until we are ready. await cv.wait(lk, () => ready); while (ready) { // pause execution and release the lock on 'm' until we are notified await cv.wait(lk); // We should now have the lock again for 'm', so do more work... taskResult = await currentTask(); } } finally { lk.unlock(); } } async function main() { const pWorker = worker(); // start the worker let task; // get the next task to perform while (task = tasks.shift()) { // pause main until we can acquire a lock on 'm'. let lk = await m.lock(); try { currentTask = task; } finally { lk.unlock(); } cv.notifyOne(); // pause main until we can acquire a lock on 'm'. lk = await m.lock(); try { // we should now have the lock again for 'm', so process the result... console.log(taskResult); } finally { lk.unlock(); } } } main().catch(e => console.error(e));"
  },
  "api/equatable/structuralequatable_interface.html": {
    "href": "api/equatable/structuralequatable_interface.html",
    "title": "Interface StructuralEquatable | @esfx API Reference",
    "keywords": "Interface StructuralEquatable Represents a value that can compare its structural equality with another value. Methods [StructuralEquatable.structuralEquals](other, equaler) Determines whether this value is structurally equal to another value using the supplied Equaler <!-- --> . Declaration [StructuralEquatable.structuralEquals](other: unknown, equaler: Equaler<unknown>): boolean; Parameters other unknown equaler Equaler <unknown> Returns boolean [StructuralEquatable.structuralHash](equaler) Compute a structural hash code for a value using the supplied Equaler <!-- --> . Declaration [StructuralEquatable.structuralHash](equaler: Equaler<unknown>): number; Parameters equaler Equaler <unknown> Returns number"
  },
  "api/equatable/structuralcomparable_namespace.html": {
    "href": "api/equatable/structuralcomparable_namespace.html",
    "title": "Namespace StructuralComparable | @esfx API Reference",
    "keywords": "Namespace StructuralComparable Functions isStructuralComparable(value) Determines whether a value is StructuralComparable. Declaration function isStructuralComparable(value: unknown): value is StructuralComparable; Parameters value unknown Returns value is StructuralComparable Variables structuralCompareTo A well-known symbol used to define a structural comparison method on a value. Declaration structuralCompareTo: unique symbol Type unique symbol"
  },
  "api/equatable/structuralcomparable_interface.html": {
    "href": "api/equatable/structuralcomparable_interface.html",
    "title": "Interface StructuralComparable | @esfx API Reference",
    "keywords": "Interface StructuralComparable Represents a value that can compare its structure relationally with another value. Methods [StructuralComparable.structuralCompareTo](other, comparer) Compares the structure of this value with another value using the supplied comparer: - A negative value indicates this value is lesser. - A positive value indicates this value is greater. - A zero value indicates this value is the same. Declaration [StructuralComparable.structuralCompareTo](other: unknown, comparer: Comparer<unknown>): number; Parameters other unknown comparer Comparer <unknown> Returns number"
  },
  "api/collections.html": {
    "href": "api/collections.html",
    "title": "Package @esfx/collections | @esfx API Reference",
    "keywords": "Package @esfx/collections Provides a number of common collection classes from the following packages: @esfx/collections-sortedmap @esfx/collections-sortedset @esfx/collections-hashmap @esfx/collections-hashset @esfx/collections-linkedlist Installation npm i @esfx/collections"
  },
  "api/collections-hashset.html": {
    "href": "api/collections-hashset.html",
    "title": "Package @esfx/collections-hashset | @esfx API Reference",
    "keywords": "Package @esfx/collections-hashset Provides the HashSet class, a collection class that utilizes @esfx/collection-core and @esfx/equatable . Overview Installation Usage Installation npm i @esfx/collections-hashset Usage TypeScript JavaScript (CommonJS) import { HashSet } from \"@esfx/collections-hashset\"; import { Equatable, Equaler, Comparable, Comparer } from \"@esfx/equatable\"; class Person { firstName: string; lastName: string; constructor(firstName: string, lastName: string) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other: unknown) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other: unknown) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Bob\", \"Clark\"); const obj2 = new Person(\"Bob\", \"Clark\"); const set = new Set<Person>(); // native ECMAScript Set set.add(obj1); set.add(obj2); set.length; // 2 const hashSet = new HashSet<Person>(); hashSet.add(obj1); hashSet.add(obj2); hashSet.length; // 1 const { HashSet } = require(\"@esfx/collections-hashset\"); const { Equatable, Equaler, Comparable, Comparer } = require(\"@esfx/equatable\"); class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Bob\", \"Clark\"); const obj2 = new Person(\"Bob\", \"Clark\"); const set = new Set(); // native ECMAScript Set set.add(obj1); set.add(obj2); set.length; // 2 const hashSet = new HashSet(); hashSet.add(obj1); hashSet.add(obj2); hashSet.length; // 1"
  },
  "api/collections-hashmap.html": {
    "href": "api/collections-hashmap.html",
    "title": "Package @esfx/collections-hashmap | @esfx API Reference",
    "keywords": "Package @esfx/collections-hashmap Provides the HashMap class, a collection class that utilizes @esfx/collection-core and @esfx/equatable . Overview Installation Usage Installation npm i @esfx/collections-hashmap Usage TypeScript JavaScript (CommonJS) import { HashMap } from \"@esfx/collections-hashmap\"; import { Equatable, Equaler, Comparable, Comparer } from \"@esfx/equatable\"; class Person { firstName: string; lastName: string; constructor(firstName: string, lastName: string) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other: unknown) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other: unknown) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Bob\", \"Clark\"); const obj2 = new Person(\"Bob\", \"Clark\"); const set = new Map<Person, string>(); // native ECMAScript Map set.set(obj1, \"obj1\"); set.set(obj2, \"obj2\"); set.size; // 2 const hashMap = new HashMap<Person, string>(); hashMap.set(obj1, \"obj1\"); hashMap.set(obj2, \"obj2\"); hashMap.size; // 1 const { HashMap } = require(\"@esfx/collections-hashmap\"); const { Equatable, Equaler, Comparable, Comparer } = require(\"@esfx/equatable\"); class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } toString() { return `${this.firstName} ${this.lastName}`; } [Equatable.equals](other) { return other instanceof Person && this.lastName === other.lastName && this.firstName === other.firstName; } [Equatable.hash]() { return Equaler.defaultEqualer.hash(this.lastName) ^ Equaler.defaultEqualer.hash(this.firstName); } [Comparable.compareTo](other) { if (!(other instanceof Person)) throw new TypeError(); return Comparer.defaultComparer.compare(this.lastName, other.lastName) || Comparer.defaultComparer.compare(this.firstName, other.firstName); } } const obj1 = new Person(\"Bob\", \"Clark\"); const obj2 = new Person(\"Bob\", \"Clark\"); const set = new Map(); // native ECMAScript Map set.set(obj1, \"obj1\"); set.set(obj2, \"obj2\"); set.size; // 2 const hashMap = new HashMap(); hashMap.set(obj1, \"obj1\"); hashMap.set(obj2, \"obj2\"); hashMap.size; // 1"
  },
  "api/collection-core-dom-shim.html": {
    "href": "api/collection-core-dom-shim.html",
    "title": "Package @esfx/collection-core-dom-shim | @esfx API Reference",
    "keywords": "Package @esfx/collection-core-dom-shim Provides a global shim to add default @esfx/collection-core behaviors to global DOM objects. Overview Installation Usage Installation npm i @esfx/collection-core-dom-shim Usage The global shim adds a default implementation the collection interfaces to the following global DOM objects: AudioParamMap implements: @\"collection-core.ReadonlyKeyedCollection\" AudioTrackList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" CSSRuleList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" CSSStyleDeclaration implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" ClientRectList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" DOMRectList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" DOMStringList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" DOMTokenList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" DataTransferItemList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" FileList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" FormData implements: @\"collection-core.KeyedCollection\" @\"collection-core.ReadonlyKeyedCollection\" HTMLAllCollection implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" HTMLCollectionBase implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" HTMLCollectionOf implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" HTMLFormElement implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" HTMLSelectElement implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" Headers implements: @\"collection-core.KeyedCollection\" @\"collection-core.ReadonlyKeyedCollection\" MediaKeyStatusMap implements: @\"collection-core.ReadonlyKeyedCollection\" MediaList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" MimeTypeArray implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" NamedNodeMap implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" NodeList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" Plugin implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" PluginArray implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" RTCStatsReport implements: @\"collection-core.ReadonlyKeyedCollection\" SVGLengthList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" SVGNumberList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" SVGStringList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" SourceBufferList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" SpeechGrammarList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" SpeechRecognitionResult implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" SpeechRecognitionResultList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" StyleSheetList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" TextTrackCueList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" TextTrackList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" TouchList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" URLSearchParams implements: @\"collection-core.KeyedCollection\" @\"collection-core.ReadonlyKeyedCollection\" @\"collection-core.ReadonlyKeyedCollection\" VideoTrackList implements: @\"collection-core.ReadonlyIndexedCollection\" @\"collection-core.ReadonlyCollection\" To install the global shim, import @esfx/collection-core-dom-shim : TypeScript JavaScript (CommonJS) import \"@esfx/collection-core-dom-shim\"; // triggers global-scope side effects import { ReadonlyIndexedCollection } from \"@esfx/collection-core\"; document.anchors[ReadonlyIndexedCollection.size]; // gets the number of anchors in the document require(\"@esfx/collection-core-dom-shim\"); // triggers global-scope side effects const { ReadonlyIndexedCollection } = require(\"@esfx/collection-core\"); document.anchors[ReadonlyIndexedCollection.size]; // gets the number of anchors in the document"
  },
  "api/cancelable.html": {
    "href": "api/cancelable.html",
    "title": "Package @esfx/cancelable | @esfx API Reference",
    "keywords": "Package @esfx/cancelable The @esfx/cancelable package provides a low-level Symbol-based API for defining a common cancellation protocol. Note This package does not contain an implementation of cancellation signals, but rather provides only a protocol for interoperable libraries that depend on cancellation. For an implementation of this protocol, please consider the following packages: @esfx/async-canceltoken @esfx/cancelable-dom @esfx/cancelable-dom-shim prex (version 0.4.6 or later) Overview Installation Usage Installation npm i @esfx/cancelable Usage TypeScript JavaScript (CommonJS) import { Cancelable } from \"@esfx/cancelable\"; function doSomeWork(cancelable: Cancelable) { return new Promise((resolve, reject) => { const cancelSignal = cancelable[Cancelable.cancelSignal](); if (cancelSignal.signaled) throw new Error(\"Operation canceled.\"); const child = fork(\"worker.js\"); const subscription = cancelSignal.subscribe(() => { // cancellation requested, abort worker worker.kill(); reject(new Error(\"Operation canceled.\")); }); worker.on(\"exit\", () => { subscription.unsubscribe(); resolve(); }); }); } const { Cancelable } = require(\"@esfx/cancelable\"); function doSomeWork(cancelable) { return new Promise((resolve, reject) => { const cancelSignal = cancelable[Cancelable.cancelSignal](); if (cancelSignal.signaled) throw new Error(\"Operation canceled.\"); const child = fork(\"worker.js\"); const subscription = cancelSignal.subscribe(() => { // cancellation requested, abort worker worker.kill(); reject(new Error(\"Operation canceled.\")); }); worker.on(\"exit\", () => { subscription.unsubscribe(); resolve(); }); }); }"
  },
  "api/cancelable-dom.html": {
    "href": "api/cancelable-dom.html",
    "title": "Package @esfx/cancelable-dom | @esfx API Reference",
    "keywords": "Package @esfx/cancelable-dom The @esfx/cancelable-dom package provides a DOM interop library for @esfx/cancelable . Overview Installation Usage Installation npm i @esfx/cancelable-dom Usage TypeScript JavaScript (CommonJS) import { Cancelable } from \"@esfx/cancelable\"; import { toAbortSignal } from \"@esfx/cancelable-dom\"; async function doSomeWork(cancelable: Cancelable) { await fetch(\"some/uri\", { signal: toAbortSignal(cancelable) }); } const { Cancelable } = require(\"@esfx/cancelable\"); const { toAbortSignal } = require(\"@esfx/cancelable-dom\"); async function doSomeWork(cancelable) { await fetch(\"some/uri\", { signal: toAbortSignal(cancelable) }); } Functions toAbortSignal(cancelable) Declaration export declare function toAbortSignal(cancelable: Cancelable): AbortSignal; Parameters cancelable Cancelable Returns AbortSignal"
  },
  "api/async-waitqueue.html": {
    "href": "api/async-waitqueue.html",
    "title": "Package @esfx/async-waitqueue | @esfx API Reference",
    "keywords": "Package @esfx/async-waitqueue The @esfx/async-waitqueue package provides the WaitQueue class, an async coordination primitive used to queue and resolve promises. Overview Installation Usage Installation npm i @esfx/async-waitqueue Usage TypeScript JavaScript (CommonJS) import { WaitQueue } from \"@esfx/async-waitqueue\"; async function main() { const queue = new WaitQueue<number>(); // Create two pending \"waiters\" in the queue const p1 = queue.wait(); const p2 = queue.wait(); // Resolve the two pending \"waiters\" in the queue queue.resolveOne(1); queue.resolveOne(Promise.resolve(2)); await p1; // 1 await p2; // 2 } const { WaitQueue } = require(\"@esfx/async-waitqueue\"); async function main() { const queue = new WaitQueue(); // Create two pending \"waiters\" in the queue const p1 = queue.wait(); const p2 = queue.wait(); // Resolve the two pending \"waiters\" in the queue queue.resolveOne(1); queue.resolveOne(Promise.resolve(2)); await p1; // 1 await p2; // 2 }"
  }
}