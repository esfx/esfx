// @ts-check
const fs = require("fs");
const path = require("path");
const { argv } = require("yargs")
    .option("package", { type: "string", default: process.cwd() })
    .option("force", { type: "boolean" })
    .option("clean", { type: "boolean" });

console.log("Using path:", argv.package);

const copyright = fs.readFileSync(path.join(__dirname, "../CopyrightNotice.txt"), "utf8");
const note = cwd => `// NOTE: This script was generated by '${getRelativeImport(cwd, __filename)}' to\n//       ensure backwards compatibility with package.json's "exports" map.`;
const oldMappings = new Map();
const newMappings = new Map();
const indexFile = normalizeSlashes(path.resolve(path.join(argv.package, "index.js")));
let added = 0;
let removed = 0;

const exportMapFile = path.resolve(argv.package, ".exportmap.json");
if (fs.existsSync(exportMapFile)) {
    const exportMapJson = JSON.parse(fs.readFileSync(exportMapFile, "utf8"));
    for (const [key, value] of Object.entries(exportMapJson)) {
        oldMappings.set(key, value);
    }
}

const packageJson = require(argv.package + "/package.json");
if (packageJson.exports) {
    for (const key of Object.keys(packageJson.exports)) {
        const value = packageJson.exports[key];
        const file = typeof value === "string" ? value :
            Array.isArray(value) ? value[0] :
            typeof value === "object" ? value.require || value.node || value.default :
            undefined;
        if (typeof file !== "string") continue;
        if (key.endsWith("/")) {
            // directory mapping
            console.log(key, "->", file);
            applyDirectoryMapping(key, file);
        }
        else {
            // file mapping
            console.log(key, "->", file);
            applyFileMapping(key, file);
        }
    }
}

for (const [key] of oldMappings) {
    const source = path.resolve(key);
    if (fs.existsSync(source)) {
        fs.unlinkSync(source);
        removed++;
    }
}

if (newMappings.size && !argv.clean) {
    const exportMapJson = {};
    for (const [key, value] of newMappings) {
        exportMapJson[key] = value;
    }
    fs.writeFileSync(exportMapFile, JSON.stringify(exportMapJson, undefined, "  "));
}
else if (fs.existsSync(exportMapFile)) {
    fs.unlinkSync(exportMapFile);
}

console.log("Export redirects added:", added);
console.log("Export redirects removed:", removed);

function applyDirectoryMapping(source, target) {
    for (const entry of fs.readdirSync(target, { withFileTypes: true })) {
        if (entry.name.startsWith("_") || entry.name === "internal") continue;
        const sourceFile = path.join(source, entry.name);
        const targetFile = path.join(target, entry.name);
        if (entry.isDirectory()) {
            applyDirectoryMapping(sourceFile, targetFile);
            if (argv.clean) {
                if (fs.existsSync(sourceFile) && fs.readdirSync(sourceFile).length === 0) {
                    fs.rmdirSync(sourceFile, { recursive: true });
                }
            }
        }
        else if (entry.isFile()) {
            applyFileMapping(sourceFile, targetFile);
        }
    }
}

function applyFileMapping(source, target) {
    if (!target.endsWith(".js")) return;
    if (source === "" || source === ".") source = "index.js";
    if (!source.endsWith(".js")) source += ".js";
    source = normalizeSlashes(path.resolve(source));
    target = normalizeSlashes(path.resolve(target));
    const sourceDts = source.replace(/\.js$/, ".d.ts");
    const targetDts = target.replace(/\.js$/, ".d.ts");

    recordMapping(source, target);
    recordMapping(sourceDts, targetDts);

    if (argv.clean) {
        if (source === indexFile) return;
        if (fs.existsSync(source)) {
            fs.unlinkSync(source);
            removed++;
        }
        if (fs.existsSync(sourceDts)) {
            fs.unlinkSync(sourceDts);
            removed++;
        }
    }
    else {
        const sourceDir = path.dirname(source);
        if (!fs.existsSync(sourceDir)) {
            fs.mkdirSync(sourceDir, { recursive: true });
        }

        const relative = getRelativeImport(sourceDir, target);
        if (fs.existsSync(target) && (argv.force || !fs.existsSync(source))) {
            fs.writeFileSync(source, `${copyright}\n${note(sourceDir)}\nmodule.exports = require("${relative}");\n`);
            added++;
        }

        if (fs.existsSync(targetDts) && (argv.force || !fs.existsSync(sourceDts))) {
            fs.writeFileSync(sourceDts, `${copyright}\n${note(sourceDir)}\nexport * from "${relative}";\n`);
            added++;
        }
    }
}

function getRelativeImport(sourceDir, target) {
    const relativePath = normalizeSlashes(path.relative(sourceDir, target));
    const relativeImport = relativePath.startsWith(".") ? relativePath : "./" + relativePath;
    return relativeImport;
}

function recordMapping(source, target) {
    source = getRelativeImport(argv.package, source);
    target = getRelativeImport(argv.package, target);
    newMappings.set(source, target);
    oldMappings.delete(source);
}

function normalizeSlashes(file) {
    return file.replace(/\\/g, "/");
}